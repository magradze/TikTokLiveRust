// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AuditStatus {
    Auditstatusunknown = 0,
    Auditstatuspass = 1,
    Auditstatusfailed = 2,
    Auditstatusreviewing = 3,
    Auditstatusforbidden = 4,
}
impl AuditStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AuditStatus::Auditstatusunknown => "AUDITSTATUSUNKNOWN",
            AuditStatus::Auditstatuspass => "AUDITSTATUSPASS",
            AuditStatus::Auditstatusfailed => "AUDITSTATUSFAILED",
            AuditStatus::Auditstatusreviewing => "AUDITSTATUSREVIEWING",
            AuditStatus::Auditstatusforbidden => "AUDITSTATUSFORBIDDEN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AUDITSTATUSUNKNOWN" => Some(Self::Auditstatusunknown),
            "AUDITSTATUSPASS" => Some(Self::Auditstatuspass),
            "AUDITSTATUSFAILED" => Some(Self::Auditstatusfailed),
            "AUDITSTATUSREVIEWING" => Some(Self::Auditstatusreviewing),
            "AUDITSTATUSFORBIDDEN" => Some(Self::Auditstatusforbidden),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EmoteType {
    Emotetypenormal = 0,
    Emotetypewithsticker = 1,
}
impl EmoteType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EmoteType::Emotetypenormal => "EMOTETYPENORMAL",
            EmoteType::Emotetypewithsticker => "EMOTETYPEWITHSTICKER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EMOTETYPENORMAL" => Some(Self::Emotetypenormal),
            "EMOTETYPEWITHSTICKER" => Some(Self::Emotetypewithsticker),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ContentSource {
    Contentsourceunknown = 0,
    Contentsourcenormal = 1,
    Contentsourcecamera = 2,
}
impl ContentSource {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ContentSource::Contentsourceunknown => "CONTENTSOURCEUNKNOWN",
            ContentSource::Contentsourcenormal => "CONTENTSOURCENORMAL",
            ContentSource::Contentsourcecamera => "CONTENTSOURCECAMERA",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONTENTSOURCEUNKNOWN" => Some(Self::Contentsourceunknown),
            "CONTENTSOURCENORMAL" => Some(Self::Contentsourcenormal),
            "CONTENTSOURCECAMERA" => Some(Self::Contentsourcecamera),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EmotePrivateType {
    Normal = 0,
    SubWave = 1,
}
impl EmotePrivateType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EmotePrivateType::Normal => "EMOTE_PRIVATE_TYPE_NORMAL",
            EmotePrivateType::SubWave => "EMOTE_PRIVATE_TYPE_SUB_WAVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EMOTE_PRIVATE_TYPE_NORMAL" => Some(Self::Normal),
            "EMOTE_PRIVATE_TYPE_SUB_WAVE" => Some(Self::SubWave),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TextType {
    DisplayText = 0,
    Content = 1,
}
impl TextType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TextType::DisplayText => "DISPLAY_TEXT",
            TextType::Content => "CONTENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DISPLAY_TEXT" => Some(Self::DisplayText),
            "CONTENT" => Some(Self::Content),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LinkmicApplierSortSetting {
    None = 0,
    ByGiftScore = 1,
}
impl LinkmicApplierSortSetting {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LinkmicApplierSortSetting::None => "LINKMIC_APPLIER_SORT_SETTING_NONE",
            LinkmicApplierSortSetting::ByGiftScore => {
                "LINKMIC_APPLIER_SORT_SETTING_BY_GIFT_SCORE"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LINKMIC_APPLIER_SORT_SETTING_NONE" => Some(Self::None),
            "LINKMIC_APPLIER_SORT_SETTING_BY_GIFT_SCORE" => Some(Self::ByGiftScore),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HashtagNamespace {
    Global = 0,
    Gaming = 1,
}
impl HashtagNamespace {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            HashtagNamespace::Global => "GLOBAL",
            HashtagNamespace::Gaming => "GAMING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GLOBAL" => Some(Self::Global),
            "GAMING" => Some(Self::Gaming),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AgreeStatus {
    AgreeUnknown = 0,
    Agree = 1,
    Reject = 2,
}
impl AgreeStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AgreeStatus::AgreeUnknown => "AGREE_UNKNOWN",
            AgreeStatus::Agree => "AGREE",
            AgreeStatus::Reject => "REJECT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AGREE_UNKNOWN" => Some(Self::AgreeUnknown),
            "AGREE" => Some(Self::Agree),
            "REJECT" => Some(Self::Reject),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KickoutReason {
    Unknown = 0,
    FirstFrameTimeout = 1,
    ByHost = 2,
    RtcLostConnection = 3,
    ByPunish = 4,
    ByAdmin = 5,
    HostRemoveAllGuests = 6,
}
impl KickoutReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            KickoutReason::Unknown => "KICKOUT_REASON_UNKNOWN",
            KickoutReason::FirstFrameTimeout => "KICKOUT_REASON_FIRST_FRAME_TIMEOUT",
            KickoutReason::ByHost => "KICKOUT_REASON_BY_HOST",
            KickoutReason::RtcLostConnection => "KICKOUT_REASON_RTC_LOST_CONNECTION",
            KickoutReason::ByPunish => "KICKOUT_REASON_BY_PUNISH",
            KickoutReason::ByAdmin => "KICKOUT_REASON_BY_ADMIN",
            KickoutReason::HostRemoveAllGuests => "KICKOUT_REASON_HOST_REMOVE_ALL_GUESTS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "KICKOUT_REASON_UNKNOWN" => Some(Self::Unknown),
            "KICKOUT_REASON_FIRST_FRAME_TIMEOUT" => Some(Self::FirstFrameTimeout),
            "KICKOUT_REASON_BY_HOST" => Some(Self::ByHost),
            "KICKOUT_REASON_RTC_LOST_CONNECTION" => Some(Self::RtcLostConnection),
            "KICKOUT_REASON_BY_PUNISH" => Some(Self::ByPunish),
            "KICKOUT_REASON_BY_ADMIN" => Some(Self::ByAdmin),
            "KICKOUT_REASON_HOST_REMOVE_ALL_GUESTS" => Some(Self::HostRemoveAllGuests),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GroupStatus {
    Unknown = 0,
    Waiting = 1,
    Linked = 3,
}
impl GroupStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            GroupStatus::Unknown => "GROUP_STATUS_UNKNOWN",
            GroupStatus::Waiting => "GROUP_STATUS_WAITING",
            GroupStatus::Linked => "GROUP_STATUS_LINKED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GROUP_STATUS_UNKNOWN" => Some(Self::Unknown),
            "GROUP_STATUS_WAITING" => Some(Self::Waiting),
            "GROUP_STATUS_LINKED" => Some(Self::Linked),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BusinessCase {
    BusinessNotSet = 0,
    ApplyBizContent = 1,
    InviteBizContent = 2,
    ReplyBizContent = 3,
    PermitBizContent = 4,
    JoinDirectBizContent = 5,
    KickOutBizContent = 6,
    ListChangeBizContent = 11,
    MultiLiveContent = 100,
    CohostContent = 200,
}
impl BusinessCase {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            BusinessCase::BusinessNotSet => "BUSINESS_NOT_SET",
            BusinessCase::ApplyBizContent => "APPLY_BIZ_CONTENT",
            BusinessCase::InviteBizContent => "INVITE_BIZ_CONTENT",
            BusinessCase::ReplyBizContent => "REPLY_BIZ_CONTENT",
            BusinessCase::PermitBizContent => "PERMIT_BIZ_CONTENT",
            BusinessCase::JoinDirectBizContent => "JOIN_DIRECT_BIZ_CONTENT",
            BusinessCase::KickOutBizContent => "KICK_OUT_BIZ_CONTENT",
            BusinessCase::ListChangeBizContent => "LIST_CHANGE_BIZ_CONTENT",
            BusinessCase::MultiLiveContent => "MULTI_LIVE_CONTENT",
            BusinessCase::CohostContent => "COHOST_CONTENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BUSINESS_NOT_SET" => Some(Self::BusinessNotSet),
            "APPLY_BIZ_CONTENT" => Some(Self::ApplyBizContent),
            "INVITE_BIZ_CONTENT" => Some(Self::InviteBizContent),
            "REPLY_BIZ_CONTENT" => Some(Self::ReplyBizContent),
            "PERMIT_BIZ_CONTENT" => Some(Self::PermitBizContent),
            "JOIN_DIRECT_BIZ_CONTENT" => Some(Self::JoinDirectBizContent),
            "KICK_OUT_BIZ_CONTENT" => Some(Self::KickOutBizContent),
            "LIST_CHANGE_BIZ_CONTENT" => Some(Self::ListChangeBizContent),
            "MULTI_LIVE_CONTENT" => Some(Self::MultiLiveContent),
            "COHOST_CONTENT" => Some(Self::CohostContent),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReplyStatus {
    Unknown = 0,
    Agree = 1,
    RefusePersonally = 2,
    RefuseTypeNotSupport = 3,
    RefuseProcessingInvitation = 4,
    RefuseByTimeout = 5,
    RefuseException = 6,
    RefuseSystemNotSupported = 7,
    RefuseSubtypeDifference = 8,
    RefuseInMicroom = 9,
    RefuseNotLoadPlugin = 10,
    RefuseInMultiGuest = 11,
    RefusePauseLive = 12,
    RefuseOpenCameraDialogShowing = 13,
    RefuseDrawGuessing = 14,
    RefuseRandomMatching = 15,
    RefuseInMatchProcessing = 16,
    RefuseInMicroomForMultiCohost = 17,
    RefuseCohostFinished = 18,
    RefuseNotConnected = 19,
    RefuseLinkmicFull = 20,
    RefuseArcIncompatible = 21,
    RefuseProcessingOtherInvite = 22,
    RefuseProcessingOtherApply = 23,
    RefuseInAnchorCohost = 24,
    RefuseTopicPairing = 25,
}
impl ReplyStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ReplyStatus::Unknown => "REPLY_STATUS_UNKNOWN",
            ReplyStatus::Agree => "REPLY_STATUS_AGREE",
            ReplyStatus::RefusePersonally => "REPLY_STATUS_REFUSE_PERSONALLY",
            ReplyStatus::RefuseTypeNotSupport => "REPLY_STATUS_REFUSE_TYPE_NOT_SUPPORT",
            ReplyStatus::RefuseProcessingInvitation => {
                "REPLY_STATUS_REFUSE_PROCESSING_INVITATION"
            }
            ReplyStatus::RefuseByTimeout => "REPLY_STATUS_REFUSE_BY_TIMEOUT",
            ReplyStatus::RefuseException => "REPLY_STATUS_REFUSE_EXCEPTION",
            ReplyStatus::RefuseSystemNotSupported => {
                "REPLY_STATUS_REFUSE_SYSTEM_NOT_SUPPORTED"
            }
            ReplyStatus::RefuseSubtypeDifference => {
                "REPLY_STATUS_REFUSE_SUBTYPE_DIFFERENCE"
            }
            ReplyStatus::RefuseInMicroom => "REPLY_STATUS_REFUSE_IN_MICROOM",
            ReplyStatus::RefuseNotLoadPlugin => "REPLY_STATUS_REFUSE_NOT_LOAD_PLUGIN",
            ReplyStatus::RefuseInMultiGuest => "REPLY_STATUS_REFUSE_IN_MULTI_GUEST",
            ReplyStatus::RefusePauseLive => "REPLY_STATUS_REFUSE_PAUSE_LIVE",
            ReplyStatus::RefuseOpenCameraDialogShowing => {
                "REPLY_STATUS_REFUSE_OPEN_CAMERA_DIALOG_SHOWING"
            }
            ReplyStatus::RefuseDrawGuessing => "REPLY_STATUS_REFUSE_DRAW_GUESSING",
            ReplyStatus::RefuseRandomMatching => "REPLY_STATUS_REFUSE_RANDOM_MATCHING",
            ReplyStatus::RefuseInMatchProcessing => {
                "REPLY_STATUS_REFUSE_IN_MATCH_PROCESSING"
            }
            ReplyStatus::RefuseInMicroomForMultiCohost => {
                "REPLY_STATUS_REFUSE_IN_MICROOM_FOR_MULTI_COHOST"
            }
            ReplyStatus::RefuseCohostFinished => "REPLY_STATUS_REFUSE_COHOST_FINISHED",
            ReplyStatus::RefuseNotConnected => "REPLY_STATUS_REFUSE_NOT_CONNECTED",
            ReplyStatus::RefuseLinkmicFull => "REPLY_STATUS_REFUSE_LINKMIC_FULL",
            ReplyStatus::RefuseArcIncompatible => "REPLY_STATUS_REFUSE_ARC_INCOMPATIBLE",
            ReplyStatus::RefuseProcessingOtherInvite => {
                "REPLY_STATUS_REFUSE_PROCESSING_OTHER_INVITE"
            }
            ReplyStatus::RefuseProcessingOtherApply => {
                "REPLY_STATUS_REFUSE_PROCESSING_OTHER_APPLY"
            }
            ReplyStatus::RefuseInAnchorCohost => "REPLY_STATUS_REFUSE_IN_ANCHOR_COHOST",
            ReplyStatus::RefuseTopicPairing => "REPLY_STATUS_REFUSE_TOPIC_PAIRING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REPLY_STATUS_UNKNOWN" => Some(Self::Unknown),
            "REPLY_STATUS_AGREE" => Some(Self::Agree),
            "REPLY_STATUS_REFUSE_PERSONALLY" => Some(Self::RefusePersonally),
            "REPLY_STATUS_REFUSE_TYPE_NOT_SUPPORT" => Some(Self::RefuseTypeNotSupport),
            "REPLY_STATUS_REFUSE_PROCESSING_INVITATION" => {
                Some(Self::RefuseProcessingInvitation)
            }
            "REPLY_STATUS_REFUSE_BY_TIMEOUT" => Some(Self::RefuseByTimeout),
            "REPLY_STATUS_REFUSE_EXCEPTION" => Some(Self::RefuseException),
            "REPLY_STATUS_REFUSE_SYSTEM_NOT_SUPPORTED" => {
                Some(Self::RefuseSystemNotSupported)
            }
            "REPLY_STATUS_REFUSE_SUBTYPE_DIFFERENCE" => {
                Some(Self::RefuseSubtypeDifference)
            }
            "REPLY_STATUS_REFUSE_IN_MICROOM" => Some(Self::RefuseInMicroom),
            "REPLY_STATUS_REFUSE_NOT_LOAD_PLUGIN" => Some(Self::RefuseNotLoadPlugin),
            "REPLY_STATUS_REFUSE_IN_MULTI_GUEST" => Some(Self::RefuseInMultiGuest),
            "REPLY_STATUS_REFUSE_PAUSE_LIVE" => Some(Self::RefusePauseLive),
            "REPLY_STATUS_REFUSE_OPEN_CAMERA_DIALOG_SHOWING" => {
                Some(Self::RefuseOpenCameraDialogShowing)
            }
            "REPLY_STATUS_REFUSE_DRAW_GUESSING" => Some(Self::RefuseDrawGuessing),
            "REPLY_STATUS_REFUSE_RANDOM_MATCHING" => Some(Self::RefuseRandomMatching),
            "REPLY_STATUS_REFUSE_IN_MATCH_PROCESSING" => {
                Some(Self::RefuseInMatchProcessing)
            }
            "REPLY_STATUS_REFUSE_IN_MICROOM_FOR_MULTI_COHOST" => {
                Some(Self::RefuseInMicroomForMultiCohost)
            }
            "REPLY_STATUS_REFUSE_COHOST_FINISHED" => Some(Self::RefuseCohostFinished),
            "REPLY_STATUS_REFUSE_NOT_CONNECTED" => Some(Self::RefuseNotConnected),
            "REPLY_STATUS_REFUSE_LINKMIC_FULL" => Some(Self::RefuseLinkmicFull),
            "REPLY_STATUS_REFUSE_ARC_INCOMPATIBLE" => Some(Self::RefuseArcIncompatible),
            "REPLY_STATUS_REFUSE_PROCESSING_OTHER_INVITE" => {
                Some(Self::RefuseProcessingOtherInvite)
            }
            "REPLY_STATUS_REFUSE_PROCESSING_OTHER_APPLY" => {
                Some(Self::RefuseProcessingOtherApply)
            }
            "REPLY_STATUS_REFUSE_IN_ANCHOR_COHOST" => Some(Self::RefuseInAnchorCohost),
            "REPLY_STATUS_REFUSE_TOPIC_PAIRING" => Some(Self::RefuseTopicPairing),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SubscribeType {
    SubscribetypeOnce = 0,
    SubscribetypeAuto = 1,
    SubscribetypeDefault = 100,
}
impl SubscribeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SubscribeType::SubscribetypeOnce => "SUBSCRIBETYPE_ONCE",
            SubscribeType::SubscribetypeAuto => "SUBSCRIBETYPE_AUTO",
            SubscribeType::SubscribetypeDefault => "SUBSCRIBETYPE_DEFAULT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SUBSCRIBETYPE_ONCE" => Some(Self::SubscribetypeOnce),
            "SUBSCRIBETYPE_AUTO" => Some(Self::SubscribetypeAuto),
            "SUBSCRIBETYPE_DEFAULT" => Some(Self::SubscribetypeDefault),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OldSubscribeStatus {
    First = 0,
    Resub = 1,
    SubinGracePeriod = 2,
    SubNotinGracePeriod = 3,
    Default = 100,
}
impl OldSubscribeStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            OldSubscribeStatus::First => "OLD_SUBSCRIBE_STATUS_FIRST",
            OldSubscribeStatus::Resub => "OLD_SUBSCRIBE_STATUS_RESUB",
            OldSubscribeStatus::SubinGracePeriod => {
                "OLD_SUBSCRIBE_STATUS_SUBIN_GRACE_PERIOD"
            }
            OldSubscribeStatus::SubNotinGracePeriod => {
                "OLD_SUBSCRIBE_STATUS_SUB_NOTIN_GRACE_PERIOD"
            }
            OldSubscribeStatus::Default => "OLD_SUBSCRIBE_STATUS_DEFAULT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OLD_SUBSCRIBE_STATUS_FIRST" => Some(Self::First),
            "OLD_SUBSCRIBE_STATUS_RESUB" => Some(Self::Resub),
            "OLD_SUBSCRIBE_STATUS_SUBIN_GRACE_PERIOD" => Some(Self::SubinGracePeriod),
            "OLD_SUBSCRIBE_STATUS_SUB_NOTIN_GRACE_PERIOD" => {
                Some(Self::SubNotinGracePeriod)
            }
            "OLD_SUBSCRIBE_STATUS_DEFAULT" => Some(Self::Default),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SubscribingStatus {
    Unknown = 0,
    Once = 1,
    Circle = 2,
    CircleCancel = 3,
    Refund = 4,
    InGracePeriod = 5,
    NotInGracePeriod = 6,
}
impl SubscribingStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SubscribingStatus::Unknown => "SUBSCRIBING_STATUS_UNKNOWN",
            SubscribingStatus::Once => "SUBSCRIBING_STATUS_ONCE",
            SubscribingStatus::Circle => "SUBSCRIBING_STATUS_CIRCLE",
            SubscribingStatus::CircleCancel => "SUBSCRIBING_STATUS_CIRCLE_CANCEL",
            SubscribingStatus::Refund => "SUBSCRIBING_STATUS_REFUND",
            SubscribingStatus::InGracePeriod => "SUBSCRIBING_STATUS_IN_GRACE_PERIOD",
            SubscribingStatus::NotInGracePeriod => {
                "SUBSCRIBING_STATUS_NOT_IN_GRACE_PERIOD"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SUBSCRIBING_STATUS_UNKNOWN" => Some(Self::Unknown),
            "SUBSCRIBING_STATUS_ONCE" => Some(Self::Once),
            "SUBSCRIBING_STATUS_CIRCLE" => Some(Self::Circle),
            "SUBSCRIBING_STATUS_CIRCLE_CANCEL" => Some(Self::CircleCancel),
            "SUBSCRIBING_STATUS_REFUND" => Some(Self::Refund),
            "SUBSCRIBING_STATUS_IN_GRACE_PERIOD" => Some(Self::InGracePeriod),
            "SUBSCRIBING_STATUS_NOT_IN_GRACE_PERIOD" => Some(Self::NotInGracePeriod),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LinkmicStatus {
    Disable = 0,
    Enable = 1,
    JustFollowing = 2,
    MultiLinking = 3,
    MultiLinkingOnlyFollowing = 4,
}
impl LinkmicStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LinkmicStatus::Disable => "Disable",
            LinkmicStatus::Enable => "Enable",
            LinkmicStatus::JustFollowing => "Just_Following",
            LinkmicStatus::MultiLinking => "Multi_Linking",
            LinkmicStatus::MultiLinkingOnlyFollowing => "Multi_Linking_Only_Following",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Disable" => Some(Self::Disable),
            "Enable" => Some(Self::Enable),
            "Just_Following" => Some(Self::JustFollowing),
            "Multi_Linking" => Some(Self::MultiLinking),
            "Multi_Linking_Only_Following" => Some(Self::MultiLinkingOnlyFollowing),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MemberMessageAction {
    Unknown = 0,
    /// User Joined the Stream
    Joined = 1,
    /// User Subscribed to the Host
    Subscribed = 3,
}
impl MemberMessageAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            MemberMessageAction::Unknown => "UNKNOWN",
            MemberMessageAction::Joined => "JOINED",
            MemberMessageAction::Subscribed => "SUBSCRIBED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN" => Some(Self::Unknown),
            "JOINED" => Some(Self::Joined),
            "SUBSCRIBED" => Some(Self::Subscribed),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ControlAction {
    FallbackUnknown = 0,
    StreamPaused = 1,
    StreamUnpaused = 2,
    StreamEnded = 3,
    StreamSuspended = 4,
}
impl ControlAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ControlAction::FallbackUnknown => "CONTROL_ACTION_FALLBACK_UNKNOWN",
            ControlAction::StreamPaused => "CONTROL_ACTION_STREAM_PAUSED",
            ControlAction::StreamUnpaused => "CONTROL_ACTION_STREAM_UNPAUSED",
            ControlAction::StreamEnded => "CONTROL_ACTION_STREAM_ENDED",
            ControlAction::StreamSuspended => "CONTROL_ACTION_STREAM_SUSPENDED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONTROL_ACTION_FALLBACK_UNKNOWN" => Some(Self::FallbackUnknown),
            "CONTROL_ACTION_STREAM_PAUSED" => Some(Self::StreamPaused),
            "CONTROL_ACTION_STREAM_UNPAUSED" => Some(Self::StreamUnpaused),
            "CONTROL_ACTION_STREAM_ENDED" => Some(Self::StreamEnded),
            "CONTROL_ACTION_STREAM_SUSPENDED" => Some(Self::StreamSuspended),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LinkLayerMessageType {
    LinkerUnknown = 0,
    LinkerCreate = 1,
    LinkerInvite = 2,
    LinkerApply = 3,
    LinkerPermit = 4,
    LinkerReply = 5,
    LinkerKickOut = 6,
    LinkerCancelApply = 7,
    LinkerCancelInvite = 8,
    LinkerLeave = 9,
    LinkerFinish = 10,
    LinkerListChange = 11,
    LinkerJoinDirect = 12,
    LinkerJoinGroup = 13,
    LinkerPermitGroup = 14,
    LinkerCancelGroup = 15,
    LinkerLeaveGroup = 16,
    LinkerP2pGroupChange = 17,
    LinkerGroupChange = 18,
}
impl LinkLayerMessageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LinkLayerMessageType::LinkerUnknown => "Linker_Unknown",
            LinkLayerMessageType::LinkerCreate => "Linker_Create",
            LinkLayerMessageType::LinkerInvite => "Linker_Invite",
            LinkLayerMessageType::LinkerApply => "Linker_Apply",
            LinkLayerMessageType::LinkerPermit => "Linker_Permit",
            LinkLayerMessageType::LinkerReply => "Linker_Reply",
            LinkLayerMessageType::LinkerKickOut => "Linker_Kick_Out",
            LinkLayerMessageType::LinkerCancelApply => "Linker_Cancel_Apply",
            LinkLayerMessageType::LinkerCancelInvite => "Linker_Cancel_Invite",
            LinkLayerMessageType::LinkerLeave => "Linker_Leave",
            LinkLayerMessageType::LinkerFinish => "Linker_Finish",
            LinkLayerMessageType::LinkerListChange => "Linker_List_Change",
            LinkLayerMessageType::LinkerJoinDirect => "Linker_Join_Direct",
            LinkLayerMessageType::LinkerJoinGroup => "Linker_Join_Group",
            LinkLayerMessageType::LinkerPermitGroup => "Linker_Permit_Group",
            LinkLayerMessageType::LinkerCancelGroup => "Linker_Cancel_Group",
            LinkLayerMessageType::LinkerLeaveGroup => "Linker_Leave_Group",
            LinkLayerMessageType::LinkerP2pGroupChange => "Linker_P2P_Group_Change",
            LinkLayerMessageType::LinkerGroupChange => "Linker_Group_Change",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Linker_Unknown" => Some(Self::LinkerUnknown),
            "Linker_Create" => Some(Self::LinkerCreate),
            "Linker_Invite" => Some(Self::LinkerInvite),
            "Linker_Apply" => Some(Self::LinkerApply),
            "Linker_Permit" => Some(Self::LinkerPermit),
            "Linker_Reply" => Some(Self::LinkerReply),
            "Linker_Kick_Out" => Some(Self::LinkerKickOut),
            "Linker_Cancel_Apply" => Some(Self::LinkerCancelApply),
            "Linker_Cancel_Invite" => Some(Self::LinkerCancelInvite),
            "Linker_Leave" => Some(Self::LinkerLeave),
            "Linker_Finish" => Some(Self::LinkerFinish),
            "Linker_List_Change" => Some(Self::LinkerListChange),
            "Linker_Join_Direct" => Some(Self::LinkerJoinDirect),
            "Linker_Join_Group" => Some(Self::LinkerJoinGroup),
            "Linker_Permit_Group" => Some(Self::LinkerPermitGroup),
            "Linker_Cancel_Group" => Some(Self::LinkerCancelGroup),
            "Linker_Leave_Group" => Some(Self::LinkerLeaveGroup),
            "Linker_P2P_Group_Change" => Some(Self::LinkerP2pGroupChange),
            "Linker_Group_Change" => Some(Self::LinkerGroupChange),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BarrageType {
    Unknown = 0,
    EComOrdering = 1,
    EComBuying = 2,
    Normal = 3,
    Subscribe = 4,
    EventView = 5,
    EventRegistered = 6,
    SubscribeGift = 7,
    UserUpgrade = 8,
    GradeUserEntranceNotification = 9,
    FansLevelUpgrade = 10,
    FansLevelEntrance = 11,
    GamePartnership = 12,
}
impl BarrageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            BarrageType::Unknown => "BarrageType_Unknown",
            BarrageType::EComOrdering => "EComOrdering",
            BarrageType::EComBuying => "EComBuying",
            BarrageType::Normal => "Normal",
            BarrageType::Subscribe => "Subscribe",
            BarrageType::EventView => "EventView",
            BarrageType::EventRegistered => "EventRegistered",
            BarrageType::SubscribeGift => "SubscribeGift",
            BarrageType::UserUpgrade => "UserUpgrade",
            BarrageType::GradeUserEntranceNotification => "GradeUserEntranceNotification",
            BarrageType::FansLevelUpgrade => "FansLevelUpgrade",
            BarrageType::FansLevelEntrance => "FansLevelEntrance",
            BarrageType::GamePartnership => "GamePartnership",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BarrageType_Unknown" => Some(Self::Unknown),
            "EComOrdering" => Some(Self::EComOrdering),
            "EComBuying" => Some(Self::EComBuying),
            "Normal" => Some(Self::Normal),
            "Subscribe" => Some(Self::Subscribe),
            "EventView" => Some(Self::EventView),
            "EventRegistered" => Some(Self::EventRegistered),
            "SubscribeGift" => Some(Self::SubscribeGift),
            "UserUpgrade" => Some(Self::UserUpgrade),
            "GradeUserEntranceNotification" => Some(Self::GradeUserEntranceNotification),
            "FansLevelUpgrade" => Some(Self::FansLevelUpgrade),
            "FansLevelEntrance" => Some(Self::FansLevelEntrance),
            "GamePartnership" => Some(Self::GamePartnership),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EnvelopeBusinessType {
    BusinessTypeUnknown = 0,
    BusinessTypeUserDiamond = 1,
    BusinessTypePlatformDiamond = 2,
    BusinessTypePlatformShell = 3,
    BusinessTypePortal = 4,
    BusinessTypePlatformMerch = 5,
    BusinessTypeEoYDiamond = 6,
    BusinessTypeFanClubGtM = 7,
}
impl EnvelopeBusinessType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EnvelopeBusinessType::BusinessTypeUnknown => "BusinessTypeUnknown",
            EnvelopeBusinessType::BusinessTypeUserDiamond => "BusinessTypeUserDiamond",
            EnvelopeBusinessType::BusinessTypePlatformDiamond => {
                "BusinessTypePlatformDiamond"
            }
            EnvelopeBusinessType::BusinessTypePlatformShell => {
                "BusinessTypePlatformShell"
            }
            EnvelopeBusinessType::BusinessTypePortal => "BusinessTypePortal",
            EnvelopeBusinessType::BusinessTypePlatformMerch => {
                "BusinessTypePlatformMerch"
            }
            EnvelopeBusinessType::BusinessTypeEoYDiamond => "BusinessTypeEoYDiamond",
            EnvelopeBusinessType::BusinessTypeFanClubGtM => "BusinessTypeFanClubGtM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BusinessTypeUnknown" => Some(Self::BusinessTypeUnknown),
            "BusinessTypeUserDiamond" => Some(Self::BusinessTypeUserDiamond),
            "BusinessTypePlatformDiamond" => Some(Self::BusinessTypePlatformDiamond),
            "BusinessTypePlatformShell" => Some(Self::BusinessTypePlatformShell),
            "BusinessTypePortal" => Some(Self::BusinessTypePortal),
            "BusinessTypePlatformMerch" => Some(Self::BusinessTypePlatformMerch),
            "BusinessTypeEoYDiamond" => Some(Self::BusinessTypeEoYDiamond),
            "BusinessTypeFanClubGtM" => Some(Self::BusinessTypeFanClubGtM),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EnvelopeFollowShowStatus {
    EnvelopeFollowShowUnknown = 0,
    EnvelopeFollowShow = 1,
    EnvelopeFollowNotShow = 2,
}
impl EnvelopeFollowShowStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EnvelopeFollowShowStatus::EnvelopeFollowShowUnknown => {
                "ENVELOPE_FOLLOW_SHOW_STATUS_ENVELOPE_FOLLOW_SHOW_UNKNOWN"
            }
            EnvelopeFollowShowStatus::EnvelopeFollowShow => {
                "ENVELOPE_FOLLOW_SHOW_STATUS_ENVELOPE_FOLLOW_SHOW"
            }
            EnvelopeFollowShowStatus::EnvelopeFollowNotShow => {
                "ENVELOPE_FOLLOW_SHOW_STATUS_ENVELOPE_FOLLOW_NOT_SHOW"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENVELOPE_FOLLOW_SHOW_STATUS_ENVELOPE_FOLLOW_SHOW_UNKNOWN" => {
                Some(Self::EnvelopeFollowShowUnknown)
            }
            "ENVELOPE_FOLLOW_SHOW_STATUS_ENVELOPE_FOLLOW_SHOW" => {
                Some(Self::EnvelopeFollowShow)
            }
            "ENVELOPE_FOLLOW_SHOW_STATUS_ENVELOPE_FOLLOW_NOT_SHOW" => {
                Some(Self::EnvelopeFollowNotShow)
            }
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EnvelopeDisplay {
    Unknown = 0,
    New = 1,
    Hide = 2,
}
impl EnvelopeDisplay {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EnvelopeDisplay::Unknown => "ENVELOPE_DISPLAY_UNKNOWN",
            EnvelopeDisplay::New => "ENVELOPE_DISPLAY_NEW",
            EnvelopeDisplay::Hide => "ENVELOPE_DISPLAY_HIDE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENVELOPE_DISPLAY_UNKNOWN" => Some(Self::Unknown),
            "ENVELOPE_DISPLAY_NEW" => Some(Self::New),
            "ENVELOPE_DISPLAY_HIDE" => Some(Self::Hide),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CommonContentCase {
    CommonContentNotSet = 0,
    CreateChannelContent = 100,
    ListChangeContent = 102,
    InviteContent = 103,
    ApplyContent = 104,
    PermitApplyContent = 105,
    ReplyInviteContent = 106,
    KickOutContent = 107,
    CancelApplyContent = 108,
    CancelInviteContent = 109,
    LeaveContent = 110,
    FinishContent = 111,
    JoinDirectContent = 112,
    JoinGroupContent = 113,
    PermitGroupContent = 114,
    CancelGroupContent = 115,
    LeaveGroupContent = 116,
    P2pGroupChangeContent = 117,
    GroupChangeContent = 118,
}
impl CommonContentCase {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CommonContentCase::CommonContentNotSet => "COMMON_CONTENT_NOT_SET",
            CommonContentCase::CreateChannelContent => "CREATE_CHANNEL_CONTENT",
            CommonContentCase::ListChangeContent => "LIST_CHANGE_CONTENT",
            CommonContentCase::InviteContent => "INVITE_CONTENT",
            CommonContentCase::ApplyContent => "APPLY_CONTENT",
            CommonContentCase::PermitApplyContent => "PERMIT_APPLY_CONTENT",
            CommonContentCase::ReplyInviteContent => "REPLY_INVITE_CONTENT",
            CommonContentCase::KickOutContent => "KICK_OUT_CONTENT",
            CommonContentCase::CancelApplyContent => "CANCEL_APPLY_CONTENT",
            CommonContentCase::CancelInviteContent => "CANCEL_INVITE_CONTENT",
            CommonContentCase::LeaveContent => "LEAVE_CONTENT",
            CommonContentCase::FinishContent => "FINISH_CONTENT",
            CommonContentCase::JoinDirectContent => "JOIN_DIRECT_CONTENT",
            CommonContentCase::JoinGroupContent => "JOIN_GROUP_CONTENT",
            CommonContentCase::PermitGroupContent => "PERMIT_GROUP_CONTENT",
            CommonContentCase::CancelGroupContent => "CANCEL_GROUP_CONTENT",
            CommonContentCase::LeaveGroupContent => "LEAVE_GROUP_CONTENT",
            CommonContentCase::P2pGroupChangeContent => "P2P_GROUP_CHANGE_CONTENT",
            CommonContentCase::GroupChangeContent => "GROUP_CHANGE_CONTENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMMON_CONTENT_NOT_SET" => Some(Self::CommonContentNotSet),
            "CREATE_CHANNEL_CONTENT" => Some(Self::CreateChannelContent),
            "LIST_CHANGE_CONTENT" => Some(Self::ListChangeContent),
            "INVITE_CONTENT" => Some(Self::InviteContent),
            "APPLY_CONTENT" => Some(Self::ApplyContent),
            "PERMIT_APPLY_CONTENT" => Some(Self::PermitApplyContent),
            "REPLY_INVITE_CONTENT" => Some(Self::ReplyInviteContent),
            "KICK_OUT_CONTENT" => Some(Self::KickOutContent),
            "CANCEL_APPLY_CONTENT" => Some(Self::CancelApplyContent),
            "CANCEL_INVITE_CONTENT" => Some(Self::CancelInviteContent),
            "LEAVE_CONTENT" => Some(Self::LeaveContent),
            "FINISH_CONTENT" => Some(Self::FinishContent),
            "JOIN_DIRECT_CONTENT" => Some(Self::JoinDirectContent),
            "JOIN_GROUP_CONTENT" => Some(Self::JoinGroupContent),
            "PERMIT_GROUP_CONTENT" => Some(Self::PermitGroupContent),
            "CANCEL_GROUP_CONTENT" => Some(Self::CancelGroupContent),
            "LEAVE_GROUP_CONTENT" => Some(Self::LeaveGroupContent),
            "P2P_GROUP_CHANGE_CONTENT" => Some(Self::P2pGroupChangeContent),
            "GROUP_CHANGE_CONTENT" => Some(Self::GroupChangeContent),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LinkMessageType {
    TypeLinkerUnknown = 0,
    TypeLinkerCreate = 1,
    TypeLinkerClose = 2,
    TypeLinkerInvite = 3,
    TypeLinkerApply = 4,
    TypeLinkerReply = 5,
    TypeLinkerEnter = 6,
    TypeLinkerLeave = 7,
    TypeLinkerPermit = 8,
    TypeLinkerCancelInvite = 9,
    TypeLinkerWaitingListChange = 10,
    TypeLinkerLinkedListChange = 11,
    TypeLinkerUpdateUser = 12,
    TypeLinkerKickOut = 13,
    TypeLinkerCancelApply = 14,
    TypeLinkerMute = 15,
    TypeLinkerMatch = 16,
    TypeLinkerUpdateUserSetting = 17,
    TypeLinkerMicIdxUpdate = 18,
    TypeLinkerLeaveV2 = 19,
    TypeLinkerWaitingListChangeV2 = 20,
    TypeLinkerLinkedListChangeV2 = 21,
    TypeLinkerCohostListChange = 22,
    TypeLinkerMediaChange = 23,
    TypeLinkerAcceptNotice = 24,
    TypeLinkerSysKickOut = 101,
    TypeLinkmicUserToast = 102,
}
impl LinkMessageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LinkMessageType::TypeLinkerUnknown => "TYPE_LINKER_UNKNOWN",
            LinkMessageType::TypeLinkerCreate => "TYPE_LINKER_CREATE",
            LinkMessageType::TypeLinkerClose => "TYPE_LINKER_CLOSE",
            LinkMessageType::TypeLinkerInvite => "TYPE_LINKER_INVITE",
            LinkMessageType::TypeLinkerApply => "TYPE_LINKER_APPLY",
            LinkMessageType::TypeLinkerReply => "TYPE_LINKER_REPLY",
            LinkMessageType::TypeLinkerEnter => "TYPE_LINKER_ENTER",
            LinkMessageType::TypeLinkerLeave => "TYPE_LINKER_LEAVE",
            LinkMessageType::TypeLinkerPermit => "TYPE_LINKER_PERMIT",
            LinkMessageType::TypeLinkerCancelInvite => "TYPE_LINKER_CANCEL_INVITE",
            LinkMessageType::TypeLinkerWaitingListChange => {
                "TYPE_LINKER_WAITING_LIST_CHANGE"
            }
            LinkMessageType::TypeLinkerLinkedListChange => {
                "TYPE_LINKER_LINKED_LIST_CHANGE"
            }
            LinkMessageType::TypeLinkerUpdateUser => "TYPE_LINKER_UPDATE_USER",
            LinkMessageType::TypeLinkerKickOut => "TYPE_LINKER_KICK_OUT",
            LinkMessageType::TypeLinkerCancelApply => "TYPE_LINKER_CANCEL_APPLY",
            LinkMessageType::TypeLinkerMute => "TYPE_LINKER_MUTE",
            LinkMessageType::TypeLinkerMatch => "TYPE_LINKER_MATCH",
            LinkMessageType::TypeLinkerUpdateUserSetting => {
                "TYPE_LINKER_UPDATE_USER_SETTING"
            }
            LinkMessageType::TypeLinkerMicIdxUpdate => "TYPE_LINKER_MIC_IDX_UPDATE",
            LinkMessageType::TypeLinkerLeaveV2 => "TYPE_LINKER_LEAVE_V2",
            LinkMessageType::TypeLinkerWaitingListChangeV2 => {
                "TYPE_LINKER_WAITING_LIST_CHANGE_V2"
            }
            LinkMessageType::TypeLinkerLinkedListChangeV2 => {
                "TYPE_LINKER_LINKED_LIST_CHANGE_V2"
            }
            LinkMessageType::TypeLinkerCohostListChange => {
                "TYPE_LINKER_COHOST_LIST_CHANGE"
            }
            LinkMessageType::TypeLinkerMediaChange => "TYPE_LINKER_MEDIA_CHANGE",
            LinkMessageType::TypeLinkerAcceptNotice => "TYPE_LINKER_ACCEPT_NOTICE",
            LinkMessageType::TypeLinkerSysKickOut => "TYPE_LINKER_SYS_KICK_OUT",
            LinkMessageType::TypeLinkmicUserToast => "TYPE_LINKMIC_USER_TOAST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TYPE_LINKER_UNKNOWN" => Some(Self::TypeLinkerUnknown),
            "TYPE_LINKER_CREATE" => Some(Self::TypeLinkerCreate),
            "TYPE_LINKER_CLOSE" => Some(Self::TypeLinkerClose),
            "TYPE_LINKER_INVITE" => Some(Self::TypeLinkerInvite),
            "TYPE_LINKER_APPLY" => Some(Self::TypeLinkerApply),
            "TYPE_LINKER_REPLY" => Some(Self::TypeLinkerReply),
            "TYPE_LINKER_ENTER" => Some(Self::TypeLinkerEnter),
            "TYPE_LINKER_LEAVE" => Some(Self::TypeLinkerLeave),
            "TYPE_LINKER_PERMIT" => Some(Self::TypeLinkerPermit),
            "TYPE_LINKER_CANCEL_INVITE" => Some(Self::TypeLinkerCancelInvite),
            "TYPE_LINKER_WAITING_LIST_CHANGE" => Some(Self::TypeLinkerWaitingListChange),
            "TYPE_LINKER_LINKED_LIST_CHANGE" => Some(Self::TypeLinkerLinkedListChange),
            "TYPE_LINKER_UPDATE_USER" => Some(Self::TypeLinkerUpdateUser),
            "TYPE_LINKER_KICK_OUT" => Some(Self::TypeLinkerKickOut),
            "TYPE_LINKER_CANCEL_APPLY" => Some(Self::TypeLinkerCancelApply),
            "TYPE_LINKER_MUTE" => Some(Self::TypeLinkerMute),
            "TYPE_LINKER_MATCH" => Some(Self::TypeLinkerMatch),
            "TYPE_LINKER_UPDATE_USER_SETTING" => Some(Self::TypeLinkerUpdateUserSetting),
            "TYPE_LINKER_MIC_IDX_UPDATE" => Some(Self::TypeLinkerMicIdxUpdate),
            "TYPE_LINKER_LEAVE_V2" => Some(Self::TypeLinkerLeaveV2),
            "TYPE_LINKER_WAITING_LIST_CHANGE_V2" => {
                Some(Self::TypeLinkerWaitingListChangeV2)
            }
            "TYPE_LINKER_LINKED_LIST_CHANGE_V2" => {
                Some(Self::TypeLinkerLinkedListChangeV2)
            }
            "TYPE_LINKER_COHOST_LIST_CHANGE" => Some(Self::TypeLinkerCohostListChange),
            "TYPE_LINKER_MEDIA_CHANGE" => Some(Self::TypeLinkerMediaChange),
            "TYPE_LINKER_ACCEPT_NOTICE" => Some(Self::TypeLinkerAcceptNotice),
            "TYPE_LINKER_SYS_KICK_OUT" => Some(Self::TypeLinkerSysKickOut),
            "TYPE_LINKMIC_USER_TOAST" => Some(Self::TypeLinkmicUserToast),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MessageType {
    SubSuccess = 0,
    AnchorReminder = 1,
    EnterRoomExpireSoon = 2,
    SubGoalCreateToAnchor = 3,
    SubGoalCompleteToAudience = 4,
    SubGoalCompleteToAnchor = 5,
    SubGiftTikTok2UserNotice = 6,
    SubGiftTikTok2AnchorNotice = 7,
    SubGiftTReceivesEndNotice = 8,
    SubGiftsEndSucceedRoomMessage = 9,
    SubGiftsEndSucceedAnchorNotice = 10,
    SubGiftLowVersionUpgradeNotice = 11,
    SubGiftUserBuyAuThNotice = 12,
    SubCommonTextNotice = 13,
    SubModeratorPinPerk = 14,
}
impl MessageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            MessageType::SubSuccess => "MESSAGE_TYPE_SUB_SUCCESS",
            MessageType::AnchorReminder => "MESSAGE_TYPE_ANCHOR_REMINDER",
            MessageType::EnterRoomExpireSoon => "MESSAGE_TYPE_ENTER_ROOM_EXPIRE_SOON",
            MessageType::SubGoalCreateToAnchor => {
                "MESSAGE_TYPE_SUB_GOAL_CREATE_TO_ANCHOR"
            }
            MessageType::SubGoalCompleteToAudience => {
                "MESSAGE_TYPE_SUB_GOAL_COMPLETE_TO_AUDIENCE"
            }
            MessageType::SubGoalCompleteToAnchor => {
                "MESSAGE_TYPE_SUB_GOAL_COMPLETE_TO_ANCHOR"
            }
            MessageType::SubGiftTikTok2UserNotice => {
                "MESSAGE_TYPE_SUB_GIFT_TIK_TOK_2_USER_NOTICE"
            }
            MessageType::SubGiftTikTok2AnchorNotice => {
                "MESSAGE_TYPE_SUB_GIFT_TIK_TOK_2_ANCHOR_NOTICE"
            }
            MessageType::SubGiftTReceivesEndNotice => {
                "MESSAGE_TYPE_SUB_GIFT_T_RECEIVES_END_NOTICE"
            }
            MessageType::SubGiftsEndSucceedRoomMessage => {
                "MESSAGE_TYPE_SUB_GIFTS_END_SUCCEED_ROOM_MESSAGE"
            }
            MessageType::SubGiftsEndSucceedAnchorNotice => {
                "MESSAGE_TYPE_SUB_GIFTS_END_SUCCEED_ANCHOR_NOTICE"
            }
            MessageType::SubGiftLowVersionUpgradeNotice => {
                "MESSAGE_TYPE_SUB_GIFT_LOW_VERSION_UPGRADE_NOTICE"
            }
            MessageType::SubGiftUserBuyAuThNotice => {
                "MESSAGE_TYPE_SUB_GIFT_USER_BUY_AU_TH_NOTICE"
            }
            MessageType::SubCommonTextNotice => "MESSAGE_TYPE_SUB_COMMON_TEXT_NOTICE",
            MessageType::SubModeratorPinPerk => "MESSAGE_TYPE_SUB_MODERATOR_PIN_PERK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MESSAGE_TYPE_SUB_SUCCESS" => Some(Self::SubSuccess),
            "MESSAGE_TYPE_ANCHOR_REMINDER" => Some(Self::AnchorReminder),
            "MESSAGE_TYPE_ENTER_ROOM_EXPIRE_SOON" => Some(Self::EnterRoomExpireSoon),
            "MESSAGE_TYPE_SUB_GOAL_CREATE_TO_ANCHOR" => Some(Self::SubGoalCreateToAnchor),
            "MESSAGE_TYPE_SUB_GOAL_COMPLETE_TO_AUDIENCE" => {
                Some(Self::SubGoalCompleteToAudience)
            }
            "MESSAGE_TYPE_SUB_GOAL_COMPLETE_TO_ANCHOR" => {
                Some(Self::SubGoalCompleteToAnchor)
            }
            "MESSAGE_TYPE_SUB_GIFT_TIK_TOK_2_USER_NOTICE" => {
                Some(Self::SubGiftTikTok2UserNotice)
            }
            "MESSAGE_TYPE_SUB_GIFT_TIK_TOK_2_ANCHOR_NOTICE" => {
                Some(Self::SubGiftTikTok2AnchorNotice)
            }
            "MESSAGE_TYPE_SUB_GIFT_T_RECEIVES_END_NOTICE" => {
                Some(Self::SubGiftTReceivesEndNotice)
            }
            "MESSAGE_TYPE_SUB_GIFTS_END_SUCCEED_ROOM_MESSAGE" => {
                Some(Self::SubGiftsEndSucceedRoomMessage)
            }
            "MESSAGE_TYPE_SUB_GIFTS_END_SUCCEED_ANCHOR_NOTICE" => {
                Some(Self::SubGiftsEndSucceedAnchorNotice)
            }
            "MESSAGE_TYPE_SUB_GIFT_LOW_VERSION_UPGRADE_NOTICE" => {
                Some(Self::SubGiftLowVersionUpgradeNotice)
            }
            "MESSAGE_TYPE_SUB_GIFT_USER_BUY_AU_TH_NOTICE" => {
                Some(Self::SubGiftUserBuyAuThNotice)
            }
            "MESSAGE_TYPE_SUB_COMMON_TEXT_NOTICE" => Some(Self::SubCommonTextNotice),
            "MESSAGE_TYPE_SUB_MODERATOR_PIN_PERK" => Some(Self::SubModeratorPinPerk),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Scene {
    Unknown = 0,
    CoHost = 2,
    MultiLive = 4,
}
impl Scene {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Scene::Unknown => "SCENE_UNKNOWN",
            Scene::CoHost => "SCENE_CO_HOST",
            Scene::MultiLive => "SCENE_MULTI_LIVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SCENE_UNKNOWN" => Some(Self::Unknown),
            "SCENE_CO_HOST" => Some(Self::CoHost),
            "SCENE_MULTI_LIVE" => Some(Self::MultiLive),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RewardCondition {
    Subscription = 0,
    SubWaveCustom = 1,
}
impl RewardCondition {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RewardCondition::Subscription => "REWARD_CONDITION_SUBSCRIPTION",
            RewardCondition::SubWaveCustom => "REWARD_CONDITION_SUB_WAVE_CUSTOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REWARD_CONDITION_SUBSCRIPTION" => Some(Self::Subscription),
            "REWARD_CONDITION_SUB_WAVE_CUSTOM" => Some(Self::SubWaveCustom),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UserEmoteUploadSource {
    EmoteUploadSourceAnchor = 0,
    EmoteUploadSourceSubscriber = 1,
    EmoteUploadSourceModerator = 2,
}
impl UserEmoteUploadSource {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            UserEmoteUploadSource::EmoteUploadSourceAnchor => {
                "USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_ANCHOR"
            }
            UserEmoteUploadSource::EmoteUploadSourceSubscriber => {
                "USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_SUBSCRIBER"
            }
            UserEmoteUploadSource::EmoteUploadSourceModerator => {
                "USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_MODERATOR"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_ANCHOR" => {
                Some(Self::EmoteUploadSourceAnchor)
            }
            "USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_SUBSCRIBER" => {
                Some(Self::EmoteUploadSourceSubscriber)
            }
            "USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_MODERATOR" => {
                Some(Self::EmoteUploadSourceModerator)
            }
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EmoteScene {
    Subscription = 0,
    Game = 1,
}
impl EmoteScene {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EmoteScene::Subscription => "EMOTE_SCENE_SUBSCRIPTION",
            EmoteScene::Game => "EMOTE_SCENE_GAME",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EMOTE_SCENE_SUBSCRIPTION" => Some(Self::Subscription),
            "EMOTE_SCENE_GAME" => Some(Self::Game),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PunishTypeId {
    PunishTypeIdunKnown = 0,
    BanLinkMic = 9,
    BanGamePartnership = 25,
    RemoveGamePartnership = 26,
    BancoHostLinkMic = 55,
    AuthorityLimitMatch = 57,
    BanVoiceChat = 59,
    BanLiveGoal = 64,
    ViewerLimit = 70,
}
impl PunishTypeId {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PunishTypeId::PunishTypeIdunKnown => "PUNISH_TYPE_IDUN_KNOWN",
            PunishTypeId::BanLinkMic => "PUNISH_TYPE_ID_BAN_LINK_MIC",
            PunishTypeId::BanGamePartnership => "PUNISH_TYPE_ID_BAN_GAME_PARTNERSHIP",
            PunishTypeId::RemoveGamePartnership => {
                "PUNISH_TYPE_ID_REMOVE_GAME_PARTNERSHIP"
            }
            PunishTypeId::BancoHostLinkMic => "PUNISH_TYPE_ID_BANCO_HOST_LINK_MIC",
            PunishTypeId::AuthorityLimitMatch => "PUNISH_TYPE_ID_AUTHORITY_LIMIT_MATCH",
            PunishTypeId::BanVoiceChat => "PUNISH_TYPE_ID_BAN_VOICE_CHAT",
            PunishTypeId::BanLiveGoal => "PUNISH_TYPE_ID_BAN_LIVE_GOAL",
            PunishTypeId::ViewerLimit => "PUNISH_TYPE_ID_VIEWER_LIMIT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PUNISH_TYPE_IDUN_KNOWN" => Some(Self::PunishTypeIdunKnown),
            "PUNISH_TYPE_ID_BAN_LINK_MIC" => Some(Self::BanLinkMic),
            "PUNISH_TYPE_ID_BAN_GAME_PARTNERSHIP" => Some(Self::BanGamePartnership),
            "PUNISH_TYPE_ID_REMOVE_GAME_PARTNERSHIP" => Some(Self::RemoveGamePartnership),
            "PUNISH_TYPE_ID_BANCO_HOST_LINK_MIC" => Some(Self::BancoHostLinkMic),
            "PUNISH_TYPE_ID_AUTHORITY_LIMIT_MATCH" => Some(Self::AuthorityLimitMatch),
            "PUNISH_TYPE_ID_BAN_VOICE_CHAT" => Some(Self::BanVoiceChat),
            "PUNISH_TYPE_ID_BAN_LIVE_GOAL" => Some(Self::BanLiveGoal),
            "PUNISH_TYPE_ID_VIEWER_LIMIT" => Some(Self::ViewerLimit),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MultiplierType {
    Unspecified = 0,
    CriticalStrike = 1,
    Top2 = 2,
    Top3 = 3,
}
impl MultiplierType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            MultiplierType::Unspecified => "MULTIPLIER_TYPE_UNSPECIFIED",
            MultiplierType::CriticalStrike => "MULTIPLIER_TYPE_CRITICAL_STRIKE",
            MultiplierType::Top2 => "MULTIPLIER_TYPE_TOP_2",
            MultiplierType::Top3 => "MULTIPLIER_TYPE_TOP_3",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MULTIPLIER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "MULTIPLIER_TYPE_CRITICAL_STRIKE" => Some(Self::CriticalStrike),
            "MULTIPLIER_TYPE_TOP_2" => Some(Self::Top2),
            "MULTIPLIER_TYPE_TOP_3" => Some(Self::Top3),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LinkmicGiftExpressionStrategy {
    ControlV1 = 0,
    ExperimentV1 = 1,
    ExperimentV2 = 2,
}
impl LinkmicGiftExpressionStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LinkmicGiftExpressionStrategy::ControlV1 => {
                "LINKMIC_GIFT_EXPRESSION_STRATEGY_CONTROL_V_1"
            }
            LinkmicGiftExpressionStrategy::ExperimentV1 => {
                "LINKMIC_GIFT_EXPRESSION_STRATEGY_EXPERIMENT_V_1"
            }
            LinkmicGiftExpressionStrategy::ExperimentV2 => {
                "LINKMIC_GIFT_EXPRESSION_STRATEGY_EXPERIMENT_V_2"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LINKMIC_GIFT_EXPRESSION_STRATEGY_CONTROL_V_1" => Some(Self::ControlV1),
            "LINKMIC_GIFT_EXPRESSION_STRATEGY_EXPERIMENT_V_1" => Some(Self::ExperimentV1),
            "LINKMIC_GIFT_EXPRESSION_STRATEGY_EXPERIMENT_V_2" => Some(Self::ExperimentV2),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GiftMessageVersion {
    GiftMessageVersion0 = 0,
    GiftMessageVersion1 = 1,
}
impl GiftMessageVersion {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            GiftMessageVersion::GiftMessageVersion0 => "GIFT_MESSAGE_VERSION_0",
            GiftMessageVersion::GiftMessageVersion1 => "GIFT_MESSAGE_VERSION_1",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GIFT_MESSAGE_VERSION_0" => Some(Self::GiftMessageVersion0),
            "GIFT_MESSAGE_VERSION_1" => Some(Self::GiftMessageVersion1),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TagType {
    CreatorCrMTagTypeUnknown = 0,
    CreatorCrMTagTypeUserGrade = 1,
    CreatorCrMTagTypeFansLevel = 2,
    CreatorCrMTagTypeWatchMeDaysAgo = 3,
    CreatorCrMTagTypeCustom = 4,
    CreatorCrMTagTypeTitleGift = 5,
    CreatorCrMTagTypeFirstJoinedTeam = 6,
    CreatorCrMTagTypePayAccompanyDays = 7,
    CreatorCrMTagTypeSponsorGiftLastRoom = 8,
    CreatorCrMTagTypeMatchMvpLastRoom = 9,
    CreatorCrMTagTypeLargeAmountGiftLastRoom = 10,
    CreatorCrMTagTypeCommentLastRoom = 11,
    CreatorCrMTagTypeRecentTitledGift = 12,
    CreatorCrMTagTypeMeetAnniversary = 13,
    CreatorCrMTagTypeFansSleep = 14,
    CreatorCrMTagTypeNotSendHeartMe = 15,
    CreatorCrMTagTypeNotJoinTeam = 16,
    CreatorCrMTagTypeFirstWatchLive = 17,
    CreatorCrMTagTypeRecentComment = 18,
    CreatorCrMTagTypeRecentGiftTimes = 19,
    CreatorCrMTagTypeRecentWatchLiveDuration = 20,
    CreatorCrMTagTypeRecentGift = 21,
    CreatorCrMTagTypeRecentLiveContributionTop = 22,
    CreatorCrMTagTypeJustUpgrade = 28,
    CreatorCrMTagTypeFanTotalWatchDuration = 29,
    CreatorCrMTagTypeFanTotalCommentNum = 30,
    CreatorCrMTagTypeFanTotalGiftSentNum = 31,
}
impl TagType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TagType::CreatorCrMTagTypeUnknown => "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_UNKNOWN",
            TagType::CreatorCrMTagTypeUserGrade => {
                "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_USER_GRADE"
            }
            TagType::CreatorCrMTagTypeFansLevel => {
                "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FANS_LEVEL"
            }
            TagType::CreatorCrMTagTypeWatchMeDaysAgo => {
                "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_WATCH_ME_DAYS_AGO"
            }
            TagType::CreatorCrMTagTypeCustom => "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_CUSTOM",
            TagType::CreatorCrMTagTypeTitleGift => {
                "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_TITLE_GIFT"
            }
            TagType::CreatorCrMTagTypeFirstJoinedTeam => {
                "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FIRST_JOINED_TEAM"
            }
            TagType::CreatorCrMTagTypePayAccompanyDays => {
                "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_PAY_ACCOMPANY_DAYS"
            }
            TagType::CreatorCrMTagTypeSponsorGiftLastRoom => {
                "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_SPONSOR_GIFT_LAST_ROOM"
            }
            TagType::CreatorCrMTagTypeMatchMvpLastRoom => {
                "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_MATCH_MVP_LAST_ROOM"
            }
            TagType::CreatorCrMTagTypeLargeAmountGiftLastRoom => {
                "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_LARGE_AMOUNT_GIFT_LAST_ROOM"
            }
            TagType::CreatorCrMTagTypeCommentLastRoom => {
                "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_COMMENT_LAST_ROOM"
            }
            TagType::CreatorCrMTagTypeRecentTitledGift => {
                "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_TITLED_GIFT"
            }
            TagType::CreatorCrMTagTypeMeetAnniversary => {
                "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_MEET_ANNIVERSARY"
            }
            TagType::CreatorCrMTagTypeFansSleep => {
                "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FANS_SLEEP"
            }
            TagType::CreatorCrMTagTypeNotSendHeartMe => {
                "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_NOT_SEND_HEART_ME"
            }
            TagType::CreatorCrMTagTypeNotJoinTeam => {
                "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_NOT_JOIN_TEAM"
            }
            TagType::CreatorCrMTagTypeFirstWatchLive => {
                "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FIRST_WATCH_LIVE"
            }
            TagType::CreatorCrMTagTypeRecentComment => {
                "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_COMMENT"
            }
            TagType::CreatorCrMTagTypeRecentGiftTimes => {
                "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_GIFT_TIMES"
            }
            TagType::CreatorCrMTagTypeRecentWatchLiveDuration => {
                "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_WATCH_LIVE_DURATION"
            }
            TagType::CreatorCrMTagTypeRecentGift => {
                "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_GIFT"
            }
            TagType::CreatorCrMTagTypeRecentLiveContributionTop => {
                "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_LIVE_CONTRIBUTION_TOP"
            }
            TagType::CreatorCrMTagTypeJustUpgrade => {
                "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_JUST_UPGRADE"
            }
            TagType::CreatorCrMTagTypeFanTotalWatchDuration => {
                "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FAN_TOTAL_WATCH_DURATION"
            }
            TagType::CreatorCrMTagTypeFanTotalCommentNum => {
                "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FAN_TOTAL_COMMENT_NUM"
            }
            TagType::CreatorCrMTagTypeFanTotalGiftSentNum => {
                "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FAN_TOTAL_GIFT_SENT_NUM"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_UNKNOWN" => {
                Some(Self::CreatorCrMTagTypeUnknown)
            }
            "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_USER_GRADE" => {
                Some(Self::CreatorCrMTagTypeUserGrade)
            }
            "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FANS_LEVEL" => {
                Some(Self::CreatorCrMTagTypeFansLevel)
            }
            "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_WATCH_ME_DAYS_AGO" => {
                Some(Self::CreatorCrMTagTypeWatchMeDaysAgo)
            }
            "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_CUSTOM" => {
                Some(Self::CreatorCrMTagTypeCustom)
            }
            "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_TITLE_GIFT" => {
                Some(Self::CreatorCrMTagTypeTitleGift)
            }
            "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FIRST_JOINED_TEAM" => {
                Some(Self::CreatorCrMTagTypeFirstJoinedTeam)
            }
            "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_PAY_ACCOMPANY_DAYS" => {
                Some(Self::CreatorCrMTagTypePayAccompanyDays)
            }
            "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_SPONSOR_GIFT_LAST_ROOM" => {
                Some(Self::CreatorCrMTagTypeSponsorGiftLastRoom)
            }
            "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_MATCH_MVP_LAST_ROOM" => {
                Some(Self::CreatorCrMTagTypeMatchMvpLastRoom)
            }
            "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_LARGE_AMOUNT_GIFT_LAST_ROOM" => {
                Some(Self::CreatorCrMTagTypeLargeAmountGiftLastRoom)
            }
            "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_COMMENT_LAST_ROOM" => {
                Some(Self::CreatorCrMTagTypeCommentLastRoom)
            }
            "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_TITLED_GIFT" => {
                Some(Self::CreatorCrMTagTypeRecentTitledGift)
            }
            "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_MEET_ANNIVERSARY" => {
                Some(Self::CreatorCrMTagTypeMeetAnniversary)
            }
            "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FANS_SLEEP" => {
                Some(Self::CreatorCrMTagTypeFansSleep)
            }
            "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_NOT_SEND_HEART_ME" => {
                Some(Self::CreatorCrMTagTypeNotSendHeartMe)
            }
            "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_NOT_JOIN_TEAM" => {
                Some(Self::CreatorCrMTagTypeNotJoinTeam)
            }
            "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FIRST_WATCH_LIVE" => {
                Some(Self::CreatorCrMTagTypeFirstWatchLive)
            }
            "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_COMMENT" => {
                Some(Self::CreatorCrMTagTypeRecentComment)
            }
            "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_GIFT_TIMES" => {
                Some(Self::CreatorCrMTagTypeRecentGiftTimes)
            }
            "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_WATCH_LIVE_DURATION" => {
                Some(Self::CreatorCrMTagTypeRecentWatchLiveDuration)
            }
            "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_GIFT" => {
                Some(Self::CreatorCrMTagTypeRecentGift)
            }
            "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_LIVE_CONTRIBUTION_TOP" => {
                Some(Self::CreatorCrMTagTypeRecentLiveContributionTop)
            }
            "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_JUST_UPGRADE" => {
                Some(Self::CreatorCrMTagTypeJustUpgrade)
            }
            "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FAN_TOTAL_WATCH_DURATION" => {
                Some(Self::CreatorCrMTagTypeFanTotalWatchDuration)
            }
            "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FAN_TOTAL_COMMENT_NUM" => {
                Some(Self::CreatorCrMTagTypeFanTotalCommentNum)
            }
            "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FAN_TOTAL_GIFT_SENT_NUM" => {
                Some(Self::CreatorCrMTagTypeFanTotalGiftSentNum)
            }
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TopicActionType {
    Unknown = 0,
    Follow = 1,
}
impl TopicActionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TopicActionType::Unknown => "TOPIC_ACTION_TYPE_UNKNOWN",
            TopicActionType::Follow => "TOPIC_ACTION_TYPE_FOLLOW",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TOPIC_ACTION_TYPE_UNKNOWN" => Some(Self::Unknown),
            "TOPIC_ACTION_TYPE_FOLLOW" => Some(Self::Follow),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UserMetricsType {
    Unknown = 0,
    Grade = 1,
    Subscribe = 2,
    Follow = 3,
    FansClub = 4,
    TopViewer = 5,
    Gift = 6,
}
impl UserMetricsType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            UserMetricsType::Unknown => "USER_METRICS_TYPE_UNKNOWN",
            UserMetricsType::Grade => "USER_METRICS_TYPE_GRADE",
            UserMetricsType::Subscribe => "USER_METRICS_TYPE_SUBSCRIBE",
            UserMetricsType::Follow => "USER_METRICS_TYPE_FOLLOW",
            UserMetricsType::FansClub => "USER_METRICS_TYPE_FANS_CLUB",
            UserMetricsType::TopViewer => "USER_METRICS_TYPE_TOP_VIEWER",
            UserMetricsType::Gift => "USER_METRICS_TYPE_GIFT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "USER_METRICS_TYPE_UNKNOWN" => Some(Self::Unknown),
            "USER_METRICS_TYPE_GRADE" => Some(Self::Grade),
            "USER_METRICS_TYPE_SUBSCRIBE" => Some(Self::Subscribe),
            "USER_METRICS_TYPE_FOLLOW" => Some(Self::Follow),
            "USER_METRICS_TYPE_FANS_CLUB" => Some(Self::FansClub),
            "USER_METRICS_TYPE_TOP_VIEWER" => Some(Self::TopViewer),
            "USER_METRICS_TYPE_GIFT" => Some(Self::Gift),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GiftMessageIgnoreConfig {
    NotIgnore = 0,
    IgnoreTray = 1,
    IgnorePsM = 2,
    IgnoreTrayAndPsM = 3,
}
impl GiftMessageIgnoreConfig {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            GiftMessageIgnoreConfig::NotIgnore => "GIFT_MESSAGE_IGNORE_CONFIG_NOT_IGNORE",
            GiftMessageIgnoreConfig::IgnoreTray => {
                "GIFT_MESSAGE_IGNORE_CONFIG_IGNORE_TRAY"
            }
            GiftMessageIgnoreConfig::IgnorePsM => {
                "GIFT_MESSAGE_IGNORE_CONFIG_IGNORE_PS_M"
            }
            GiftMessageIgnoreConfig::IgnoreTrayAndPsM => {
                "GIFT_MESSAGE_IGNORE_CONFIG_IGNORE_TRAY_AND_PS_M"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GIFT_MESSAGE_IGNORE_CONFIG_NOT_IGNORE" => Some(Self::NotIgnore),
            "GIFT_MESSAGE_IGNORE_CONFIG_IGNORE_TRAY" => Some(Self::IgnoreTray),
            "GIFT_MESSAGE_IGNORE_CONFIG_IGNORE_PS_M" => Some(Self::IgnorePsM),
            "GIFT_MESSAGE_IGNORE_CONFIG_IGNORE_TRAY_AND_PS_M" => {
                Some(Self::IgnoreTrayAndPsM)
            }
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HorizontalOnclickTriggerType {
    OnclickTriggerTypeUnknown = 0,
    OnclickTriggerTypeLeft = 1,
    OnclickTriggerTypeMiddle = 2,
    OnclickTriggerTypeRight = 3,
    OnclickTriggerTypeAllArea = 4,
}
impl HorizontalOnclickTriggerType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            HorizontalOnclickTriggerType::OnclickTriggerTypeUnknown => {
                "HORIZONTAL_ONCLICK_TRIGGER_TYPE_ONCLICK_TRIGGER_TYPE_UNKNOWN"
            }
            HorizontalOnclickTriggerType::OnclickTriggerTypeLeft => {
                "HORIZONTAL_ONCLICK_TRIGGER_TYPE_ONCLICK_TRIGGER_TYPE_LEFT"
            }
            HorizontalOnclickTriggerType::OnclickTriggerTypeMiddle => {
                "HORIZONTAL_ONCLICK_TRIGGER_TYPE_ONCLICK_TRIGGER_TYPE_MIDDLE"
            }
            HorizontalOnclickTriggerType::OnclickTriggerTypeRight => {
                "HORIZONTAL_ONCLICK_TRIGGER_TYPE_ONCLICK_TRIGGER_TYPE_RIGHT"
            }
            HorizontalOnclickTriggerType::OnclickTriggerTypeAllArea => {
                "HORIZONTAL_ONCLICK_TRIGGER_TYPE_ONCLICK_TRIGGER_TYPE_ALL_AREA"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HORIZONTAL_ONCLICK_TRIGGER_TYPE_ONCLICK_TRIGGER_TYPE_UNKNOWN" => {
                Some(Self::OnclickTriggerTypeUnknown)
            }
            "HORIZONTAL_ONCLICK_TRIGGER_TYPE_ONCLICK_TRIGGER_TYPE_LEFT" => {
                Some(Self::OnclickTriggerTypeLeft)
            }
            "HORIZONTAL_ONCLICK_TRIGGER_TYPE_ONCLICK_TRIGGER_TYPE_MIDDLE" => {
                Some(Self::OnclickTriggerTypeMiddle)
            }
            "HORIZONTAL_ONCLICK_TRIGGER_TYPE_ONCLICK_TRIGGER_TYPE_RIGHT" => {
                Some(Self::OnclickTriggerTypeRight)
            }
            "HORIZONTAL_ONCLICK_TRIGGER_TYPE_ONCLICK_TRIGGER_TYPE_ALL_AREA" => {
                Some(Self::OnclickTriggerTypeAllArea)
            }
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ShowType {
    Normal = 0,
    FadeInOut = 1,
}
impl ShowType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ShowType::Normal => "SHOW_TYPE_NORMAL",
            ShowType::FadeInOut => "SHOW_TYPE_FADE_IN_OUT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SHOW_TYPE_NORMAL" => Some(Self::Normal),
            "SHOW_TYPE_FADE_IN_OUT" => Some(Self::FadeInOut),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RenderType {
    Native = 0,
    Hybrid = 1,
    Alpha = 2,
}
impl RenderType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RenderType::Native => "RENDER_TYPE_NATIVE",
            RenderType::Hybrid => "RENDER_TYPE_HYBRID",
            RenderType::Alpha => "RENDER_TYPE_ALPHA",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RENDER_TYPE_NATIVE" => Some(Self::Native),
            "RENDER_TYPE_HYBRID" => Some(Self::Hybrid),
            "RENDER_TYPE_ALPHA" => Some(Self::Alpha),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IconDisplayType {
    Image = 0,
    Badge = 1,
}
impl IconDisplayType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            IconDisplayType::Image => "ICON_DISPLAY_TYPE_IMAGE",
            IconDisplayType::Badge => "ICON_DISPLAY_TYPE_BADGE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ICON_DISPLAY_TYPE_IMAGE" => Some(Self::Image),
            "ICON_DISPLAY_TYPE_BADGE" => Some(Self::Badge),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CommentTag {
    Normal = 0,
    Candidate = 1,
    Overage = 2,
}
impl CommentTag {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CommentTag::Normal => "COMMENT_TAG_NORMAL",
            CommentTag::Candidate => "COMMENT_TAG_CANDIDATE",
            CommentTag::Overage => "COMMENT_TAG_OVERAGE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMMENT_TAG_NORMAL" => Some(Self::Normal),
            "COMMENT_TAG_CANDIDATE" => Some(Self::Candidate),
            "COMMENT_TAG_OVERAGE" => Some(Self::Overage),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PerceptionDialogIconType {
    IconTypeNone = 0,
    IconTypeWarning = 1,
    IconTypeLinkMic = 2,
    IconTypeGuestLinkMic = 3,
    IconTypeLive = 4,
    IconTypeTreasureBox = 5,
    IconTypeMute = 6,
    IconGamepadAccessRevoked = 7,
    IconTypeBanReportLiveSingleRoom = 8,
    IconTypeBanReportLiveAllRoom = 9,
    IconTypeBanReportLiveGreenScreen = 10,
    IconTypeGift = 11,
    IconTypeAppealSuccess = 12,
    IconTypeMatch = 13,
    IconTypeLiveGoal = 14,
    IconTypeSubscription = 15,
    IconTypeStarComment = 16,
    IconTypeRanking = 17,
    IconTypeCommon = 18,
}
impl PerceptionDialogIconType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PerceptionDialogIconType::IconTypeNone => {
                "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_NONE"
            }
            PerceptionDialogIconType::IconTypeWarning => {
                "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_WARNING"
            }
            PerceptionDialogIconType::IconTypeLinkMic => {
                "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_LINK_MIC"
            }
            PerceptionDialogIconType::IconTypeGuestLinkMic => {
                "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_GUEST_LINK_MIC"
            }
            PerceptionDialogIconType::IconTypeLive => {
                "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_LIVE"
            }
            PerceptionDialogIconType::IconTypeTreasureBox => {
                "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_TREASURE_BOX"
            }
            PerceptionDialogIconType::IconTypeMute => {
                "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_MUTE"
            }
            PerceptionDialogIconType::IconGamepadAccessRevoked => {
                "PERCEPTION_DIALOG_ICON_TYPE_ICON_GAMEPAD_ACCESS_REVOKED"
            }
            PerceptionDialogIconType::IconTypeBanReportLiveSingleRoom => {
                "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_BAN_REPORT_LIVE_SINGLE_ROOM"
            }
            PerceptionDialogIconType::IconTypeBanReportLiveAllRoom => {
                "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_BAN_REPORT_LIVE_ALL_ROOM"
            }
            PerceptionDialogIconType::IconTypeBanReportLiveGreenScreen => {
                "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_BAN_REPORT_LIVE_GREEN_SCREEN"
            }
            PerceptionDialogIconType::IconTypeGift => {
                "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_GIFT"
            }
            PerceptionDialogIconType::IconTypeAppealSuccess => {
                "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_APPEAL_SUCCESS"
            }
            PerceptionDialogIconType::IconTypeMatch => {
                "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_MATCH"
            }
            PerceptionDialogIconType::IconTypeLiveGoal => {
                "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_LIVE_GOAL"
            }
            PerceptionDialogIconType::IconTypeSubscription => {
                "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_SUBSCRIPTION"
            }
            PerceptionDialogIconType::IconTypeStarComment => {
                "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_STAR_COMMENT"
            }
            PerceptionDialogIconType::IconTypeRanking => {
                "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_RANKING"
            }
            PerceptionDialogIconType::IconTypeCommon => {
                "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_COMMON"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_NONE" => Some(Self::IconTypeNone),
            "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_WARNING" => {
                Some(Self::IconTypeWarning)
            }
            "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_LINK_MIC" => {
                Some(Self::IconTypeLinkMic)
            }
            "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_GUEST_LINK_MIC" => {
                Some(Self::IconTypeGuestLinkMic)
            }
            "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_LIVE" => Some(Self::IconTypeLive),
            "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_TREASURE_BOX" => {
                Some(Self::IconTypeTreasureBox)
            }
            "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_MUTE" => Some(Self::IconTypeMute),
            "PERCEPTION_DIALOG_ICON_TYPE_ICON_GAMEPAD_ACCESS_REVOKED" => {
                Some(Self::IconGamepadAccessRevoked)
            }
            "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_BAN_REPORT_LIVE_SINGLE_ROOM" => {
                Some(Self::IconTypeBanReportLiveSingleRoom)
            }
            "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_BAN_REPORT_LIVE_ALL_ROOM" => {
                Some(Self::IconTypeBanReportLiveAllRoom)
            }
            "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_BAN_REPORT_LIVE_GREEN_SCREEN" => {
                Some(Self::IconTypeBanReportLiveGreenScreen)
            }
            "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_GIFT" => Some(Self::IconTypeGift),
            "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_APPEAL_SUCCESS" => {
                Some(Self::IconTypeAppealSuccess)
            }
            "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_MATCH" => Some(Self::IconTypeMatch),
            "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_LIVE_GOAL" => {
                Some(Self::IconTypeLiveGoal)
            }
            "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_SUBSCRIPTION" => {
                Some(Self::IconTypeSubscription)
            }
            "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_STAR_COMMENT" => {
                Some(Self::IconTypeStarComment)
            }
            "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_RANKING" => {
                Some(Self::IconTypeRanking)
            }
            "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_COMMON" => Some(Self::IconTypeCommon),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GoalMessageSource {
    Unknown = 0,
    Commit = 1,
    ProgressUpdate = 2,
    Pin = 3,
    Unpin = 4,
    ReviewCallback = 5,
    Suspend = 6,
    ChallengePrompt = 7,
}
impl GoalMessageSource {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            GoalMessageSource::Unknown => "GOAL_MESSAGE_SOURCE_UNKNOWN",
            GoalMessageSource::Commit => "GOAL_MESSAGE_SOURCE_COMMIT",
            GoalMessageSource::ProgressUpdate => "GOAL_MESSAGE_SOURCE_PROGRESS_UPDATE",
            GoalMessageSource::Pin => "GOAL_MESSAGE_SOURCE_PIN",
            GoalMessageSource::Unpin => "GOAL_MESSAGE_SOURCE_UNPIN",
            GoalMessageSource::ReviewCallback => "GOAL_MESSAGE_SOURCE_REVIEW_CALLBACK",
            GoalMessageSource::Suspend => "GOAL_MESSAGE_SOURCE_SUSPEND",
            GoalMessageSource::ChallengePrompt => "GOAL_MESSAGE_SOURCE_CHALLENGE_PROMPT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GOAL_MESSAGE_SOURCE_UNKNOWN" => Some(Self::Unknown),
            "GOAL_MESSAGE_SOURCE_COMMIT" => Some(Self::Commit),
            "GOAL_MESSAGE_SOURCE_PROGRESS_UPDATE" => Some(Self::ProgressUpdate),
            "GOAL_MESSAGE_SOURCE_PIN" => Some(Self::Pin),
            "GOAL_MESSAGE_SOURCE_UNPIN" => Some(Self::Unpin),
            "GOAL_MESSAGE_SOURCE_REVIEW_CALLBACK" => Some(Self::ReviewCallback),
            "GOAL_MESSAGE_SOURCE_SUSPEND" => Some(Self::Suspend),
            "GOAL_MESSAGE_SOURCE_CHALLENGE_PROMPT" => Some(Self::ChallengePrompt),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExhibitionType {
    Default = 0,
    Fold = 1,
    PublicScreen = 2,
}
impl ExhibitionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ExhibitionType::Default => "EXHIBITION_TYPE_DEFAULT",
            ExhibitionType::Fold => "EXHIBITION_TYPE_FOLD",
            ExhibitionType::PublicScreen => "EXHIBITION_TYPE_PUBLIC_SCREEN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EXHIBITION_TYPE_DEFAULT" => Some(Self::Default),
            "EXHIBITION_TYPE_FOLD" => Some(Self::Fold),
            "EXHIBITION_TYPE_PUBLIC_SCREEN" => Some(Self::PublicScreen),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GiftSource {
    Unknown = 0,
    Platform = 1,
    UserBuyRandom = 2,
    UserBuySpecific = 3,
}
impl GiftSource {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            GiftSource::Unknown => "GIFT_SOURCE_UNKNOWN",
            GiftSource::Platform => "GIFT_SOURCE_PLATFORM",
            GiftSource::UserBuyRandom => "GIFT_SOURCE_USER_BUY_RANDOM",
            GiftSource::UserBuySpecific => "GIFT_SOURCE_USER_BUY_SPECIFIC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GIFT_SOURCE_UNKNOWN" => Some(Self::Unknown),
            "GIFT_SOURCE_PLATFORM" => Some(Self::Platform),
            "GIFT_SOURCE_USER_BUY_RANDOM" => Some(Self::UserBuyRandom),
            "GIFT_SOURCE_USER_BUY_SPECIFIC" => Some(Self::UserBuySpecific),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MessageDisplayStyle {
    Default = 0,
    Popup = 1,
}
impl MessageDisplayStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            MessageDisplayStyle::Default => "MESSAGE_DISPLAY_STYLE_DEFAULT",
            MessageDisplayStyle::Popup => "MESSAGE_DISPLAY_STYLE_POPUP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MESSAGE_DISPLAY_STYLE_DEFAULT" => Some(Self::Default),
            "MESSAGE_DISPLAY_STYLE_POPUP" => Some(Self::Popup),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProfitRankType {
    TypeHourlyRank = 0,
    TypeWeeklyRank = 1,
    TypeHourlyStarRank = 2,
    TypeWeeklyRisingRankActivity = 3,
    TypeWeeklyRisingRank = 4,
    TypeWeeklyRookie = 5,
    TypeECommerceWeekly = 6,
    TypeECommerceDaily = 7,
    TypeDailyRank = 8,
    TypeFirstGiftRank = 9,
    TypeGameRank = 10,
    TypeDailyGame = 11,
    TypeHallOfFameRank = 12,
    TypeRankLeague = 13,
    DailyRookie = 14,
    TypeTeamRank = 15,
    TypeClassRank = 16,
    TypeDailyGamePubG = 20,
    TypeDailyGameMlbB = 21,
    TypeDailyGameFreeFire = 22,
    TypeWeeklyGameSubcategoryOne = 23,
    TypeWeeklyGameSubcategoryTwo = 24,
    TypeWeeklyGameSubcategoryThree = 25,
}
impl ProfitRankType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ProfitRankType::TypeHourlyRank => "PROFIT_RANK_TYPE_TYPE_HOURLY_RANK",
            ProfitRankType::TypeWeeklyRank => "PROFIT_RANK_TYPE_TYPE_WEEKLY_RANK",
            ProfitRankType::TypeHourlyStarRank => {
                "PROFIT_RANK_TYPE_TYPE_HOURLY_STAR_RANK"
            }
            ProfitRankType::TypeWeeklyRisingRankActivity => {
                "PROFIT_RANK_TYPE_TYPE_WEEKLY_RISING_RANK_ACTIVITY"
            }
            ProfitRankType::TypeWeeklyRisingRank => {
                "PROFIT_RANK_TYPE_TYPE_WEEKLY_RISING_RANK"
            }
            ProfitRankType::TypeWeeklyRookie => "PROFIT_RANK_TYPE_TYPE_WEEKLY_ROOKIE",
            ProfitRankType::TypeECommerceWeekly => {
                "PROFIT_RANK_TYPE_TYPE_E_COMMERCE_WEEKLY"
            }
            ProfitRankType::TypeECommerceDaily => {
                "PROFIT_RANK_TYPE_TYPE_E_COMMERCE_DAILY"
            }
            ProfitRankType::TypeDailyRank => "PROFIT_RANK_TYPE_TYPE_DAILY_RANK",
            ProfitRankType::TypeFirstGiftRank => "PROFIT_RANK_TYPE_TYPE_FIRST_GIFT_RANK",
            ProfitRankType::TypeGameRank => "PROFIT_RANK_TYPE_TYPE_GAME_RANK",
            ProfitRankType::TypeDailyGame => "PROFIT_RANK_TYPE_TYPE_DAILY_GAME",
            ProfitRankType::TypeHallOfFameRank => {
                "PROFIT_RANK_TYPE_TYPE_HALL_OF_FAME_RANK"
            }
            ProfitRankType::TypeRankLeague => "PROFIT_RANK_TYPE_TYPE_RANK_LEAGUE",
            ProfitRankType::DailyRookie => "PROFIT_RANK_TYPE_DAILY_ROOKIE",
            ProfitRankType::TypeTeamRank => "PROFIT_RANK_TYPE_TYPE_TEAM_RANK",
            ProfitRankType::TypeClassRank => "PROFIT_RANK_TYPE_TYPE_CLASS_RANK",
            ProfitRankType::TypeDailyGamePubG => "PROFIT_RANK_TYPE_TYPE_DAILY_GAME_PUB_G",
            ProfitRankType::TypeDailyGameMlbB => "PROFIT_RANK_TYPE_TYPE_DAILY_GAME_MLB_B",
            ProfitRankType::TypeDailyGameFreeFire => {
                "PROFIT_RANK_TYPE_TYPE_DAILY_GAME_FREE_FIRE"
            }
            ProfitRankType::TypeWeeklyGameSubcategoryOne => {
                "PROFIT_RANK_TYPE_TYPE_WEEKLY_GAME_SUBCATEGORY_ONE"
            }
            ProfitRankType::TypeWeeklyGameSubcategoryTwo => {
                "PROFIT_RANK_TYPE_TYPE_WEEKLY_GAME_SUBCATEGORY_TWO"
            }
            ProfitRankType::TypeWeeklyGameSubcategoryThree => {
                "PROFIT_RANK_TYPE_TYPE_WEEKLY_GAME_SUBCATEGORY_THREE"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROFIT_RANK_TYPE_TYPE_HOURLY_RANK" => Some(Self::TypeHourlyRank),
            "PROFIT_RANK_TYPE_TYPE_WEEKLY_RANK" => Some(Self::TypeWeeklyRank),
            "PROFIT_RANK_TYPE_TYPE_HOURLY_STAR_RANK" => Some(Self::TypeHourlyStarRank),
            "PROFIT_RANK_TYPE_TYPE_WEEKLY_RISING_RANK_ACTIVITY" => {
                Some(Self::TypeWeeklyRisingRankActivity)
            }
            "PROFIT_RANK_TYPE_TYPE_WEEKLY_RISING_RANK" => {
                Some(Self::TypeWeeklyRisingRank)
            }
            "PROFIT_RANK_TYPE_TYPE_WEEKLY_ROOKIE" => Some(Self::TypeWeeklyRookie),
            "PROFIT_RANK_TYPE_TYPE_E_COMMERCE_WEEKLY" => Some(Self::TypeECommerceWeekly),
            "PROFIT_RANK_TYPE_TYPE_E_COMMERCE_DAILY" => Some(Self::TypeECommerceDaily),
            "PROFIT_RANK_TYPE_TYPE_DAILY_RANK" => Some(Self::TypeDailyRank),
            "PROFIT_RANK_TYPE_TYPE_FIRST_GIFT_RANK" => Some(Self::TypeFirstGiftRank),
            "PROFIT_RANK_TYPE_TYPE_GAME_RANK" => Some(Self::TypeGameRank),
            "PROFIT_RANK_TYPE_TYPE_DAILY_GAME" => Some(Self::TypeDailyGame),
            "PROFIT_RANK_TYPE_TYPE_HALL_OF_FAME_RANK" => Some(Self::TypeHallOfFameRank),
            "PROFIT_RANK_TYPE_TYPE_RANK_LEAGUE" => Some(Self::TypeRankLeague),
            "PROFIT_RANK_TYPE_DAILY_ROOKIE" => Some(Self::DailyRookie),
            "PROFIT_RANK_TYPE_TYPE_TEAM_RANK" => Some(Self::TypeTeamRank),
            "PROFIT_RANK_TYPE_TYPE_CLASS_RANK" => Some(Self::TypeClassRank),
            "PROFIT_RANK_TYPE_TYPE_DAILY_GAME_PUB_G" => Some(Self::TypeDailyGamePubG),
            "PROFIT_RANK_TYPE_TYPE_DAILY_GAME_MLB_B" => Some(Self::TypeDailyGameMlbB),
            "PROFIT_RANK_TYPE_TYPE_DAILY_GAME_FREE_FIRE" => {
                Some(Self::TypeDailyGameFreeFire)
            }
            "PROFIT_RANK_TYPE_TYPE_WEEKLY_GAME_SUBCATEGORY_ONE" => {
                Some(Self::TypeWeeklyGameSubcategoryOne)
            }
            "PROFIT_RANK_TYPE_TYPE_WEEKLY_GAME_SUBCATEGORY_TWO" => {
                Some(Self::TypeWeeklyGameSubcategoryTwo)
            }
            "PROFIT_RANK_TYPE_TYPE_WEEKLY_GAME_SUBCATEGORY_THREE" => {
                Some(Self::TypeWeeklyGameSubcategoryThree)
            }
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UnionAnimationInfoType {
    NoUnionAnimation = 0,
    Loop = 1,
    Lock = 2,
}
impl UnionAnimationInfoType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            UnionAnimationInfoType::NoUnionAnimation => {
                "UNION_ANIMATION_INFO_TYPE_NO_UNION_ANIMATION"
            }
            UnionAnimationInfoType::Loop => "UNION_ANIMATION_INFO_TYPE_LOOP",
            UnionAnimationInfoType::Lock => "UNION_ANIMATION_INFO_TYPE_LOCK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNION_ANIMATION_INFO_TYPE_NO_UNION_ANIMATION" => {
                Some(Self::NoUnionAnimation)
            }
            "UNION_ANIMATION_INFO_TYPE_LOOP" => Some(Self::Loop),
            "UNION_ANIMATION_INFO_TYPE_LOCK" => Some(Self::Lock),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DisplayStyle {
    Normal = 0,
    Stay = 1,
    Chat = 2,
}
impl DisplayStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DisplayStyle::Normal => "DISPLAY_STYLE_NORMAL",
            DisplayStyle::Stay => "DISPLAY_STYLE_STAY",
            DisplayStyle::Chat => "DISPLAY_STYLE_CHAT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DISPLAY_STYLE_NORMAL" => Some(Self::Normal),
            "DISPLAY_STYLE_STAY" => Some(Self::Stay),
            "DISPLAY_STYLE_CHAT" => Some(Self::Chat),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HitAbStatus {
    HitABStatusHitAbStatusNoHit = 0,
    HitABStatusHitAbStatusEnterFromExternalLinkNewText = 1,
    HitABStatusHitAbStatusEnterFromRePostNewText = 2,
}
impl HitAbStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            HitAbStatus::HitABStatusHitAbStatusNoHit => {
                "HIT_A_B_STATUS_HIT_AB_STATUS_NO_HIT"
            }
            HitAbStatus::HitABStatusHitAbStatusEnterFromExternalLinkNewText => {
                "HIT_A_B_STATUS_HIT_AB_STATUS_ENTER_FROM_EXTERNAL_LINK_NEW_TEXT"
            }
            HitAbStatus::HitABStatusHitAbStatusEnterFromRePostNewText => {
                "HIT_A_B_STATUS_HIT_AB_STATUS_ENTER_FROM_RE_POST_NEW_TEXT"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HIT_A_B_STATUS_HIT_AB_STATUS_NO_HIT" => {
                Some(Self::HitABStatusHitAbStatusNoHit)
            }
            "HIT_A_B_STATUS_HIT_AB_STATUS_ENTER_FROM_EXTERNAL_LINK_NEW_TEXT" => {
                Some(Self::HitABStatusHitAbStatusEnterFromExternalLinkNewText)
            }
            "HIT_A_B_STATUS_HIT_AB_STATUS_ENTER_FROM_RE_POST_NEW_TEXT" => {
                Some(Self::HitABStatusHitAbStatusEnterFromRePostNewText)
            }
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PollKind {
    Normal = 0,
    Gift = 1,
    Customizable = 2,
    CustomizableGift = 3,
    QuickGift = 4,
    Emote = 5,
}
impl PollKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PollKind::Normal => "POLL_KIND_NORMAL",
            PollKind::Gift => "POLL_KIND_GIFT",
            PollKind::Customizable => "POLL_KIND_CUSTOMIZABLE",
            PollKind::CustomizableGift => "POLL_KIND_CUSTOMIZABLE_GIFT",
            PollKind::QuickGift => "POLL_KIND_QUICK_GIFT",
            PollKind::Emote => "POLL_KIND_EMOTE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "POLL_KIND_NORMAL" => Some(Self::Normal),
            "POLL_KIND_GIFT" => Some(Self::Gift),
            "POLL_KIND_CUSTOMIZABLE" => Some(Self::Customizable),
            "POLL_KIND_CUSTOMIZABLE_GIFT" => Some(Self::CustomizableGift),
            "POLL_KIND_QUICK_GIFT" => Some(Self::QuickGift),
            "POLL_KIND_EMOTE" => Some(Self::Emote),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PollTemplateStatus {
    ToBeReviewed = 0,
    UnderReview = 1,
    Reviewed = 2,
    Refused = 3,
}
impl PollTemplateStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PollTemplateStatus::ToBeReviewed => "POLL_TEMPLATE_STATUS_TO_BE_REVIEWED",
            PollTemplateStatus::UnderReview => "POLL_TEMPLATE_STATUS_UNDER_REVIEW",
            PollTemplateStatus::Reviewed => "POLL_TEMPLATE_STATUS_REVIEWED",
            PollTemplateStatus::Refused => "POLL_TEMPLATE_STATUS_REFUSED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "POLL_TEMPLATE_STATUS_TO_BE_REVIEWED" => Some(Self::ToBeReviewed),
            "POLL_TEMPLATE_STATUS_UNDER_REVIEW" => Some(Self::UnderReview),
            "POLL_TEMPLATE_STATUS_REVIEWED" => Some(Self::Reviewed),
            "POLL_TEMPLATE_STATUS_REFUSED" => Some(Self::Refused),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PollAppealStatus {
    Unknown = 0,
    Pass = 1,
    Fail = 2,
}
impl PollAppealStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PollAppealStatus::Unknown => "POLL_APPEAL_STATUS_UNKNOWN",
            PollAppealStatus::Pass => "POLL_APPEAL_STATUS_PASS",
            PollAppealStatus::Fail => "POLL_APPEAL_STATUS_FAIL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "POLL_APPEAL_STATUS_UNKNOWN" => Some(Self::Unknown),
            "POLL_APPEAL_STATUS_PASS" => Some(Self::Pass),
            "POLL_APPEAL_STATUS_FAIL" => Some(Self::Fail),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RankTestMessageScene {
    Unknown = 0,
    OnlineAudienceTopNUpdatePublicScreen = 1,
}
impl RankTestMessageScene {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RankTestMessageScene::Unknown => "RANK_TEST_MESSAGE_SCENE_UNKNOWN",
            RankTestMessageScene::OnlineAudienceTopNUpdatePublicScreen => {
                "RANK_TEST_MESSAGE_SCENE_ONLINE_AUDIENCE_TOP_N_UPDATE_PUBLIC_SCREEN"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RANK_TEST_MESSAGE_SCENE_UNKNOWN" => Some(Self::Unknown),
            "RANK_TEST_MESSAGE_SCENE_ONLINE_AUDIENCE_TOP_N_UPDATE_PUBLIC_SCREEN" => {
                Some(Self::OnlineAudienceTopNUpdatePublicScreen)
            }
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TriggerReason {
    Unknown = 0,
    ScoreUpdate = 1,
    BattleEnd = 2,
    OptOutUpdate = 3,
    KeepAlive = 4,
}
impl TriggerReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TriggerReason::Unknown => "TRIGGER_REASON_UNKNOWN",
            TriggerReason::ScoreUpdate => "TRIGGER_REASON_SCORE_UPDATE",
            TriggerReason::BattleEnd => "TRIGGER_REASON_BATTLE_END",
            TriggerReason::OptOutUpdate => "TRIGGER_REASON_OPT_OUT_UPDATE",
            TriggerReason::KeepAlive => "TRIGGER_REASON_KEEP_ALIVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRIGGER_REASON_UNKNOWN" => Some(Self::Unknown),
            "TRIGGER_REASON_SCORE_UPDATE" => Some(Self::ScoreUpdate),
            "TRIGGER_REASON_BATTLE_END" => Some(Self::BattleEnd),
            "TRIGGER_REASON_OPT_OUT_UPDATE" => Some(Self::OptOutUpdate),
            "TRIGGER_REASON_KEEP_ALIVE" => Some(Self::KeepAlive),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Reason {
    TimeUp = 0,
    CutShort = 1,
}
impl Reason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Reason::TimeUp => "REASON_TIME_UP",
            Reason::CutShort => "REASON_CUT_SHORT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REASON_TIME_UP" => Some(Self::TimeUp),
            "REASON_CUT_SHORT" => Some(Self::CutShort),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BattleTaskMessageType {
    Start = 0,
    TaskUpdate = 1,
    TaskSettle = 2,
    RewardSettle = 3,
}
impl BattleTaskMessageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            BattleTaskMessageType::Start => "BATTLE_TASK_MESSAGE_TYPE_START",
            BattleTaskMessageType::TaskUpdate => "BATTLE_TASK_MESSAGE_TYPE_TASK_UPDATE",
            BattleTaskMessageType::TaskSettle => "BATTLE_TASK_MESSAGE_TYPE_TASK_SETTLE",
            BattleTaskMessageType::RewardSettle => {
                "BATTLE_TASK_MESSAGE_TYPE_REWARD_SETTLE"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BATTLE_TASK_MESSAGE_TYPE_START" => Some(Self::Start),
            "BATTLE_TASK_MESSAGE_TYPE_TASK_UPDATE" => Some(Self::TaskUpdate),
            "BATTLE_TASK_MESSAGE_TYPE_TASK_SETTLE" => Some(Self::TaskSettle),
            "BATTLE_TASK_MESSAGE_TYPE_REWARD_SETTLE" => Some(Self::RewardSettle),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RewardStatus {
    Succeed = 0,
    Failed = 1,
}
impl RewardStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RewardStatus::Succeed => "REWARD_STATUS_SUCCEED",
            RewardStatus::Failed => "REWARD_STATUS_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REWARD_STATUS_SUCCEED" => Some(Self::Succeed),
            "REWARD_STATUS_FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BattleAction {
    Unknown = 0,
    Invite = 1,
    Reject = 2,
    Cancel = 3,
    Open = 4,
    Finish = 5,
    CutShort = 6,
    Accept = 7,
    QuitApply = 8,
    DeclineQuit = 9,
    DeclineOffQuit = 10,
    LeaveLinkMic = 11,
}
impl BattleAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            BattleAction::Unknown => "BATTLE_ACTION_UNKNOWN",
            BattleAction::Invite => "BATTLE_ACTION_INVITE",
            BattleAction::Reject => "BATTLE_ACTION_REJECT",
            BattleAction::Cancel => "BATTLE_ACTION_CANCEL",
            BattleAction::Open => "BATTLE_ACTION_OPEN",
            BattleAction::Finish => "BATTLE_ACTION_FINISH",
            BattleAction::CutShort => "BATTLE_ACTION_CUT_SHORT",
            BattleAction::Accept => "BATTLE_ACTION_ACCEPT",
            BattleAction::QuitApply => "BATTLE_ACTION_QUIT_APPLY",
            BattleAction::DeclineQuit => "BATTLE_ACTION_DECLINE_QUIT",
            BattleAction::DeclineOffQuit => "BATTLE_ACTION_DECLINE_OFF_QUIT",
            BattleAction::LeaveLinkMic => "BATTLE_ACTION_LEAVE_LINK_MIC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BATTLE_ACTION_UNKNOWN" => Some(Self::Unknown),
            "BATTLE_ACTION_INVITE" => Some(Self::Invite),
            "BATTLE_ACTION_REJECT" => Some(Self::Reject),
            "BATTLE_ACTION_CANCEL" => Some(Self::Cancel),
            "BATTLE_ACTION_OPEN" => Some(Self::Open),
            "BATTLE_ACTION_FINISH" => Some(Self::Finish),
            "BATTLE_ACTION_CUT_SHORT" => Some(Self::CutShort),
            "BATTLE_ACTION_ACCEPT" => Some(Self::Accept),
            "BATTLE_ACTION_QUIT_APPLY" => Some(Self::QuitApply),
            "BATTLE_ACTION_DECLINE_QUIT" => Some(Self::DeclineQuit),
            "BATTLE_ACTION_DECLINE_OFF_QUIT" => Some(Self::DeclineOffQuit),
            "BATTLE_ACTION_LEAVE_LINK_MIC" => Some(Self::LeaveLinkMic),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Result {
    Win = 0,
    Lose = 1,
    Draw = 2,
}
impl Result {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Result::Win => "RESULT_WIN",
            Result::Lose => "RESULT_LOSE",
            Result::Draw => "RESULT_DRAW",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESULT_WIN" => Some(Self::Win),
            "RESULT_LOSE" => Some(Self::Lose),
            "RESULT_DRAW" => Some(Self::Draw),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GiftPermissionType {
    UnknownType = 0,
    NoGiftPermission = 1,
    AnchorClose = 2,
    HasGiftPermission = 3,
    AnchorBanned = 4,
}
impl GiftPermissionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            GiftPermissionType::UnknownType => "GIFT_PERMISSION_TYPE_UNKNOWN_TYPE",
            GiftPermissionType::NoGiftPermission => {
                "GIFT_PERMISSION_TYPE_NO_GIFT_PERMISSION"
            }
            GiftPermissionType::AnchorClose => "GIFT_PERMISSION_TYPE_ANCHOR_CLOSE",
            GiftPermissionType::HasGiftPermission => {
                "GIFT_PERMISSION_TYPE_HAS_GIFT_PERMISSION"
            }
            GiftPermissionType::AnchorBanned => "GIFT_PERMISSION_TYPE_ANCHOR_BANNED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GIFT_PERMISSION_TYPE_UNKNOWN_TYPE" => Some(Self::UnknownType),
            "GIFT_PERMISSION_TYPE_NO_GIFT_PERMISSION" => Some(Self::NoGiftPermission),
            "GIFT_PERMISSION_TYPE_ANCHOR_CLOSE" => Some(Self::AnchorClose),
            "GIFT_PERMISSION_TYPE_HAS_GIFT_PERMISSION" => Some(Self::HasGiftPermission),
            "GIFT_PERMISSION_TYPE_ANCHOR_BANNED" => Some(Self::AnchorBanned),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BattleAbTestType {
    BattleABTestTypeUnknownAbTestType = 0,
    BattleABTestTypeMeanwhileInvite = 1,
    BattleABTestTypeSpecifiedGift = 2,
    BattleABTestTypeRtCMessageChannel = 3,
    BattleABTestTypeConnectionTimeOut = 4,
    BattleABTestTypeRematchSkipTeammate = 5,
    BattleABTestTypeOptInvitee4048 = 6,
    BattleABTestTypeBattleAbTestTypeTimeCalibrate = 7,
}
impl BattleAbTestType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            BattleAbTestType::BattleABTestTypeUnknownAbTestType => {
                "BATTLE_A_B_TEST_TYPE_UNKNOWN_AB_TEST_TYPE"
            }
            BattleAbTestType::BattleABTestTypeMeanwhileInvite => {
                "BATTLE_A_B_TEST_TYPE_MEANWHILE_INVITE"
            }
            BattleAbTestType::BattleABTestTypeSpecifiedGift => {
                "BATTLE_A_B_TEST_TYPE_SPECIFIED_GIFT"
            }
            BattleAbTestType::BattleABTestTypeRtCMessageChannel => {
                "BATTLE_A_B_TEST_TYPE_RT_C_MESSAGE_CHANNEL"
            }
            BattleAbTestType::BattleABTestTypeConnectionTimeOut => {
                "BATTLE_A_B_TEST_TYPE_CONNECTION_TIME_OUT"
            }
            BattleAbTestType::BattleABTestTypeRematchSkipTeammate => {
                "BATTLE_A_B_TEST_TYPE_REMATCH_SKIP_TEAMMATE"
            }
            BattleAbTestType::BattleABTestTypeOptInvitee4048 => {
                "BATTLE_A_B_TEST_TYPE_OPT_INVITEE_4048"
            }
            BattleAbTestType::BattleABTestTypeBattleAbTestTypeTimeCalibrate => {
                "BATTLE_A_B_TEST_TYPE_BATTLE_AB_TEST_TYPE_TIME_CALIBRATE"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BATTLE_A_B_TEST_TYPE_UNKNOWN_AB_TEST_TYPE" => {
                Some(Self::BattleABTestTypeUnknownAbTestType)
            }
            "BATTLE_A_B_TEST_TYPE_MEANWHILE_INVITE" => {
                Some(Self::BattleABTestTypeMeanwhileInvite)
            }
            "BATTLE_A_B_TEST_TYPE_SPECIFIED_GIFT" => {
                Some(Self::BattleABTestTypeSpecifiedGift)
            }
            "BATTLE_A_B_TEST_TYPE_RT_C_MESSAGE_CHANNEL" => {
                Some(Self::BattleABTestTypeRtCMessageChannel)
            }
            "BATTLE_A_B_TEST_TYPE_CONNECTION_TIME_OUT" => {
                Some(Self::BattleABTestTypeConnectionTimeOut)
            }
            "BATTLE_A_B_TEST_TYPE_REMATCH_SKIP_TEAMMATE" => {
                Some(Self::BattleABTestTypeRematchSkipTeammate)
            }
            "BATTLE_A_B_TEST_TYPE_OPT_INVITEE_4048" => {
                Some(Self::BattleABTestTypeOptInvitee4048)
            }
            "BATTLE_A_B_TEST_TYPE_BATTLE_AB_TEST_TYPE_TIME_CALIBRATE" => {
                Some(Self::BattleABTestTypeBattleAbTestTypeTimeCalibrate)
            }
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PlayScene {
    Unknown = 0,
    CountdownForAll = 1,
    CountdownForSingle = 2,
    LiveShow = 3,
    AigC = 4,
    Karaoke = 5,
    DrawGuess = 6,
    EnlargeGrid = 7,
    GiftPriorityLink = 8,
    GiftThresholdLink = 9,
    NoticeBoard = 10,
    PlayBook = 11,
    GuestShowdown = 12,
}
impl PlayScene {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PlayScene::Unknown => "PLAY_SCENE_UNKNOWN",
            PlayScene::CountdownForAll => "PLAY_SCENE_COUNTDOWN_FOR_ALL",
            PlayScene::CountdownForSingle => "PLAY_SCENE_COUNTDOWN_FOR_SINGLE",
            PlayScene::LiveShow => "PLAY_SCENE_LIVE_SHOW",
            PlayScene::AigC => "PLAY_SCENE_AIG_C",
            PlayScene::Karaoke => "PLAY_SCENE_KARAOKE",
            PlayScene::DrawGuess => "PLAY_SCENE_DRAW_GUESS",
            PlayScene::EnlargeGrid => "PLAY_SCENE_ENLARGE_GRID",
            PlayScene::GiftPriorityLink => "PLAY_SCENE_GIFT_PRIORITY_LINK",
            PlayScene::GiftThresholdLink => "PLAY_SCENE_GIFT_THRESHOLD_LINK",
            PlayScene::NoticeBoard => "PLAY_SCENE_NOTICE_BOARD",
            PlayScene::PlayBook => "PLAY_SCENE_PLAY_BOOK",
            PlayScene::GuestShowdown => "PLAY_SCENE_GUEST_SHOWDOWN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PLAY_SCENE_UNKNOWN" => Some(Self::Unknown),
            "PLAY_SCENE_COUNTDOWN_FOR_ALL" => Some(Self::CountdownForAll),
            "PLAY_SCENE_COUNTDOWN_FOR_SINGLE" => Some(Self::CountdownForSingle),
            "PLAY_SCENE_LIVE_SHOW" => Some(Self::LiveShow),
            "PLAY_SCENE_AIG_C" => Some(Self::AigC),
            "PLAY_SCENE_KARAOKE" => Some(Self::Karaoke),
            "PLAY_SCENE_DRAW_GUESS" => Some(Self::DrawGuess),
            "PLAY_SCENE_ENLARGE_GRID" => Some(Self::EnlargeGrid),
            "PLAY_SCENE_GIFT_PRIORITY_LINK" => Some(Self::GiftPriorityLink),
            "PLAY_SCENE_GIFT_THRESHOLD_LINK" => Some(Self::GiftThresholdLink),
            "PLAY_SCENE_NOTICE_BOARD" => Some(Self::NoticeBoard),
            "PLAY_SCENE_PLAY_BOOK" => Some(Self::PlayBook),
            "PLAY_SCENE_GUEST_SHOWDOWN" => Some(Self::GuestShowdown),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LinkType {
    TypeUnknown = 0,
    TypeVideo = 1,
    TypeAudio = 2,
    TypeVirtual = 3,
}
impl LinkType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LinkType::TypeUnknown => "LINK_TYPE_TYPE_UNKNOWN",
            LinkType::TypeVideo => "LINK_TYPE_TYPE_VIDEO",
            LinkType::TypeAudio => "LINK_TYPE_TYPE_AUDIO",
            LinkType::TypeVirtual => "LINK_TYPE_TYPE_VIRTUAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LINK_TYPE_TYPE_UNKNOWN" => Some(Self::TypeUnknown),
            "LINK_TYPE_TYPE_VIDEO" => Some(Self::TypeVideo),
            "LINK_TYPE_TYPE_AUDIO" => Some(Self::TypeAudio),
            "LINK_TYPE_TYPE_VIRTUAL" => Some(Self::TypeVirtual),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LinkSilenceStatus {
    StatusUnSilence = 0,
    StatusSilenceBySelf = 1,
    StatusSilenceByOwner = 2,
}
impl LinkSilenceStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LinkSilenceStatus::StatusUnSilence => "LINK_SILENCE_STATUS_STATUS_UN_SILENCE",
            LinkSilenceStatus::StatusSilenceBySelf => {
                "LINK_SILENCE_STATUS_STATUS_SILENCE_BY_SELF"
            }
            LinkSilenceStatus::StatusSilenceByOwner => {
                "LINK_SILENCE_STATUS_STATUS_SILENCE_BY_OWNER"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LINK_SILENCE_STATUS_STATUS_UN_SILENCE" => Some(Self::StatusUnSilence),
            "LINK_SILENCE_STATUS_STATUS_SILENCE_BY_SELF" => {
                Some(Self::StatusSilenceBySelf)
            }
            "LINK_SILENCE_STATUS_STATUS_SILENCE_BY_OWNER" => {
                Some(Self::StatusSilenceByOwner)
            }
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LinkmicRoleType {
    RoleTypeUnkown = 0,
    Leader = 1,
    Player = 2,
    Invitee = 3,
}
impl LinkmicRoleType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LinkmicRoleType::RoleTypeUnkown => "LINKMIC_ROLE_TYPE_ROLE_TYPE_UNKOWN",
            LinkmicRoleType::Leader => "LINKMIC_ROLE_TYPE_LEADER",
            LinkmicRoleType::Player => "LINKMIC_ROLE_TYPE_PLAYER",
            LinkmicRoleType::Invitee => "LINKMIC_ROLE_TYPE_INVITEE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LINKMIC_ROLE_TYPE_ROLE_TYPE_UNKOWN" => Some(Self::RoleTypeUnkown),
            "LINKMIC_ROLE_TYPE_LEADER" => Some(Self::Leader),
            "LINKMIC_ROLE_TYPE_PLAYER" => Some(Self::Player),
            "LINKMIC_ROLE_TYPE_INVITEE" => Some(Self::Invitee),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LinkRoleType {
    TypeRoleTypeUnkown = 0,
    TypeLeader = 1,
    TypePlayer = 2,
    TypeInvitee = 3,
    TypeApplier = 4,
}
impl LinkRoleType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LinkRoleType::TypeRoleTypeUnkown => "LINK_ROLE_TYPE_TYPE_ROLE_TYPE_UNKOWN",
            LinkRoleType::TypeLeader => "LINK_ROLE_TYPE_TYPE_LEADER",
            LinkRoleType::TypePlayer => "LINK_ROLE_TYPE_TYPE_PLAYER",
            LinkRoleType::TypeInvitee => "LINK_ROLE_TYPE_TYPE_INVITEE",
            LinkRoleType::TypeApplier => "LINK_ROLE_TYPE_TYPE_APPLIER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LINK_ROLE_TYPE_TYPE_ROLE_TYPE_UNKOWN" => Some(Self::TypeRoleTypeUnkown),
            "LINK_ROLE_TYPE_TYPE_LEADER" => Some(Self::TypeLeader),
            "LINK_ROLE_TYPE_TYPE_PLAYER" => Some(Self::TypePlayer),
            "LINK_ROLE_TYPE_TYPE_INVITEE" => Some(Self::TypeInvitee),
            "LINK_ROLE_TYPE_TYPE_APPLIER" => Some(Self::TypeApplier),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MuteStatus {
    Mute = 0,
    UnMute = 1,
}
impl MuteStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            MuteStatus::Mute => "MUTE_STATUS_MUTE",
            MuteStatus::UnMute => "MUTE_STATUS_UN_MUTE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MUTE_STATUS_MUTE" => Some(Self::Mute),
            "MUTE_STATUS_UN_MUTE" => Some(Self::UnMute),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GuestMicCameraManageOp {
    OpenMic = 0,
    OpenCamera = 1,
    CloseMic = 2,
    CloseCamera = 3,
    CloseMicPunish = 4,
}
impl GuestMicCameraManageOp {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            GuestMicCameraManageOp::OpenMic => "GUEST_MIC_CAMERA_MANAGE_OP_OPEN_MIC",
            GuestMicCameraManageOp::OpenCamera => {
                "GUEST_MIC_CAMERA_MANAGE_OP_OPEN_CAMERA"
            }
            GuestMicCameraManageOp::CloseMic => "GUEST_MIC_CAMERA_MANAGE_OP_CLOSE_MIC",
            GuestMicCameraManageOp::CloseCamera => {
                "GUEST_MIC_CAMERA_MANAGE_OP_CLOSE_CAMERA"
            }
            GuestMicCameraManageOp::CloseMicPunish => {
                "GUEST_MIC_CAMERA_MANAGE_OP_CLOSE_MIC_PUNISH"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GUEST_MIC_CAMERA_MANAGE_OP_OPEN_MIC" => Some(Self::OpenMic),
            "GUEST_MIC_CAMERA_MANAGE_OP_OPEN_CAMERA" => Some(Self::OpenCamera),
            "GUEST_MIC_CAMERA_MANAGE_OP_CLOSE_MIC" => Some(Self::CloseMic),
            "GUEST_MIC_CAMERA_MANAGE_OP_CLOSE_CAMERA" => Some(Self::CloseCamera),
            "GUEST_MIC_CAMERA_MANAGE_OP_CLOSE_MIC_PUNISH" => Some(Self::CloseMicPunish),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GuestMicCameraChangeScene {
    ChangeSceneUnknown = 0,
    LiveShowByAnchorAuto = 1,
    LiveShowByServerNormal = 2,
    LiveShowByShowEnd = 3,
}
impl GuestMicCameraChangeScene {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            GuestMicCameraChangeScene::ChangeSceneUnknown => {
                "GUEST_MIC_CAMERA_CHANGE_SCENE_CHANGE_SCENE_UNKNOWN"
            }
            GuestMicCameraChangeScene::LiveShowByAnchorAuto => {
                "GUEST_MIC_CAMERA_CHANGE_SCENE_LIVE_SHOW_BY_ANCHOR_AUTO"
            }
            GuestMicCameraChangeScene::LiveShowByServerNormal => {
                "GUEST_MIC_CAMERA_CHANGE_SCENE_LIVE_SHOW_BY_SERVER_NORMAL"
            }
            GuestMicCameraChangeScene::LiveShowByShowEnd => {
                "GUEST_MIC_CAMERA_CHANGE_SCENE_LIVE_SHOW_BY_SHOW_END"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GUEST_MIC_CAMERA_CHANGE_SCENE_CHANGE_SCENE_UNKNOWN" => {
                Some(Self::ChangeSceneUnknown)
            }
            "GUEST_MIC_CAMERA_CHANGE_SCENE_LIVE_SHOW_BY_ANCHOR_AUTO" => {
                Some(Self::LiveShowByAnchorAuto)
            }
            "GUEST_MIC_CAMERA_CHANGE_SCENE_LIVE_SHOW_BY_SERVER_NORMAL" => {
                Some(Self::LiveShowByServerNormal)
            }
            "GUEST_MIC_CAMERA_CHANGE_SCENE_LIVE_SHOW_BY_SHOW_END" => {
                Some(Self::LiveShowByShowEnd)
            }
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LinkMicUserAdminType {
    UndefinedType = 0,
    ManagerType = 1,
    HostType = 2,
}
impl LinkMicUserAdminType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LinkMicUserAdminType::UndefinedType => {
                "LINK_MIC_USER_ADMIN_TYPE_UNDEFINED_TYPE"
            }
            LinkMicUserAdminType::ManagerType => "LINK_MIC_USER_ADMIN_TYPE_MANAGER_TYPE",
            LinkMicUserAdminType::HostType => "LINK_MIC_USER_ADMIN_TYPE_HOST_TYPE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LINK_MIC_USER_ADMIN_TYPE_UNDEFINED_TYPE" => Some(Self::UndefinedType),
            "LINK_MIC_USER_ADMIN_TYPE_MANAGER_TYPE" => Some(Self::ManagerType),
            "LINK_MIC_USER_ADMIN_TYPE_HOST_TYPE" => Some(Self::HostType),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LinkmicMultiLiveEnum {
    Default = 0,
    AnchorUseNewLayout = 1,
}
impl LinkmicMultiLiveEnum {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LinkmicMultiLiveEnum::Default => "LINKMIC_MULTI_LIVE_ENUM_DEFAULT",
            LinkmicMultiLiveEnum::AnchorUseNewLayout => {
                "LINKMIC_MULTI_LIVE_ENUM_ANCHOR_USE_NEW_LAYOUT"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LINKMIC_MULTI_LIVE_ENUM_DEFAULT" => Some(Self::Default),
            "LINKMIC_MULTI_LIVE_ENUM_ANCHOR_USE_NEW_LAYOUT" => {
                Some(Self::AnchorUseNewLayout)
            }
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PollEndType {
    PollEndByTime = 0,
    PollEndByOwner = 1,
    PollEndByOther = 2,
    PollEndByAdmin = 3,
}
impl PollEndType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PollEndType::PollEndByTime => "POLL_END_TYPE_POLL_END_BY_TIME",
            PollEndType::PollEndByOwner => "POLL_END_TYPE_POLL_END_BY_OWNER",
            PollEndType::PollEndByOther => "POLL_END_TYPE_POLL_END_BY_OTHER",
            PollEndType::PollEndByAdmin => "POLL_END_TYPE_POLL_END_BY_ADMIN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "POLL_END_TYPE_POLL_END_BY_TIME" => Some(Self::PollEndByTime),
            "POLL_END_TYPE_POLL_END_BY_OWNER" => Some(Self::PollEndByOwner),
            "POLL_END_TYPE_POLL_END_BY_OTHER" => Some(Self::PollEndByOther),
            "POLL_END_TYPE_POLL_END_BY_ADMIN" => Some(Self::PollEndByAdmin),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CohostAbTestType {
    CohostABTestTypeCohostAbTestTypeUnknown = 0,
    CohostABTestTypeCohostAbTestTypeLinkTimeOutStrategy = 1,
    CohostABTestTypeCohostAbTestTypeCohostReservation = 2,
    CohostABTestTypeCohostAbTestTypeQuickPairNewArchSwitch = 3,
    CohostABTestTypeCohostAbTestTypeCohostInvitationText = 4,
}
impl CohostAbTestType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CohostAbTestType::CohostABTestTypeCohostAbTestTypeUnknown => {
                "COHOST_A_B_TEST_TYPE_COHOST_AB_TEST_TYPE_UNKNOWN"
            }
            CohostAbTestType::CohostABTestTypeCohostAbTestTypeLinkTimeOutStrategy => {
                "COHOST_A_B_TEST_TYPE_COHOST_AB_TEST_TYPE_LINK_TIME_OUT_STRATEGY"
            }
            CohostAbTestType::CohostABTestTypeCohostAbTestTypeCohostReservation => {
                "COHOST_A_B_TEST_TYPE_COHOST_AB_TEST_TYPE_COHOST_RESERVATION"
            }
            CohostAbTestType::CohostABTestTypeCohostAbTestTypeQuickPairNewArchSwitch => {
                "COHOST_A_B_TEST_TYPE_COHOST_AB_TEST_TYPE_QUICK_PAIR_NEW_ARCH_SWITCH"
            }
            CohostAbTestType::CohostABTestTypeCohostAbTestTypeCohostInvitationText => {
                "COHOST_A_B_TEST_TYPE_COHOST_AB_TEST_TYPE_COHOST_INVITATION_TEXT"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COHOST_A_B_TEST_TYPE_COHOST_AB_TEST_TYPE_UNKNOWN" => {
                Some(Self::CohostABTestTypeCohostAbTestTypeUnknown)
            }
            "COHOST_A_B_TEST_TYPE_COHOST_AB_TEST_TYPE_LINK_TIME_OUT_STRATEGY" => {
                Some(Self::CohostABTestTypeCohostAbTestTypeLinkTimeOutStrategy)
            }
            "COHOST_A_B_TEST_TYPE_COHOST_AB_TEST_TYPE_COHOST_RESERVATION" => {
                Some(Self::CohostABTestTypeCohostAbTestTypeCohostReservation)
            }
            "COHOST_A_B_TEST_TYPE_COHOST_AB_TEST_TYPE_QUICK_PAIR_NEW_ARCH_SWITCH" => {
                Some(Self::CohostABTestTypeCohostAbTestTypeQuickPairNewArchSwitch)
            }
            "COHOST_A_B_TEST_TYPE_COHOST_AB_TEST_TYPE_COHOST_INVITATION_TEXT" => {
                Some(Self::CohostABTestTypeCohostAbTestTypeCohostInvitationText)
            }
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OptPairStatus {
    Unknown = 0,
    Offline = 1,
    Finished = 2,
}
impl OptPairStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            OptPairStatus::Unknown => "OPT_PAIR_STATUS_UNKNOWN",
            OptPairStatus::Offline => "OPT_PAIR_STATUS_OFFLINE",
            OptPairStatus::Finished => "OPT_PAIR_STATUS_FINISHED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OPT_PAIR_STATUS_UNKNOWN" => Some(Self::Unknown),
            "OPT_PAIR_STATUS_OFFLINE" => Some(Self::Offline),
            "OPT_PAIR_STATUS_FINISHED" => Some(Self::Finished),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ContentPositionType {
    Unknown = 0,
    Stream = 1,
    LiveStudioStreamPortrait = 2,
    LiveStudioStreamLandscape = 3,
}
impl ContentPositionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ContentPositionType::Unknown => "CONTENT_POSITION_TYPE_UNKNOWN",
            ContentPositionType::Stream => "CONTENT_POSITION_TYPE_STREAM",
            ContentPositionType::LiveStudioStreamPortrait => {
                "CONTENT_POSITION_TYPE_LIVE_STUDIO_STREAM_PORTRAIT"
            }
            ContentPositionType::LiveStudioStreamLandscape => {
                "CONTENT_POSITION_TYPE_LIVE_STUDIO_STREAM_LANDSCAPE"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONTENT_POSITION_TYPE_UNKNOWN" => Some(Self::Unknown),
            "CONTENT_POSITION_TYPE_STREAM" => Some(Self::Stream),
            "CONTENT_POSITION_TYPE_LIVE_STUDIO_STREAM_PORTRAIT" => {
                Some(Self::LiveStudioStreamPortrait)
            }
            "CONTENT_POSITION_TYPE_LIVE_STUDIO_STREAM_LANDSCAPE" => {
                Some(Self::LiveStudioStreamLandscape)
            }
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MultiGuestOutsideRoomInviteSource {
    OutsideRoomInviteSourceUnknown = 0,
    OutsideRoomInviteSourcePanel = 1,
    OutsideRoomInviteSourceCapsule = 2,
    OutsideRoomInviteSourceEmptyPosition = 3,
}
impl MultiGuestOutsideRoomInviteSource {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            MultiGuestOutsideRoomInviteSource::OutsideRoomInviteSourceUnknown => {
                "MULTI_GUEST_OUTSIDE_ROOM_INVITE_SOURCE_OUTSIDE_ROOM_INVITE_SOURCE_UNKNOWN"
            }
            MultiGuestOutsideRoomInviteSource::OutsideRoomInviteSourcePanel => {
                "MULTI_GUEST_OUTSIDE_ROOM_INVITE_SOURCE_OUTSIDE_ROOM_INVITE_SOURCE_PANEL"
            }
            MultiGuestOutsideRoomInviteSource::OutsideRoomInviteSourceCapsule => {
                "MULTI_GUEST_OUTSIDE_ROOM_INVITE_SOURCE_OUTSIDE_ROOM_INVITE_SOURCE_CAPSULE"
            }
            MultiGuestOutsideRoomInviteSource::OutsideRoomInviteSourceEmptyPosition => {
                "MULTI_GUEST_OUTSIDE_ROOM_INVITE_SOURCE_OUTSIDE_ROOM_INVITE_SOURCE_EMPTY_POSITION"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MULTI_GUEST_OUTSIDE_ROOM_INVITE_SOURCE_OUTSIDE_ROOM_INVITE_SOURCE_UNKNOWN" => {
                Some(Self::OutsideRoomInviteSourceUnknown)
            }
            "MULTI_GUEST_OUTSIDE_ROOM_INVITE_SOURCE_OUTSIDE_ROOM_INVITE_SOURCE_PANEL" => {
                Some(Self::OutsideRoomInviteSourcePanel)
            }
            "MULTI_GUEST_OUTSIDE_ROOM_INVITE_SOURCE_OUTSIDE_ROOM_INVITE_SOURCE_CAPSULE" => {
                Some(Self::OutsideRoomInviteSourceCapsule)
            }
            "MULTI_GUEST_OUTSIDE_ROOM_INVITE_SOURCE_OUTSIDE_ROOM_INVITE_SOURCE_EMPTY_POSITION" => {
                Some(Self::OutsideRoomInviteSourceEmptyPosition)
            }
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LinkUserType {
    Default = 0,
    Karaoke = 1,
}
impl LinkUserType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LinkUserType::Default => "LINK_USER_TYPE_DEFAULT",
            LinkUserType::Karaoke => "LINK_USER_TYPE_KARAOKE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LINK_USER_TYPE_DEFAULT" => Some(Self::Default),
            "LINK_USER_TYPE_KARAOKE" => Some(Self::Karaoke),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ContentInviteSource {
    InviteSourceUnknown = 0,
    InviteSourcePanelGoLive = 1,
    InviteSourceMutualNotice = 2,
    InviteSourceUserProfile = 3,
    InviteSourceReserve = 4,
}
impl ContentInviteSource {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ContentInviteSource::InviteSourceUnknown => {
                "CONTENT_INVITE_SOURCE_INVITE_SOURCE_UNKNOWN"
            }
            ContentInviteSource::InviteSourcePanelGoLive => {
                "CONTENT_INVITE_SOURCE_INVITE_SOURCE_PANEL_GO_LIVE"
            }
            ContentInviteSource::InviteSourceMutualNotice => {
                "CONTENT_INVITE_SOURCE_INVITE_SOURCE_MUTUAL_NOTICE"
            }
            ContentInviteSource::InviteSourceUserProfile => {
                "CONTENT_INVITE_SOURCE_INVITE_SOURCE_USER_PROFILE"
            }
            ContentInviteSource::InviteSourceReserve => {
                "CONTENT_INVITE_SOURCE_INVITE_SOURCE_RESERVE"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONTENT_INVITE_SOURCE_INVITE_SOURCE_UNKNOWN" => {
                Some(Self::InviteSourceUnknown)
            }
            "CONTENT_INVITE_SOURCE_INVITE_SOURCE_PANEL_GO_LIVE" => {
                Some(Self::InviteSourcePanelGoLive)
            }
            "CONTENT_INVITE_SOURCE_INVITE_SOURCE_MUTUAL_NOTICE" => {
                Some(Self::InviteSourceMutualNotice)
            }
            "CONTENT_INVITE_SOURCE_INVITE_SOURCE_USER_PROFILE" => {
                Some(Self::InviteSourceUserProfile)
            }
            "CONTENT_INVITE_SOURCE_INVITE_SOURCE_RESERVE" => {
                Some(Self::InviteSourceReserve)
            }
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LinkmicShareRevenueSetting {
    LinkMicShareRevenueNotSet = 0,
    LinkMicShareRevenueOpen = 1,
    LinkMicShareRevenueClose = 2,
}
impl LinkmicShareRevenueSetting {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LinkmicShareRevenueSetting::LinkMicShareRevenueNotSet => {
                "LINKMIC_SHARE_REVENUE_SETTING_LINK_MIC_SHARE_REVENUE_NOT_SET"
            }
            LinkmicShareRevenueSetting::LinkMicShareRevenueOpen => {
                "LINKMIC_SHARE_REVENUE_SETTING_LINK_MIC_SHARE_REVENUE_OPEN"
            }
            LinkmicShareRevenueSetting::LinkMicShareRevenueClose => {
                "LINKMIC_SHARE_REVENUE_SETTING_LINK_MIC_SHARE_REVENUE_CLOSE"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LINKMIC_SHARE_REVENUE_SETTING_LINK_MIC_SHARE_REVENUE_NOT_SET" => {
                Some(Self::LinkMicShareRevenueNotSet)
            }
            "LINKMIC_SHARE_REVENUE_SETTING_LINK_MIC_SHARE_REVENUE_OPEN" => {
                Some(Self::LinkMicShareRevenueOpen)
            }
            "LINKMIC_SHARE_REVENUE_SETTING_LINK_MIC_SHARE_REVENUE_CLOSE" => {
                Some(Self::LinkMicShareRevenueClose)
            }
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PosIdentityType {
    IdentityEmptySlot = 0,
    IdentityRtCUserId = 1,
    IdentityRtCStreamId = 2,
    IdentityLiveUserId = 3,
}
impl PosIdentityType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PosIdentityType::IdentityEmptySlot => "POS_IDENTITY_TYPE_IDENTITY_EMPTY_SLOT",
            PosIdentityType::IdentityRtCUserId => {
                "POS_IDENTITY_TYPE_IDENTITY_RT_C_USER_ID"
            }
            PosIdentityType::IdentityRtCStreamId => {
                "POS_IDENTITY_TYPE_IDENTITY_RT_C_STREAM_ID"
            }
            PosIdentityType::IdentityLiveUserId => {
                "POS_IDENTITY_TYPE_IDENTITY_LIVE_USER_ID"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "POS_IDENTITY_TYPE_IDENTITY_EMPTY_SLOT" => Some(Self::IdentityEmptySlot),
            "POS_IDENTITY_TYPE_IDENTITY_RT_C_USER_ID" => Some(Self::IdentityRtCUserId),
            "POS_IDENTITY_TYPE_IDENTITY_RT_C_STREAM_ID" => {
                Some(Self::IdentityRtCStreamId)
            }
            "POS_IDENTITY_TYPE_IDENTITY_LIVE_USER_ID" => Some(Self::IdentityLiveUserId),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JoinType {
    Unknown = 0,
    ChannelApply = 1,
    ChannelInvite = 2,
    GroupApply = 100,
    GroupApplyFollow = 101,
    GroupInvite = 102,
    GroupInviteFollow = 103,
    GroupOwnerJoin = 104,
}
impl JoinType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            JoinType::Unknown => "JOIN_TYPE_UNKNOWN",
            JoinType::ChannelApply => "JOIN_TYPE_CHANNEL_APPLY",
            JoinType::ChannelInvite => "JOIN_TYPE_CHANNEL_INVITE",
            JoinType::GroupApply => "JOIN_TYPE_GROUP_APPLY",
            JoinType::GroupApplyFollow => "JOIN_TYPE_GROUP_APPLY_FOLLOW",
            JoinType::GroupInvite => "JOIN_TYPE_GROUP_INVITE",
            JoinType::GroupInviteFollow => "JOIN_TYPE_GROUP_INVITE_FOLLOW",
            JoinType::GroupOwnerJoin => "JOIN_TYPE_GROUP_OWNER_JOIN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "JOIN_TYPE_UNKNOWN" => Some(Self::Unknown),
            "JOIN_TYPE_CHANNEL_APPLY" => Some(Self::ChannelApply),
            "JOIN_TYPE_CHANNEL_INVITE" => Some(Self::ChannelInvite),
            "JOIN_TYPE_GROUP_APPLY" => Some(Self::GroupApply),
            "JOIN_TYPE_GROUP_APPLY_FOLLOW" => Some(Self::GroupApplyFollow),
            "JOIN_TYPE_GROUP_INVITE" => Some(Self::GroupInvite),
            "JOIN_TYPE_GROUP_INVITE_FOLLOW" => Some(Self::GroupInviteFollow),
            "JOIN_TYPE_GROUP_OWNER_JOIN" => Some(Self::GroupOwnerJoin),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CohostLayoutMode {
    Normal = 0,
    ScreenShare = 1,
}
impl CohostLayoutMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CohostLayoutMode::Normal => "COHOST_LAYOUT_MODE_NORMAL",
            CohostLayoutMode::ScreenShare => "COHOST_LAYOUT_MODE_SCREEN_SHARE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COHOST_LAYOUT_MODE_NORMAL" => Some(Self::Normal),
            "COHOST_LAYOUT_MODE_SCREEN_SHARE" => Some(Self::ScreenShare),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TagClassification {
    Unknown = 0,
    CohostHistory = 1,
    FirstDegreeRelation = 2,
    SecondDegreeRelation = 3,
    Rank = 4,
    SimilarInterests = 5,
}
impl TagClassification {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TagClassification::Unknown => "TAG_CLASSIFICATION_UNKNOWN",
            TagClassification::CohostHistory => "TAG_CLASSIFICATION_COHOST_HISTORY",
            TagClassification::FirstDegreeRelation => {
                "TAG_CLASSIFICATION_FIRST_DEGREE_RELATION"
            }
            TagClassification::SecondDegreeRelation => {
                "TAG_CLASSIFICATION_SECOND_DEGREE_RELATION"
            }
            TagClassification::Rank => "TAG_CLASSIFICATION_RANK",
            TagClassification::SimilarInterests => "TAG_CLASSIFICATION_SIMILAR_INTERESTS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TAG_CLASSIFICATION_UNKNOWN" => Some(Self::Unknown),
            "TAG_CLASSIFICATION_COHOST_HISTORY" => Some(Self::CohostHistory),
            "TAG_CLASSIFICATION_FIRST_DEGREE_RELATION" => Some(Self::FirstDegreeRelation),
            "TAG_CLASSIFICATION_SECOND_DEGREE_RELATION" => {
                Some(Self::SecondDegreeRelation)
            }
            "TAG_CLASSIFICATION_RANK" => Some(Self::Rank),
            "TAG_CLASSIFICATION_SIMILAR_INTERESTS" => Some(Self::SimilarInterests),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SourceType {
    Unknown = 0,
    FriendList = 1,
    RecommendList = 2,
    Recent = 3,
    OtherFollow = 4,
    QuickPair = 5,
    Activity = 6,
    QuickRecommend = 7,
    OfficialChannel = 8,
    BestTeammate = 9,
    Reservation = 10,
    Pairing = 11,
    PairingOnReservation = 12,
    TopicQuickPair = 13,
    TopicQuickRecommend = 14,
    OnlineFriendCapsule = 15,
    WeeklyRank = 20,
    HourlyRank = 21,
    WeeklyRising = 23,
    WeeklyRookie = 24,
    ConnectionList = 25,
    DailyRank = 26,
    DailyRankHallOfFame = 27,
    ReservationBubble = 28,
    PairingBubble = 29,
    LeaguePhaseOne = 30,
    LeaguePhaseTwo = 31,
    LeaguePhaseThree = 32,
    DailyRookie = 33,
    MayKnowList = 34,
    Banner = 35,
    FansTeamRank = 36,
    Search = 37,
    EOyRankList = 38,
    LeagueCampaignRank = 39,
    CreatorClassRank = 40,
    History = 41,
    QuickRecommendDuringCohost = 43,
}
impl SourceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SourceType::Unknown => "SOURCE_TYPE_UNKNOWN",
            SourceType::FriendList => "SOURCE_TYPE_FRIEND_LIST",
            SourceType::RecommendList => "SOURCE_TYPE_RECOMMEND_LIST",
            SourceType::Recent => "SOURCE_TYPE_RECENT",
            SourceType::OtherFollow => "SOURCE_TYPE_OTHER_FOLLOW",
            SourceType::QuickPair => "SOURCE_TYPE_QUICK_PAIR",
            SourceType::Activity => "SOURCE_TYPE_ACTIVITY",
            SourceType::QuickRecommend => "SOURCE_TYPE_QUICK_RECOMMEND",
            SourceType::OfficialChannel => "SOURCE_TYPE_OFFICIAL_CHANNEL",
            SourceType::BestTeammate => "SOURCE_TYPE_BEST_TEAMMATE",
            SourceType::Reservation => "SOURCE_TYPE_RESERVATION",
            SourceType::Pairing => "SOURCE_TYPE_PAIRING",
            SourceType::PairingOnReservation => "SOURCE_TYPE_PAIRING_ON_RESERVATION",
            SourceType::TopicQuickPair => "SOURCE_TYPE_TOPIC_QUICK_PAIR",
            SourceType::TopicQuickRecommend => "SOURCE_TYPE_TOPIC_QUICK_RECOMMEND",
            SourceType::OnlineFriendCapsule => "SOURCE_TYPE_ONLINE_FRIEND_CAPSULE",
            SourceType::WeeklyRank => "SOURCE_TYPE_WEEKLY_RANK",
            SourceType::HourlyRank => "SOURCE_TYPE_HOURLY_RANK",
            SourceType::WeeklyRising => "SOURCE_TYPE_WEEKLY_RISING",
            SourceType::WeeklyRookie => "SOURCE_TYPE_WEEKLY_ROOKIE",
            SourceType::ConnectionList => "SOURCE_TYPE_CONNECTION_LIST",
            SourceType::DailyRank => "SOURCE_TYPE_DAILY_RANK",
            SourceType::DailyRankHallOfFame => "SOURCE_TYPE_DAILY_RANK_HALL_OF_FAME",
            SourceType::ReservationBubble => "SOURCE_TYPE_RESERVATION_BUBBLE",
            SourceType::PairingBubble => "SOURCE_TYPE_PAIRING_BUBBLE",
            SourceType::LeaguePhaseOne => "SOURCE_TYPE_LEAGUE_PHASE_ONE",
            SourceType::LeaguePhaseTwo => "SOURCE_TYPE_LEAGUE_PHASE_TWO",
            SourceType::LeaguePhaseThree => "SOURCE_TYPE_LEAGUE_PHASE_THREE",
            SourceType::DailyRookie => "SOURCE_TYPE_DAILY_ROOKIE",
            SourceType::MayKnowList => "SOURCE_TYPE_MAY_KNOW_LIST",
            SourceType::Banner => "SOURCE_TYPE_BANNER",
            SourceType::FansTeamRank => "SOURCE_TYPE_FANS_TEAM_RANK",
            SourceType::Search => "SOURCE_TYPE_SEARCH",
            SourceType::EOyRankList => "SOURCE_TYPE_E_OY_RANK_LIST",
            SourceType::LeagueCampaignRank => "SOURCE_TYPE_LEAGUE_CAMPAIGN_RANK",
            SourceType::CreatorClassRank => "SOURCE_TYPE_CREATOR_CLASS_RANK",
            SourceType::History => "SOURCE_TYPE_HISTORY",
            SourceType::QuickRecommendDuringCohost => {
                "SOURCE_TYPE_QUICK_RECOMMEND_DURING_COHOST"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SOURCE_TYPE_UNKNOWN" => Some(Self::Unknown),
            "SOURCE_TYPE_FRIEND_LIST" => Some(Self::FriendList),
            "SOURCE_TYPE_RECOMMEND_LIST" => Some(Self::RecommendList),
            "SOURCE_TYPE_RECENT" => Some(Self::Recent),
            "SOURCE_TYPE_OTHER_FOLLOW" => Some(Self::OtherFollow),
            "SOURCE_TYPE_QUICK_PAIR" => Some(Self::QuickPair),
            "SOURCE_TYPE_ACTIVITY" => Some(Self::Activity),
            "SOURCE_TYPE_QUICK_RECOMMEND" => Some(Self::QuickRecommend),
            "SOURCE_TYPE_OFFICIAL_CHANNEL" => Some(Self::OfficialChannel),
            "SOURCE_TYPE_BEST_TEAMMATE" => Some(Self::BestTeammate),
            "SOURCE_TYPE_RESERVATION" => Some(Self::Reservation),
            "SOURCE_TYPE_PAIRING" => Some(Self::Pairing),
            "SOURCE_TYPE_PAIRING_ON_RESERVATION" => Some(Self::PairingOnReservation),
            "SOURCE_TYPE_TOPIC_QUICK_PAIR" => Some(Self::TopicQuickPair),
            "SOURCE_TYPE_TOPIC_QUICK_RECOMMEND" => Some(Self::TopicQuickRecommend),
            "SOURCE_TYPE_ONLINE_FRIEND_CAPSULE" => Some(Self::OnlineFriendCapsule),
            "SOURCE_TYPE_WEEKLY_RANK" => Some(Self::WeeklyRank),
            "SOURCE_TYPE_HOURLY_RANK" => Some(Self::HourlyRank),
            "SOURCE_TYPE_WEEKLY_RISING" => Some(Self::WeeklyRising),
            "SOURCE_TYPE_WEEKLY_ROOKIE" => Some(Self::WeeklyRookie),
            "SOURCE_TYPE_CONNECTION_LIST" => Some(Self::ConnectionList),
            "SOURCE_TYPE_DAILY_RANK" => Some(Self::DailyRank),
            "SOURCE_TYPE_DAILY_RANK_HALL_OF_FAME" => Some(Self::DailyRankHallOfFame),
            "SOURCE_TYPE_RESERVATION_BUBBLE" => Some(Self::ReservationBubble),
            "SOURCE_TYPE_PAIRING_BUBBLE" => Some(Self::PairingBubble),
            "SOURCE_TYPE_LEAGUE_PHASE_ONE" => Some(Self::LeaguePhaseOne),
            "SOURCE_TYPE_LEAGUE_PHASE_TWO" => Some(Self::LeaguePhaseTwo),
            "SOURCE_TYPE_LEAGUE_PHASE_THREE" => Some(Self::LeaguePhaseThree),
            "SOURCE_TYPE_DAILY_ROOKIE" => Some(Self::DailyRookie),
            "SOURCE_TYPE_MAY_KNOW_LIST" => Some(Self::MayKnowList),
            "SOURCE_TYPE_BANNER" => Some(Self::Banner),
            "SOURCE_TYPE_FANS_TEAM_RANK" => Some(Self::FansTeamRank),
            "SOURCE_TYPE_SEARCH" => Some(Self::Search),
            "SOURCE_TYPE_E_OY_RANK_LIST" => Some(Self::EOyRankList),
            "SOURCE_TYPE_LEAGUE_CAMPAIGN_RANK" => Some(Self::LeagueCampaignRank),
            "SOURCE_TYPE_CREATOR_CLASS_RANK" => Some(Self::CreatorClassRank),
            "SOURCE_TYPE_HISTORY" => Some(Self::History),
            "SOURCE_TYPE_QUICK_RECOMMEND_DURING_COHOST" => {
                Some(Self::QuickRecommendDuringCohost)
            }
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BattleType {
    UnknownBattleType = 0,
    NormalBattle = 1,
    TeamBattle = 2,
    IndividualBattle = 3,
    BattleType1VN = 4,
    TakeTheStage = 51,
    GroupShow = 52,
}
impl BattleType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            BattleType::UnknownBattleType => "BATTLE_TYPE_UNKNOWN_BATTLE_TYPE",
            BattleType::NormalBattle => "BATTLE_TYPE_NORMAL_BATTLE",
            BattleType::TeamBattle => "BATTLE_TYPE_TEAM_BATTLE",
            BattleType::IndividualBattle => "BATTLE_TYPE_INDIVIDUAL_BATTLE",
            BattleType::BattleType1VN => "BATTLE_TYPE_1_V_N",
            BattleType::TakeTheStage => "BATTLE_TYPE_TAKE_THE_STAGE",
            BattleType::GroupShow => "BATTLE_TYPE_GROUP_SHOW",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BATTLE_TYPE_UNKNOWN_BATTLE_TYPE" => Some(Self::UnknownBattleType),
            "BATTLE_TYPE_NORMAL_BATTLE" => Some(Self::NormalBattle),
            "BATTLE_TYPE_TEAM_BATTLE" => Some(Self::TeamBattle),
            "BATTLE_TYPE_INDIVIDUAL_BATTLE" => Some(Self::IndividualBattle),
            "BATTLE_TYPE_1_V_N" => Some(Self::BattleType1VN),
            "BATTLE_TYPE_TAKE_THE_STAGE" => Some(Self::TakeTheStage),
            "BATTLE_TYPE_GROUP_SHOW" => Some(Self::GroupShow),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BattleInviteType {
    Normal = 0,
    Again = 1,
}
impl BattleInviteType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            BattleInviteType::Normal => "BATTLE_INVITE_TYPE_NORMAL",
            BattleInviteType::Again => "BATTLE_INVITE_TYPE_AGAIN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BATTLE_INVITE_TYPE_NORMAL" => Some(Self::Normal),
            "BATTLE_INVITE_TYPE_AGAIN" => Some(Self::Again),
            _ => None,
        }
    }
}
/// @Common
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommonMessageData {
    #[prost(string, tag = "1")]
    pub method: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub msg_id: i64,
    #[prost(int64, tag = "3")]
    pub room_id: i64,
    #[prost(int64, tag = "4")]
    pub create_time: i64,
    #[prost(int32, tag = "5")]
    pub monitor: i32,
    #[prost(bool, tag = "6")]
    pub is_show_msg: bool,
    #[prost(string, tag = "7")]
    pub describe: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "8")]
    pub display_text: ::core::option::Option<Text>,
    #[prost(int64, tag = "9")]
    pub fold_type: i64,
    #[prost(int64, tag = "10")]
    pub anchor_fold_type: i64,
    #[prost(int64, tag = "11")]
    pub priority_score: i64,
    #[prost(string, tag = "12")]
    pub log_id: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub msg_process_filter_k: ::prost::alloc::string::String,
    #[prost(string, tag = "14")]
    pub msg_process_filter_v: ::prost::alloc::string::String,
    #[prost(string, tag = "15")]
    pub from_idc: ::prost::alloc::string::String,
    #[prost(string, tag = "16")]
    pub to_idc: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "17")]
    pub filter_msg_tags_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "18")]
    pub sei: ::core::option::Option<common_message_data::LiveMessageSei>,
    #[prost(message, optional, tag = "19")]
    pub depend_root_id: ::core::option::Option<common_message_data::LiveMessageId>,
    #[prost(message, optional, tag = "20")]
    pub depend_id: ::core::option::Option<common_message_data::LiveMessageId>,
    #[prost(int64, tag = "21")]
    pub anchor_priority_score: i64,
    #[prost(int64, tag = "22")]
    pub room_message_heat_level: i64,
    #[prost(int64, tag = "23")]
    pub fold_type_for_web: i64,
    #[prost(int64, tag = "24")]
    pub anchor_fold_type_for_web: i64,
    #[prost(int64, tag = "25")]
    pub client_send_time: i64,
    /// Enum
    #[prost(enumeration = "common_message_data::ImDispatchStrategy", tag = "26")]
    pub dispatch_strategy: i32,
}
/// Nested message and enum types in `CommonMessageData`.
pub mod common_message_data {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LiveMessageSei {
        #[prost(message, optional, tag = "1")]
        pub unique_id: ::core::option::Option<LiveMessageId>,
        #[prost(int64, tag = "2")]
        pub timestamp: i64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LiveMessageId {
        #[prost(string, tag = "1")]
        pub primary_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub message_scene: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ImDispatchStrategy {
        Default = 0,
        BypassDispatchQueue = 1,
    }
    impl ImDispatchStrategy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ImDispatchStrategy::Default => "IM_DISPATCH_STRATEGY_DEFAULT",
                ImDispatchStrategy::BypassDispatchQueue => {
                    "IM_DISPATCH_STRATEGY_BYPASS_DISPATCH_QUEUE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "IM_DISPATCH_STRATEGY_DEFAULT" => Some(Self::Default),
                "IM_DISPATCH_STRATEGY_BYPASS_DISPATCH_QUEUE" => {
                    Some(Self::BypassDispatchQueue)
                }
                _ => None,
            }
        }
    }
}
/// @Text
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Text {
    #[prost(string, tag = "1")]
    pub display_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub default_pattern: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub default_format: ::core::option::Option<text::TextFormat>,
    #[prost(message, repeated, tag = "4")]
    pub pieces_list: ::prost::alloc::vec::Vec<text::TextPiece>,
}
/// Nested message and enum types in `Text`.
pub mod text {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TextPiece {
        #[prost(int32, tag = "1")]
        pub r#type: i32,
        #[prost(message, optional, tag = "2")]
        pub format: ::core::option::Option<TextFormat>,
        #[prost(string, tag = "11")]
        pub string_value: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "24")]
        pub pattern_ref_value: ::core::option::Option<TextPiecePatternRef>,
        #[prost(oneof = "text_piece::TextPieceType", tags = "21, 22")]
        pub text_piece_type: ::core::option::Option<text_piece::TextPieceType>,
    }
    /// Nested message and enum types in `TextPiece`.
    pub mod text_piece {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum TextPieceType {
            #[prost(message, tag = "21")]
            UserValue(super::TextPieceUser),
            #[prost(message, tag = "22")]
            GiftValue(super::TextPieceGift),
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TextFormat {
        #[prost(string, tag = "1")]
        pub color: ::prost::alloc::string::String,
        #[prost(bool, tag = "2")]
        pub bold: bool,
        #[prost(bool, tag = "3")]
        pub italic: bool,
        #[prost(int32, tag = "4")]
        pub weight: i32,
        #[prost(int32, tag = "5")]
        pub italic_angle: i32,
        #[prost(int32, tag = "6")]
        pub font_size: i32,
        #[prost(bool, tag = "7")]
        pub use_heigh_light_color: bool,
        #[prost(bool, tag = "8")]
        pub use_remote_clor: bool,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TextPieceGift {
        #[prost(int32, tag = "1")]
        pub gift_id: i32,
        #[prost(message, optional, tag = "2")]
        pub name_ref: ::core::option::Option<PatternRef>,
        /// Enum
        #[prost(enumeration = "ShowType", tag = "3")]
        pub show_type: i32,
        #[prost(int64, tag = "4")]
        pub color_id: i64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TextPiecePatternRef {
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub default_pattern: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TextPieceUser {
        #[prost(message, optional, tag = "1")]
        pub user: ::core::option::Option<super::User>,
        #[prost(bool, tag = "2")]
        pub with_colon: bool,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PatternRef {
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub default_pattern: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ShowType {
        Normal = 0,
        FadeInOut = 1,
    }
    impl ShowType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ShowType::Normal => "SHOW_TYPE_NORMAL",
                ShowType::FadeInOut => "SHOW_TYPE_FADE_IN_OUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SHOW_TYPE_NORMAL" => Some(Self::Normal),
                "SHOW_TYPE_FADE_IN_OUT" => Some(Self::FadeInOut),
                _ => None,
            }
        }
    }
}
/// @Image
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Image {
    #[prost(string, repeated, tag = "1")]
    pub url: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub m_uri: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub height: i32,
    #[prost(int32, tag = "4")]
    pub width: i32,
    #[prost(string, tag = "5")]
    pub avg_color: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub image_type: i32,
    #[prost(string, tag = "7")]
    pub schema: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "8")]
    pub content: ::core::option::Option<image::Content>,
    #[prost(bool, tag = "9")]
    pub is_animated: bool,
}
/// Nested message and enum types in `Image`.
pub mod image {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Content {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub font_color: ::prost::alloc::string::String,
        #[prost(int64, tag = "3")]
        pub level: i64,
    }
}
/// @Badge
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BadgeStruct {
    /// Enum
    #[prost(enumeration = "badge_struct::BadgeDisplayType", tag = "1")]
    pub badge_display_type: i32,
    #[prost(enumeration = "badge_struct::BadgePriorityType", tag = "2")]
    pub badge_priority_type: i32,
    #[prost(enumeration = "badge_struct::BadgeSceneType", tag = "3")]
    pub badge_scene: i32,
    #[prost(enumeration = "badge_struct::Position", tag = "4")]
    pub position: i32,
    #[prost(enumeration = "badge_struct::DisplayStatus", tag = "5")]
    pub display_status: i32,
    #[prost(int64, tag = "6")]
    pub greyed_by_client: i64,
    #[prost(enumeration = "badge_struct::BadgeExhibitionType", tag = "7")]
    pub exhibition_type: i32,
    #[prost(string, tag = "10")]
    pub schema_url: ::prost::alloc::string::String,
    #[prost(bool, tag = "11")]
    pub display: bool,
    #[prost(message, optional, tag = "12")]
    pub log_extra: ::core::option::Option<PrivilegeLogExtra>,
    #[prost(bool, tag = "24")]
    pub is_customized: bool,
    #[prost(oneof = "badge_struct::BadgeType", tags = "20, 21, 22, 23")]
    pub badge_type: ::core::option::Option<badge_struct::BadgeType>,
}
/// Nested message and enum types in `BadgeStruct`.
pub mod badge_struct {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CombineBadge {
        #[prost(int32, tag = "1")]
        pub badge_display_type: i32,
        #[prost(message, optional, tag = "2")]
        pub icon: ::core::option::Option<super::Image>,
        #[prost(message, optional, tag = "3")]
        pub text: ::core::option::Option<TextBadge>,
        #[prost(string, tag = "4")]
        pub str: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "5")]
        pub padding: ::core::option::Option<PaddingInfo>,
        #[prost(message, optional, tag = "6")]
        pub font_style: ::core::option::Option<super::FontStyle>,
        #[prost(message, optional, tag = "7")]
        pub profile_card_panel: ::core::option::Option<ProfileCardPanel>,
        #[prost(message, optional, tag = "11")]
        pub background: ::core::option::Option<CombineBadgeBackground>,
        #[prost(message, optional, tag = "12")]
        pub background_dark_mode: ::core::option::Option<CombineBadgeBackground>,
        #[prost(bool, tag = "13")]
        pub icon_auto_mirrored: bool,
        #[prost(bool, tag = "14")]
        pub bg_auto_mirrored: bool,
        #[prost(int32, tag = "15")]
        pub public_screen_show_style: i32,
        #[prost(int32, tag = "16")]
        pub personal_card_show_style: i32,
        #[prost(int32, tag = "17")]
        pub rank_list_online_audience_show_style: i32,
        #[prost(int32, tag = "18")]
        pub multi_guest_show_style: i32,
        #[prost(message, optional, tag = "19")]
        pub arrow_config: ::core::option::Option<ArrowConfig>,
        #[prost(message, optional, tag = "20")]
        pub padding_new_font: ::core::option::Option<PaddingInfo>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ArrowConfig {
        #[prost(message, optional, tag = "1")]
        pub icon: ::core::option::Option<super::Image>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ProfileContent {
        #[prost(bool, tag = "1")]
        pub use_content: bool,
        #[prost(message, repeated, tag = "2")]
        pub icon_list: ::prost::alloc::vec::Vec<IconConfig>,
        #[prost(message, optional, tag = "3")]
        pub number_config: ::core::option::Option<NumberConfig>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ProjectionConfig {
        #[prost(bool, tag = "1")]
        pub use_projection: bool,
        #[prost(message, optional, tag = "2")]
        pub icon: ::core::option::Option<super::Image>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NumberConfig {
        #[prost(int64, tag = "1")]
        pub number: i64,
        #[prost(message, optional, tag = "2")]
        pub font_style: ::core::option::Option<super::FontStyle>,
        #[prost(message, optional, tag = "3")]
        pub background: ::core::option::Option<CombineBadgeBackground>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ProfileCardPanel {
        #[prost(bool, tag = "1")]
        pub use_new_profile_card_style: bool,
        ///   BadgeTextPosition badgeTextPosition = 2; // Enum
        #[prost(message, optional, tag = "3")]
        pub projection_config: ::core::option::Option<ProjectionConfig>,
        #[prost(message, optional, tag = "4")]
        pub profile_content: ::core::option::Option<ProfileContent>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CombineBadgeBackground {
        #[prost(message, optional, tag = "1")]
        pub image: ::core::option::Option<super::Image>,
        #[prost(string, tag = "2")]
        pub background_color_code: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub border_color_code: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ImageBadge {
        #[prost(enumeration = "BadgeDisplayType", tag = "1")]
        pub badge_display_type: i32,
        #[prost(message, optional, tag = "2")]
        pub image: ::core::option::Option<super::Image>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TextBadge {
        #[prost(enumeration = "BadgeDisplayType", tag = "1")]
        pub badge_display_type: i32,
        #[prost(string, tag = "2")]
        pub key: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub default_pattern: ::prost::alloc::string::String,
        #[prost(string, repeated, tag = "4")]
        pub pieces: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IconConfig {
        #[prost(message, optional, tag = "1")]
        pub icon: ::core::option::Option<super::Image>,
        #[prost(message, optional, tag = "2")]
        pub background: ::core::option::Option<CombineBadgeBackground>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StringBadge {
        #[prost(enumeration = "BadgeDisplayType", tag = "1")]
        pub badge_display_type: i32,
        #[prost(string, tag = "2")]
        pub str: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PaddingInfo {
        #[prost(bool, tag = "1")]
        pub use_specific: bool,
        #[prost(int32, tag = "2")]
        pub middle_padding: i32,
        #[prost(int32, tag = "3")]
        pub badge_width: i32,
        #[prost(int32, tag = "4")]
        pub left_padding: i32,
        #[prost(int32, tag = "5")]
        pub right_padding: i32,
        #[prost(int32, tag = "6")]
        pub icon_top_padding: i32,
        #[prost(int32, tag = "7")]
        pub icon_bottom_padding: i32,
        #[prost(enumeration = "HorizontalPaddingRule", tag = "8")]
        pub horizontal_padding_rule: i32,
        #[prost(enumeration = "VerticalPaddingRule", tag = "9")]
        pub vertical_padding_rule: i32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BadgeDisplayType {
        BadgedisplaytypeUnknown = 0,
        BadgedisplaytypeImage = 1,
        BadgedisplaytypeText = 2,
        BadgedisplaytypeString = 3,
        BadgedisplaytypeCombine = 4,
    }
    impl BadgeDisplayType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BadgeDisplayType::BadgedisplaytypeUnknown => "BADGEDISPLAYTYPE_UNKNOWN",
                BadgeDisplayType::BadgedisplaytypeImage => "BADGEDISPLAYTYPE_IMAGE",
                BadgeDisplayType::BadgedisplaytypeText => "BADGEDISPLAYTYPE_TEXT",
                BadgeDisplayType::BadgedisplaytypeString => "BADGEDISPLAYTYPE_STRING",
                BadgeDisplayType::BadgedisplaytypeCombine => "BADGEDISPLAYTYPE_COMBINE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BADGEDISPLAYTYPE_UNKNOWN" => Some(Self::BadgedisplaytypeUnknown),
                "BADGEDISPLAYTYPE_IMAGE" => Some(Self::BadgedisplaytypeImage),
                "BADGEDISPLAYTYPE_TEXT" => Some(Self::BadgedisplaytypeText),
                "BADGEDISPLAYTYPE_STRING" => Some(Self::BadgedisplaytypeString),
                "BADGEDISPLAYTYPE_COMBINE" => Some(Self::BadgedisplaytypeCombine),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BadgePriorityType {
        Unknown = 0,
        StrongRelation = 10,
        Platform = 20,
        Relation = 30,
        Activity = 40,
        RankList = 50,
    }
    impl BadgePriorityType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BadgePriorityType::Unknown => "BADGE_PRIORITY_TYPE_UNKNOWN",
                BadgePriorityType::StrongRelation => {
                    "BADGE_PRIORITY_TYPE_STRONG_RELATION"
                }
                BadgePriorityType::Platform => "BADGE_PRIORITY_TYPE_PLATFORM",
                BadgePriorityType::Relation => "BADGE_PRIORITY_TYPE_RELATION",
                BadgePriorityType::Activity => "BADGE_PRIORITY_TYPE_ACTIVITY",
                BadgePriorityType::RankList => "BADGE_PRIORITY_TYPE_RANK_LIST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BADGE_PRIORITY_TYPE_UNKNOWN" => Some(Self::Unknown),
                "BADGE_PRIORITY_TYPE_STRONG_RELATION" => Some(Self::StrongRelation),
                "BADGE_PRIORITY_TYPE_PLATFORM" => Some(Self::Platform),
                "BADGE_PRIORITY_TYPE_RELATION" => Some(Self::Relation),
                "BADGE_PRIORITY_TYPE_ACTIVITY" => Some(Self::Activity),
                "BADGE_PRIORITY_TYPE_RANK_LIST" => Some(Self::RankList),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BadgeSceneType {
        Unknown = 0,
        Admin = 1,
        FirstRecharge = 2,
        Friends = 3,
        Subscriber = 4,
        Activity = 5,
        RankList = 6,
        NewSubscriber = 7,
        UserGrade = 8,
        StateControlledMedia = 9,
        Fans = 10,
        LivePro = 11,
        Anchor = 12,
    }
    impl BadgeSceneType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BadgeSceneType::Unknown => "BADGE_SCENE_TYPE_UNKNOWN",
                BadgeSceneType::Admin => "BADGE_SCENE_TYPE_ADMIN",
                BadgeSceneType::FirstRecharge => "BADGE_SCENE_TYPE_FIRST_RECHARGE",
                BadgeSceneType::Friends => "BADGE_SCENE_TYPE_FRIENDS",
                BadgeSceneType::Subscriber => "BADGE_SCENE_TYPE_SUBSCRIBER",
                BadgeSceneType::Activity => "BADGE_SCENE_TYPE_ACTIVITY",
                BadgeSceneType::RankList => "BADGE_SCENE_TYPE_RANK_LIST",
                BadgeSceneType::NewSubscriber => "BADGE_SCENE_TYPE_NEW_SUBSCRIBER",
                BadgeSceneType::UserGrade => "BADGE_SCENE_TYPE_USER_GRADE",
                BadgeSceneType::StateControlledMedia => {
                    "BADGE_SCENE_TYPE_STATE_CONTROLLED_MEDIA"
                }
                BadgeSceneType::Fans => "BADGE_SCENE_TYPE_FANS",
                BadgeSceneType::LivePro => "BADGE_SCENE_TYPE_LIVE_PRO",
                BadgeSceneType::Anchor => "BADGE_SCENE_TYPE_ANCHOR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BADGE_SCENE_TYPE_UNKNOWN" => Some(Self::Unknown),
                "BADGE_SCENE_TYPE_ADMIN" => Some(Self::Admin),
                "BADGE_SCENE_TYPE_FIRST_RECHARGE" => Some(Self::FirstRecharge),
                "BADGE_SCENE_TYPE_FRIENDS" => Some(Self::Friends),
                "BADGE_SCENE_TYPE_SUBSCRIBER" => Some(Self::Subscriber),
                "BADGE_SCENE_TYPE_ACTIVITY" => Some(Self::Activity),
                "BADGE_SCENE_TYPE_RANK_LIST" => Some(Self::RankList),
                "BADGE_SCENE_TYPE_NEW_SUBSCRIBER" => Some(Self::NewSubscriber),
                "BADGE_SCENE_TYPE_USER_GRADE" => Some(Self::UserGrade),
                "BADGE_SCENE_TYPE_STATE_CONTROLLED_MEDIA" => {
                    Some(Self::StateControlledMedia)
                }
                "BADGE_SCENE_TYPE_FANS" => Some(Self::Fans),
                "BADGE_SCENE_TYPE_LIVE_PRO" => Some(Self::LivePro),
                "BADGE_SCENE_TYPE_ANCHOR" => Some(Self::Anchor),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DisplayStatus {
        Normal = 0,
        Shadow = 1,
    }
    impl DisplayStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DisplayStatus::Normal => "DISPLAY_STATUS_NORMAL",
                DisplayStatus::Shadow => "DISPLAY_STATUS_SHADOW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DISPLAY_STATUS_NORMAL" => Some(Self::Normal),
                "DISPLAY_STATUS_SHADOW" => Some(Self::Shadow),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BadgeExhibitionType {
        Badge = 0,
        IdentityLabel = 1,
    }
    impl BadgeExhibitionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BadgeExhibitionType::Badge => "BADGE_EXHIBITION_TYPE_BADGE",
                BadgeExhibitionType::IdentityLabel => {
                    "BADGE_EXHIBITION_TYPE_IDENTITY_LABEL"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BADGE_EXHIBITION_TYPE_BADGE" => Some(Self::Badge),
                "BADGE_EXHIBITION_TYPE_IDENTITY_LABEL" => Some(Self::IdentityLabel),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Position {
        Positionunknown = 0,
        Positionleft = 1,
        Positionright = 2,
    }
    impl Position {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Position::Positionunknown => "POSITIONUNKNOWN",
                Position::Positionleft => "POSITIONLEFT",
                Position::Positionright => "POSITIONRIGHT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "POSITIONUNKNOWN" => Some(Self::Positionunknown),
                "POSITIONLEFT" => Some(Self::Positionleft),
                "POSITIONRIGHT" => Some(Self::Positionright),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HorizontalPaddingRule {
        UseMiddleAndWidth = 0,
        UseLeftAndMiddleAndRight = 1,
    }
    impl HorizontalPaddingRule {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                HorizontalPaddingRule::UseMiddleAndWidth => {
                    "HORIZONTAL_PADDING_RULE_USE_MIDDLE_AND_WIDTH"
                }
                HorizontalPaddingRule::UseLeftAndMiddleAndRight => {
                    "HORIZONTAL_PADDING_RULE_USE_LEFT_AND_MIDDLE_AND_RIGHT"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "HORIZONTAL_PADDING_RULE_USE_MIDDLE_AND_WIDTH" => {
                    Some(Self::UseMiddleAndWidth)
                }
                "HORIZONTAL_PADDING_RULE_USE_LEFT_AND_MIDDLE_AND_RIGHT" => {
                    Some(Self::UseLeftAndMiddleAndRight)
                }
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum VerticalPaddingRule {
        UseDefault = 0,
        UseTopAndBottom = 1,
    }
    impl VerticalPaddingRule {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                VerticalPaddingRule::UseDefault => "VERTICAL_PADDING_RULE_USE_DEFAULT",
                VerticalPaddingRule::UseTopAndBottom => {
                    "VERTICAL_PADDING_RULE_USE_TOP_AND_BOTTOM"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VERTICAL_PADDING_RULE_USE_DEFAULT" => Some(Self::UseDefault),
                "VERTICAL_PADDING_RULE_USE_TOP_AND_BOTTOM" => Some(Self::UseTopAndBottom),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum BadgeType {
        #[prost(message, tag = "20")]
        Image(ImageBadge),
        #[prost(message, tag = "21")]
        Text(TextBadge),
        #[prost(message, tag = "22")]
        Str(StringBadge),
        #[prost(message, tag = "23")]
        Combine(CombineBadge),
    }
}
/// @Gift
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Gift {
    #[prost(message, optional, tag = "1")]
    pub gift_image: ::core::option::Option<Image>,
    #[prost(string, tag = "2")]
    pub describe: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub duration: i32,
    #[prost(int64, tag = "5")]
    pub id: i64,
    #[prost(bool, tag = "7")]
    pub for_link_mic: bool,
    #[prost(bool, tag = "10")]
    pub combo: bool,
    #[prost(int32, tag = "11")]
    pub gift_type: i32,
    #[prost(int32, tag = "12")]
    pub diamond_count: i32,
    #[prost(bool, tag = "13")]
    pub is_displayed_on_panel: bool,
    #[prost(int64, tag = "14")]
    pub primary_effect_id: i64,
    #[prost(message, optional, tag = "15")]
    pub gift_label_icon: ::core::option::Option<Image>,
    #[prost(string, tag = "16")]
    pub gift_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "21")]
    pub icon: ::core::option::Option<Image>,
    #[prost(string, tag = "24")]
    pub gold_effect: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "47")]
    pub preview_image: ::core::option::Option<Image>,
    #[prost(message, optional, tag = "48")]
    pub gift_panel_banner: ::core::option::Option<gift::GiftPanelBanner>,
    #[prost(bool, tag = "49")]
    pub is_broadcast_gift: bool,
    #[prost(bool, tag = "50")]
    pub is_effect_befview: bool,
    #[prost(bool, tag = "51")]
    pub is_random_gift: bool,
    #[prost(bool, tag = "52")]
    pub is_box_gift: bool,
    #[prost(bool, tag = "53")]
    pub can_put_in_gift_box: bool,
    #[prost(message, optional, tag = "54")]
    pub gift_box_info: ::core::option::Option<gift::GiftBoxInfo>,
}
/// Nested message and enum types in `Gift`.
pub mod gift {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GiftPanelBanner {
        #[prost(message, optional, tag = "1")]
        pub display_text: ::core::option::Option<super::Text>,
        #[prost(message, optional, tag = "2")]
        pub left_icon: ::core::option::Option<super::Image>,
        #[prost(string, tag = "3")]
        pub schema_url: ::prost::alloc::string::String,
        #[prost(string, repeated, tag = "5")]
        pub bg_colors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, tag = "6")]
        pub banner_lynx_url: ::prost::alloc::string::String,
        #[prost(int32, tag = "7")]
        pub banner_priority: i32,
        #[prost(string, tag = "8")]
        pub banner_lynx_extra: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "9")]
        pub bg_image: ::core::option::Option<super::Image>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BatchGiftInfo {
        #[prost(bool, tag = "1")]
        pub can_batch_send: bool,
        #[prost(int64, repeated, tag = "2")]
        pub available_counts: ::prost::alloc::vec::Vec<i64>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CrossScreenEffectInfo {
        #[prost(map = "int64, int32", tag = "1")]
        pub single_action_effect_ids: ::std::collections::HashMap<i64, i32>,
        #[prost(map = "int64, int32", tag = "2")]
        pub action_effect_ids: ::std::collections::HashMap<i64, i32>,
        #[prost(map = "int64, int32", tag = "3")]
        pub reaction_effect_ids: ::std::collections::HashMap<i64, i32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GiftSponsorInfo {
        #[prost(int64, tag = "1")]
        pub sponsor_id: i64,
        #[prost(int64, tag = "2")]
        pub sponsor_count: i64,
        #[prost(int64, tag = "3")]
        pub current_count: i64,
        #[prost(int64, tag = "4")]
        pub left_count_to_sponsor: i64,
        #[prost(bool, tag = "5")]
        pub can_sponsor: bool,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UgGiftStructInfo {
        #[prost(bool, tag = "1")]
        pub is_ug_gift: bool,
        #[prost(int64, tag = "2")]
        pub ug_points_cost: i64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GiftSkin {
        #[prost(int64, tag = "1")]
        pub gift_skin_id: i64,
        #[prost(string, tag = "2")]
        pub gift_skin_name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub static_image: ::core::option::Option<super::Image>,
        #[prost(message, optional, tag = "4")]
        pub animated_image: ::core::option::Option<super::Image>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GiftText {
        #[prost(int64, tag = "1")]
        pub gift_text_id: i64,
        #[prost(string, tag = "2")]
        pub gift_text_name: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GiftSkinToGiftTextsInfo {
        #[prost(int64, tag = "1")]
        pub gift_skin_id: i64,
        #[prost(int64, repeated, tag = "2")]
        pub gift_text_ids: ::prost::alloc::vec::Vec<i64>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GiftBoxInfo {
        #[prost(int64, tag = "1")]
        pub capacity: i64,
        #[prost(bool, tag = "2")]
        pub is_primary_box: bool,
        #[prost(string, tag = "3")]
        pub scheme_url: ::prost::alloc::string::String,
    }
}
/// @User
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct User {
    #[prost(int64, tag = "1")]
    pub user_id: i64,
    #[prost(string, tag = "3")]
    pub nickname: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub bio_description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "9")]
    pub profile_picture: ::core::option::Option<Image>,
    #[prost(message, optional, tag = "10")]
    pub profile_picture_medium: ::core::option::Option<Image>,
    #[prost(message, optional, tag = "11")]
    pub profile_picture_large: ::core::option::Option<Image>,
    #[prost(bool, tag = "12")]
    pub verified: bool,
    #[prost(int32, tag = "15")]
    pub status: i32,
    #[prost(int64, tag = "16")]
    pub create_time: i64,
    #[prost(int64, tag = "17")]
    pub modify_time: i64,
    #[prost(int32, tag = "18")]
    pub secret: i32,
    #[prost(string, tag = "19")]
    pub share_qrcode_uri: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "21")]
    pub badge_image_list: ::prost::alloc::vec::Vec<Image>,
    #[prost(message, optional, tag = "22")]
    pub follow_info: ::core::option::Option<user::FollowInfo>,
    #[prost(message, optional, tag = "23")]
    pub user_honor: ::core::option::Option<UserHonor>,
    #[prost(message, optional, tag = "24")]
    pub fans_club: ::core::option::Option<FansClubMember>,
    #[prost(message, optional, tag = "25")]
    pub border: ::core::option::Option<BorderInfo>,
    #[prost(string, tag = "26")]
    pub special_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "27")]
    pub avatar_border: ::core::option::Option<Image>,
    #[prost(message, optional, tag = "28")]
    pub medal: ::core::option::Option<Image>,
    #[prost(message, repeated, tag = "29")]
    pub user_badges: ::prost::alloc::vec::Vec<Image>,
    #[prost(message, repeated, tag = "30")]
    pub new_user_badges: ::prost::alloc::vec::Vec<Image>,
    #[prost(int32, tag = "31")]
    pub top_vip_no: i32,
    #[prost(message, optional, tag = "32")]
    pub user_attr: ::core::option::Option<user::UserAttr>,
    #[prost(message, optional, tag = "33")]
    pub own_room: ::core::option::Option<user::OwnRoom>,
    #[prost(int64, tag = "34")]
    pub pay_score: i64,
    #[prost(int64, tag = "35")]
    pub fan_ticket_count: i64,
    #[prost(message, optional, tag = "36")]
    pub anchor_info: ::core::option::Option<user::AnchorLevel>,
    #[prost(enumeration = "LinkmicStatus", tag = "37")]
    pub link_mic_stats: i32,
    #[prost(string, tag = "38")]
    pub unique_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "39")]
    pub enable_show_commerce_sale: bool,
    #[prost(bool, tag = "40")]
    pub with_fusion_shop_entry: bool,
    #[prost(int64, tag = "41")]
    pub pay_scores: i64,
    #[prost(message, optional, tag = "42")]
    pub anchor_level: ::core::option::Option<user::AnchorLevel>,
    #[prost(string, tag = "43")]
    pub verified_content: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "44")]
    pub author_info: ::core::option::Option<Author>,
    #[prost(message, repeated, tag = "45")]
    pub top_fans: ::prost::alloc::vec::Vec<User>,
    #[prost(string, tag = "46")]
    pub sec_uid: ::prost::alloc::string::String,
    #[prost(int32, tag = "47")]
    pub user_role: i32,
    #[prost(message, optional, tag = "49")]
    pub reward_info: ::core::option::Option<user::ActivityInfo>,
    #[prost(message, optional, tag = "52")]
    pub personal_card: ::core::option::Option<Image>,
    #[prost(message, optional, tag = "53")]
    pub authentication_info: ::core::option::Option<user::AuthenticationInfo>,
    #[prost(message, repeated, tag = "57")]
    pub media_badge_image_list: ::prost::alloc::vec::Vec<Image>,
    #[prost(int64, repeated, tag = "60")]
    pub commerce_webcast_config_ids: ::prost::alloc::vec::Vec<i64>,
    #[prost(message, repeated, tag = "61")]
    pub borders: ::prost::alloc::vec::Vec<BorderInfo>,
    #[prost(message, optional, tag = "62")]
    pub combo_badge_info: ::core::option::Option<user::ComboBadgeInfo>,
    #[prost(message, optional, tag = "63")]
    pub subscribe_info: ::core::option::Option<user::SubscribeInfo>,
    #[prost(message, repeated, tag = "64")]
    pub badges: ::prost::alloc::vec::Vec<BadgeStruct>,
    #[prost(int64, repeated, tag = "65")]
    pub mint_type_label: ::prost::alloc::vec::Vec<i64>,
    #[prost(message, optional, tag = "66")]
    pub fans_club_info: ::core::option::Option<user::FansClubInfo>,
    #[prost(bool, tag = "1002")]
    pub allow_find_by_contacts: bool,
    #[prost(bool, tag = "1003")]
    pub allow_others_download_video: bool,
    #[prost(bool, tag = "1004")]
    pub allow_others_download_when_sharing_video: bool,
    #[prost(bool, tag = "1005")]
    pub allow_share_show_profile: bool,
    #[prost(bool, tag = "1006")]
    pub allow_show_in_gossip: bool,
    #[prost(bool, tag = "1007")]
    pub allow_show_my_action: bool,
    #[prost(bool, tag = "1008")]
    pub allow_strange_comment: bool,
    #[prost(bool, tag = "1009")]
    pub allow_unfollower_comment: bool,
    #[prost(bool, tag = "1010")]
    pub allow_use_linkmic: bool,
    #[prost(message, optional, tag = "1012")]
    pub avatar_jpg: ::core::option::Option<Image>,
    #[prost(string, tag = "1013")]
    pub background_img_url: ::prost::alloc::string::String,
    #[prost(int32, tag = "1016")]
    pub block_status: i32,
    #[prost(int32, tag = "1017")]
    pub comment_restrict: i32,
    #[prost(string, tag = "1018")]
    pub constellation: ::prost::alloc::string::String,
    #[prost(int32, tag = "1019")]
    pub disable_ichat: i32,
    #[prost(int64, tag = "1020")]
    pub enable_ichat_img: i64,
    #[prost(int32, tag = "1021")]
    pub exp: i32,
    #[prost(bool, tag = "1023")]
    pub fold_stranger_chat: bool,
    #[prost(int64, tag = "1024")]
    pub follow_status: i64,
    #[prost(int32, tag = "1027")]
    pub ichat_restrict_type: i32,
    #[prost(string, tag = "1028")]
    pub id_str: ::prost::alloc::string::String,
    #[prost(bool, tag = "1029")]
    pub is_follower: bool,
    #[prost(bool, tag = "1030")]
    pub is_following: bool,
    #[prost(bool, tag = "1031")]
    pub need_profile_guide: bool,
    #[prost(bool, tag = "1033")]
    pub push_comment_status: bool,
    #[prost(bool, tag = "1034")]
    pub push_digg: bool,
    #[prost(bool, tag = "1035")]
    pub push_follow: bool,
    #[prost(bool, tag = "1036")]
    pub push_friend_action: bool,
    #[prost(bool, tag = "1037")]
    pub push_ichat: bool,
    #[prost(bool, tag = "1038")]
    pub push_status: bool,
    #[prost(bool, tag = "1039")]
    pub push_video_post: bool,
    #[prost(bool, tag = "1040")]
    pub push_video_recommend: bool,
    #[prost(string, tag = "1043")]
    pub verified_reason: ::prost::alloc::string::String,
    #[prost(bool, tag = "1044")]
    pub enable_car_management_permission: bool,
    #[prost(message, repeated, tag = "1045")]
    pub upcoming_event_list: ::prost::alloc::vec::Vec<user::LiveEventInfo>,
    #[prost(string, tag = "1046")]
    pub scm_label: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "1047")]
    pub ecommerce_entrance: ::core::option::Option<user::EcommerceEntrance>,
    #[prost(bool, tag = "1048")]
    pub is_block: bool,
    #[prost(bool, tag = "1090")]
    pub is_subscribe: bool,
    #[prost(bool, tag = "1091")]
    pub is_anchor_marked: bool,
}
/// Nested message and enum types in `User`.
pub mod user {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LiveEventInfo {
        #[prost(int64, tag = "1")]
        pub event_id: i64,
        #[prost(int64, tag = "2")]
        pub start_time: i64,
        #[prost(int64, tag = "3")]
        pub duration: i64,
        #[prost(string, tag = "4")]
        pub title: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub description: ::prost::alloc::string::String,
        #[prost(bool, tag = "6")]
        pub has_subscribed: bool,
        #[prost(bool, tag = "7")]
        pub is_paid_event: bool,
        #[prost(int64, tag = "8")]
        pub ticket_amount: i64,
        /// @warning Enum not found, should be PayMethod
        #[prost(int64, tag = "9")]
        pub pay_method: i64,
    }
    /// Nested message and enum types in `LiveEventInfo`.
    pub mod live_event_info {
        /// @WalletPackage
        /// proto.webcast.data.LiveEventInfo
        /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct WalletPackage {
            #[prost(string, tag = "1")]
            pub iap_id: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub usd_price_show: ::prost::alloc::string::String,
        }
        /// @EventPayMethod
        /// webcast.data.LiveEventInfo
        /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum EventPayMethod {
            Eventpaymethodinvalid = 0,
            Eventpaymethodcoins = 1,
            Eventpaymethodcash = 2,
        }
        impl EventPayMethod {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    EventPayMethod::Eventpaymethodinvalid => "EVENTPAYMETHODINVALID",
                    EventPayMethod::Eventpaymethodcoins => "EVENTPAYMETHODCOINS",
                    EventPayMethod::Eventpaymethodcash => "EVENTPAYMETHODCASH",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "EVENTPAYMETHODINVALID" => Some(Self::Eventpaymethodinvalid),
                    "EVENTPAYMETHODCOINS" => Some(Self::Eventpaymethodcoins),
                    "EVENTPAYMETHODCASH" => Some(Self::Eventpaymethodcash),
                    _ => None,
                }
            }
        }
    }
    /// @ActivityInfo
    /// proto.webcast.data.User
    /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ActivityInfo {
        #[prost(message, optional, tag = "1")]
        pub badge: ::core::option::Option<super::Image>,
        #[prost(message, optional, tag = "2")]
        pub storytag: ::core::option::Option<super::Image>,
    }
    /// @AnchorLevel
    /// proto.webcast.data.User
    /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AnchorLevel {
        #[prost(int64, tag = "1")]
        pub level: i64,
        #[prost(int64, tag = "2")]
        pub experience: i64,
        #[prost(int64, tag = "3")]
        pub lowest_experience_this_level: i64,
        #[prost(int64, tag = "4")]
        pub highest_experience_this_level: i64,
        #[prost(int64, tag = "5")]
        pub task_start_experience: i64,
        #[prost(int64, tag = "6")]
        pub task_start_time: i64,
        #[prost(int64, tag = "7")]
        pub task_decrease_experience: i64,
        #[prost(int64, tag = "8")]
        pub task_target_experience: i64,
        #[prost(int64, tag = "9")]
        pub task_end_time: i64,
        #[prost(message, optional, tag = "10")]
        pub profile_dialog_bg: ::core::option::Option<super::Image>,
        #[prost(message, optional, tag = "11")]
        pub profile_dialog_bg_back: ::core::option::Option<super::Image>,
        #[prost(message, optional, tag = "12")]
        pub stage_level: ::core::option::Option<super::Image>,
        #[prost(message, optional, tag = "13")]
        pub small_icon: ::core::option::Option<super::Image>,
    }
    /// @AuthenticationInfo
    /// proto.webcast.data.User
    /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AuthenticationInfo {
        #[prost(string, tag = "1")]
        pub custom_verify: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub enterprise_verify_reason: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub authentication_badge: ::core::option::Option<super::Image>,
    }
    /// @AuthorStats
    /// proto.webcast.data.User
    /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AuthorStats {
        #[prost(int64, tag = "1")]
        pub video_total_count: i64,
        #[prost(int64, tag = "2")]
        pub video_total_play_count: i64,
        #[prost(int64, tag = "3")]
        pub video_total_share_count: i64,
        #[prost(int64, tag = "4")]
        pub video_total_series_count: i64,
        #[prost(int64, tag = "5")]
        pub variety_show_play_count: i64,
        #[prost(int64, tag = "6")]
        pub video_total_favorite_count: i64,
    }
    /// @Border
    /// proto.webcast.data.User
    /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Border {
        #[prost(message, optional, tag = "1")]
        pub icon: ::core::option::Option<super::Image>,
        #[prost(int64, tag = "2")]
        pub level: i64,
        #[prost(string, tag = "3")]
        pub source: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "4")]
        pub profile_decoration_ribbon: ::core::option::Option<super::Image>,
        #[prost(string, tag = "7")]
        pub avatar_background_color: ::prost::alloc::string::String,
        #[prost(string, tag = "8")]
        pub avatar_background_border_color: ::prost::alloc::string::String,
    }
    /// @ComboBadgeInfo
    /// proto.webcast.data.User
    /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ComboBadgeInfo {
        #[prost(message, optional, tag = "1")]
        pub icon: ::core::option::Option<super::Image>,
        #[prost(int64, tag = "2")]
        pub combo_count: i64,
    }
    /// @EcommerceEntrance
    /// proto.webcast.data.User
    /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EcommerceEntrance {
        /// Enum
        #[prost(enumeration = "ecommerce_entrance::EntranceType", tag = "1")]
        pub entrance_type: i32,
        /// Enum
        #[prost(enumeration = "ecommerce_entrance::CreatorType", tag = "2")]
        pub creator_type: i32,
        #[prost(string, tag = "3")]
        pub schema: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "4")]
        pub shop_entrance_info: ::core::option::Option<
            ecommerce_entrance::ShopEntranceInfo,
        >,
        #[prost(message, optional, tag = "5")]
        pub showcase_entrance_info: ::core::option::Option<
            ecommerce_entrance::ShowcaseEntranceInfo,
        >,
    }
    /// Nested message and enum types in `EcommerceEntrance`.
    pub mod ecommerce_entrance {
        /// @ShopEntranceInfo
        /// proto.webcast.data.User.EcommerceEntrance
        /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ShopEntranceInfo {
            #[prost(string, tag = "1")]
            pub shop_id: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub shop_name: ::prost::alloc::string::String,
            #[prost(string, tag = "3")]
            pub shop_rating: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "4")]
            pub store_label: ::core::option::Option<shop_entrance_info::StoreLabel>,
            #[prost(string, tag = "5")]
            pub format_sold_count: ::prost::alloc::string::String,
            #[prost(int64, tag = "6")]
            pub sold_count: i64,
            #[prost(int32, tag = "7")]
            pub exp_rate_percentile: i32,
            #[prost(string, tag = "8")]
            pub exp_rate_top_display: ::prost::alloc::string::String,
            #[prost(int32, tag = "9")]
            pub rate_display_style: i32,
            #[prost(bool, tag = "10")]
            pub show_rate_not_applicable: bool,
        }
        /// Nested message and enum types in `ShopEntranceInfo`.
        pub mod shop_entrance_info {
            /// @StoreLabel
            /// proto.webcast.data.User.EcommerceEntrance.ShopEntranceInfo
            /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct StoreLabel {
                #[prost(message, optional, tag = "1")]
                pub official_label: ::core::option::Option<
                    store_label::StoreOfficialLabel,
                >,
                #[prost(bool, tag = "2")]
                pub is_bytemall: bool,
            }
            /// Nested message and enum types in `StoreLabel`.
            pub mod store_label {
                /// @StoreOfficialLabel
                /// proto.webcast.data.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel
                /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
                #[derive(serde::Serialize, serde::Deserialize)]
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct StoreOfficialLabel {
                    #[prost(message, optional, tag = "1")]
                    pub label_image_light: ::core::option::Option<
                        store_official_label::ShopLabelImage,
                    >,
                    #[prost(message, optional, tag = "2")]
                    pub label_image_dark: ::core::option::Option<
                        store_official_label::ShopLabelImage,
                    >,
                    /// @warning Enum not found, should be LabelType
                    #[prost(int64, tag = "3")]
                    pub label_type: i64,
                    #[prost(string, tag = "4")]
                    pub label_type_str: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `StoreOfficialLabel`.
                pub mod store_official_label {
                    /// @ShopLabelImage
                    /// proto.webcast.data.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreOfficialLabel
                    /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
                    #[derive(serde::Serialize, serde::Deserialize)]
                    #[allow(clippy::derive_partial_eq_without_eq)]
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct ShopLabelImage {
                        #[prost(int32, tag = "1")]
                        pub height: i32,
                        #[prost(int32, tag = "2")]
                        pub width: i32,
                        #[prost(string, tag = "3")]
                        pub minetype: ::prost::alloc::string::String,
                        #[prost(string, tag = "4")]
                        pub thumb_uri: ::prost::alloc::string::String,
                        #[prost(string, repeated, tag = "5")]
                        pub thumb_uri_list: ::prost::alloc::vec::Vec<
                            ::prost::alloc::string::String,
                        >,
                        #[prost(string, tag = "6")]
                        pub uri: ::prost::alloc::string::String,
                        #[prost(string, repeated, tag = "7")]
                        pub url_list: ::prost::alloc::vec::Vec<
                            ::prost::alloc::string::String,
                        >,
                        #[prost(string, tag = "8")]
                        pub color: ::prost::alloc::string::String,
                    }
                }
                /// @StoreBrandLabelType
                /// webcast.data.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel
                /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
                #[derive(serde::Serialize, serde::Deserialize)]
                #[derive(
                    Clone,
                    Copy,
                    Debug,
                    PartialEq,
                    Eq,
                    Hash,
                    PartialOrd,
                    Ord,
                    ::prost::Enumeration
                )]
                #[repr(i32)]
                pub enum StoreBrandLabelType {
                    None = 0,
                    Official = 1,
                    Authorized = 2,
                    BlueV = 3,
                    TopChoice = 4,
                }
                impl StoreBrandLabelType {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            StoreBrandLabelType::None => "NONE",
                            StoreBrandLabelType::Official => "OFFICIAL",
                            StoreBrandLabelType::Authorized => "AUTHORIZED",
                            StoreBrandLabelType::BlueV => "STORE_BRAND_LABEL_TYPE_BLUE_V",
                            StoreBrandLabelType::TopChoice => {
                                "STORE_BRAND_LABEL_TYPE_TOP_CHOICE"
                            }
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "NONE" => Some(Self::None),
                            "OFFICIAL" => Some(Self::Official),
                            "AUTHORIZED" => Some(Self::Authorized),
                            "STORE_BRAND_LABEL_TYPE_BLUE_V" => Some(Self::BlueV),
                            "STORE_BRAND_LABEL_TYPE_TOP_CHOICE" => Some(Self::TopChoice),
                            _ => None,
                        }
                    }
                }
            }
        }
        /// @ShowcaseEntranceInfo
        /// proto.webcast.data.User.EcommerceEntrance
        /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ShowcaseEntranceInfo {
            #[prost(string, tag = "1")]
            pub format_sold_count: ::prost::alloc::string::String,
            #[prost(int64, tag = "2")]
            pub sold_count: i64,
        }
        /// @CreatorType
        /// webcast.data.User.EcommerceEntrance
        /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum CreatorType {
            Undefined = 0,
            Official = 1,
            Market = 2,
            Normal = 3,
        }
        impl CreatorType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    CreatorType::Undefined => "UNDEFINED",
                    CreatorType::Official => "OFFICIAL",
                    CreatorType::Market => "MARKET",
                    CreatorType::Normal => "NORMAL",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNDEFINED" => Some(Self::Undefined),
                    "OFFICIAL" => Some(Self::Official),
                    "MARKET" => Some(Self::Market),
                    "NORMAL" => Some(Self::Normal),
                    _ => None,
                }
            }
        }
        /// @EntranceType
        /// webcast.data.User.EcommerceEntrance
        /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum EntranceType {
            Profile = 0,
            Showcase = 1,
            Shop = 2,
        }
        impl EntranceType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    EntranceType::Profile => "PROFILE",
                    EntranceType::Showcase => "SHOWCASE",
                    EntranceType::Shop => "SHOP",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "PROFILE" => Some(Self::Profile),
                    "SHOWCASE" => Some(Self::Showcase),
                    "SHOP" => Some(Self::Shop),
                    _ => None,
                }
            }
        }
    }
    /// @FansClub
    /// proto.webcast.data.User
    /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FansClub {
        #[prost(message, optional, tag = "1")]
        pub data: ::core::option::Option<fans_club::FansClubData>,
    }
    /// Nested message and enum types in `FansClub`.
    pub mod fans_club {
        /// @FansClubData
        /// proto.webcast.data.User.FansClub
        /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct FansClubData {
            #[prost(string, tag = "1")]
            pub club_name: ::prost::alloc::string::String,
            #[prost(int32, tag = "2")]
            pub level: i32,
            /// Enum
            #[prost(enumeration = "fans_club_data::UserFansClubStatus", tag = "3")]
            pub user_fans_club_status: i32,
            #[prost(int64, repeated, tag = "5")]
            pub available_gift_ids_list: ::prost::alloc::vec::Vec<i64>,
            #[prost(int64, tag = "6")]
            pub anchor_id: i64,
        }
        /// Nested message and enum types in `FansClubData`.
        pub mod fans_club_data {
            /// @BadgeIcon
            /// webcast.data.User.FansClub.FansClubData
            /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
            #[derive(serde::Serialize, serde::Deserialize)]
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum BadgeIcon {
                Unknown = 0,
                Icon = 1,
                Smallicon = 2,
            }
            impl BadgeIcon {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        BadgeIcon::Unknown => "UNKNOWN",
                        BadgeIcon::Icon => "ICON",
                        BadgeIcon::Smallicon => "SMALLICON",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "UNKNOWN" => Some(Self::Unknown),
                        "ICON" => Some(Self::Icon),
                        "SMALLICON" => Some(Self::Smallicon),
                        _ => None,
                    }
                }
            }
            /// @UserFansClubStatus
            /// webcast.data.User.FansClub.FansClubData
            /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
            #[derive(serde::Serialize, serde::Deserialize)]
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum UserFansClubStatus {
                Notjoined = 0,
                Active = 1,
                Inactive = 2,
            }
            impl UserFansClubStatus {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        UserFansClubStatus::Notjoined => "NOTJOINED",
                        UserFansClubStatus::Active => "ACTIVE",
                        UserFansClubStatus::Inactive => "INACTIVE",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "NOTJOINED" => Some(Self::Notjoined),
                        "ACTIVE" => Some(Self::Active),
                        "INACTIVE" => Some(Self::Inactive),
                        _ => None,
                    }
                }
            }
        }
        /// @PreferntialType
        /// webcast.data.User.FansClub
        /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum PreferntialType {
            Presonalprofile = 0,
            Otherroom = 1,
        }
        impl PreferntialType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    PreferntialType::Presonalprofile => "PRESONALPROFILE",
                    PreferntialType::Otherroom => "OTHERROOM",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "PRESONALPROFILE" => Some(Self::Presonalprofile),
                    "OTHERROOM" => Some(Self::Otherroom),
                    _ => None,
                }
            }
        }
    }
    /// @FansClubInfo
    /// proto.webcast.data.User
    /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FansClubInfo {
        #[prost(bool, tag = "1")]
        pub is_sleeping: bool,
        #[prost(int64, tag = "2")]
        pub fans_level: i64,
        #[prost(int64, tag = "3")]
        pub fans_score: i64,
        #[prost(message, optional, tag = "4")]
        pub badge: ::core::option::Option<super::Image>,
        #[prost(int64, tag = "5")]
        pub fans_count: i64,
        #[prost(string, tag = "6")]
        pub fans_club_name: ::prost::alloc::string::String,
    }
    /// @FollowInfo
    /// proto.webcast.data.User
    /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FollowInfo {
        #[prost(int64, tag = "1")]
        pub following_count: i64,
        #[prost(int64, tag = "2")]
        pub follower_count: i64,
        #[prost(int64, tag = "3")]
        pub follow_status: i64,
        #[prost(int64, tag = "4")]
        pub push_status: i64,
    }
    /// @OwnRoom
    /// proto.webcast.data.User
    /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct OwnRoom {
        #[prost(int64, repeated, tag = "1")]
        pub room_ids_list: ::prost::alloc::vec::Vec<i64>,
        #[prost(string, repeated, tag = "2")]
        pub room_ids_str_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// @PayGrade
    /// proto.webcast.data.User
    /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PayGrade {
        #[prost(message, optional, tag = "2")]
        pub diamond_icon: ::core::option::Option<super::Image>,
        #[prost(string, tag = "3")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "4")]
        pub icon: ::core::option::Option<super::Image>,
        #[prost(string, tag = "5")]
        pub next_name: ::prost::alloc::string::String,
        #[prost(int64, tag = "6")]
        pub level: i64,
        #[prost(message, optional, tag = "7")]
        pub next_icon: ::core::option::Option<super::Image>,
        #[prost(string, tag = "13")]
        pub grade_describe: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "14")]
        pub grade_icon_list: ::prost::alloc::vec::Vec<super::GradeIcon>,
        #[prost(int64, tag = "15")]
        pub screen_chat_type: i64,
        #[prost(message, optional, tag = "16")]
        pub im_icon: ::core::option::Option<super::Image>,
        #[prost(message, optional, tag = "17")]
        pub im_icon_with_level: ::core::option::Option<super::Image>,
        #[prost(message, optional, tag = "18")]
        pub live_icon: ::core::option::Option<super::Image>,
        #[prost(message, optional, tag = "19")]
        pub new_im_icon_with_level: ::core::option::Option<super::Image>,
        #[prost(message, optional, tag = "20")]
        pub new_live_icon: ::core::option::Option<super::Image>,
        #[prost(int64, tag = "21")]
        pub upgrade_need_consume: i64,
        #[prost(string, tag = "22")]
        pub next_privileges: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "23")]
        pub background: ::core::option::Option<super::Image>,
        #[prost(message, optional, tag = "24")]
        pub background_back: ::core::option::Option<super::Image>,
        #[prost(int64, tag = "25")]
        pub score: i64,
        #[prost(string, tag = "1001")]
        pub grade_banner: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "1002")]
        pub profile_dialog_bg: ::core::option::Option<super::Image>,
        #[prost(message, optional, tag = "1003")]
        pub profile_dialog_bg_back: ::core::option::Option<super::Image>,
    }
    /// @SubscribeBadge
    /// proto.webcast.data.User
    /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SubscribeBadge {
        #[prost(message, optional, tag = "3")]
        pub origin_img: ::core::option::Option<super::Image>,
        #[prost(message, optional, tag = "4")]
        pub preview_img: ::core::option::Option<super::Image>,
    }
    /// @SubscribeInfo
    /// proto.webcast.data.User
    /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SubscribeInfo {
        #[prost(bool, tag = "1")]
        pub qualification: bool,
        #[prost(bool, tag = "2")]
        pub is_subscribe: bool,
        #[prost(message, optional, tag = "3")]
        pub badge: ::core::option::Option<SubscribeBadge>,
        #[prost(bool, tag = "4")]
        pub enable_subscription: bool,
        #[prost(int64, tag = "5")]
        pub subscriber_count: i64,
        #[prost(bool, tag = "6")]
        pub is_in_grace_period: bool,
        #[prost(bool, tag = "7")]
        pub is_subscribed_to_anchor: bool,
        #[prost(bool, tag = "9")]
        pub user_gift_sub_auth: bool,
        #[prost(bool, tag = "10")]
        pub anchor_gift_sub_auth: bool,
    }
    /// @UserAttr
    /// proto.webcast.data.User
    /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UserAttr {
        #[prost(bool, tag = "1")]
        pub is_muted: bool,
        #[prost(bool, tag = "2")]
        pub is_admin: bool,
        #[prost(bool, tag = "3")]
        pub is_super_admin: bool,
        #[prost(int64, tag = "4")]
        pub mute_duration: i64,
    }
    /// @UserStats
    /// proto.webcast.data.User
    /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UserStats {
        #[prost(int64, tag = "1")]
        pub id: i64,
        #[prost(string, tag = "2")]
        pub id_str: ::prost::alloc::string::String,
        #[prost(int64, tag = "3")]
        pub following_count: i64,
        #[prost(int64, tag = "4")]
        pub follower_count: i64,
        #[prost(int64, tag = "5")]
        pub record_count: i64,
        #[prost(int64, tag = "6")]
        pub total_duration: i64,
        #[prost(int64, tag = "7")]
        pub daily_fan_ticket_count: i64,
        #[prost(int64, tag = "8")]
        pub daily_income: i64,
        #[prost(int64, tag = "9")]
        pub item_count: i64,
        #[prost(int64, tag = "10")]
        pub favorite_item_count: i64,
        #[prost(int64, tag = "12")]
        pub diamond_consumed_count: i64,
        #[prost(int64, tag = "13")]
        pub tuwen_item_count: i64,
    }
}
/// @Emote
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Emote {
    #[prost(string, tag = "1")]
    pub emote_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub image: ::core::option::Option<Image>,
    /// Enum
    #[prost(enumeration = "AuditStatus", tag = "3")]
    pub audit_status: i32,
    #[prost(string, tag = "4")]
    pub uuid: ::prost::alloc::string::String,
    /// Enum
    #[prost(enumeration = "EmoteType", tag = "5")]
    pub emote_type: i32,
    /// Enum
    #[prost(enumeration = "ContentSource", tag = "6")]
    pub content_source: i32,
    /// Enum
    #[prost(enumeration = "EmotePrivateType", tag = "7")]
    pub emote_private_type: i32,
    #[prost(string, tag = "8")]
    pub package_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "9")]
    pub audit_info: ::core::option::Option<emote::AuditInfo>,
    #[prost(enumeration = "RewardCondition", tag = "10")]
    pub reward_condition: i32,
    #[prost(message, optional, tag = "11")]
    pub emote_upload_info: ::core::option::Option<emote::EmoteUploadInfo>,
    #[prost(int64, tag = "12")]
    pub create_time: i64,
    #[prost(enumeration = "EmoteScene", tag = "13")]
    pub emote_scene: i32,
}
/// Nested message and enum types in `Emote`.
pub mod emote {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AuditInfo {
        #[prost(int64, tag = "1")]
        pub violation_id: i64,
        #[prost(enumeration = "audit_info::AuditTaskType", tag = "2")]
        pub task_type: i32,
    }
    /// Nested message and enum types in `AuditInfo`.
    pub mod audit_info {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum AuditTaskType {
            Default = 0,
            Appeal = 1,
        }
        impl AuditTaskType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    AuditTaskType::Default => "AUDIT_TASK_TYPE_DEFAULT",
                    AuditTaskType::Appeal => "AUDIT_TASK_TYPE_APPEAL",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "AUDIT_TASK_TYPE_DEFAULT" => Some(Self::Default),
                    "AUDIT_TASK_TYPE_APPEAL" => Some(Self::Appeal),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EmoteUploadInfo {
        #[prost(int64, tag = "1")]
        pub user_id: i64,
        #[prost(enumeration = "super::UserEmoteUploadSource", tag = "2")]
        pub emote_upload_source: i32,
        #[prost(message, optional, tag = "3")]
        pub user_info: ::core::option::Option<super::User>,
        #[prost(string, tag = "4")]
        pub user_id_str: ::prost::alloc::string::String,
    }
}
/// @PunishEventInfo
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PunishEventInfo {
    #[prost(string, tag = "1")]
    pub punish_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub punish_reason: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub punish_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub violation_uid: i64,
    /// Enum
    #[prost(enumeration = "PunishTypeId", tag = "5")]
    pub punish_type_id: i32,
    #[prost(int64, tag = "6")]
    pub duration: i64,
    #[prost(string, tag = "7")]
    pub punish_perception_code: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub violation_uid_str: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub show_reason: ::prost::alloc::string::String,
}
/// @MsgFilter
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgFilter {
    #[prost(bool, tag = "1")]
    pub is_gifter: bool,
    #[prost(bool, tag = "2")]
    pub is_subscribed_to_anchor: bool,
}
/// @UserIdentity
/// proto.webcast.data
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserIdentity {
    #[prost(bool, tag = "1")]
    pub is_gift_giver_of_anchor: bool,
    #[prost(bool, tag = "2")]
    pub is_subscriber_of_anchor: bool,
    #[prost(bool, tag = "3")]
    pub is_mutual_following_with_anchor: bool,
    #[prost(bool, tag = "4")]
    pub is_follower_of_anchor: bool,
    #[prost(bool, tag = "5")]
    pub is_moderator_of_anchor: bool,
    #[prost(bool, tag = "6")]
    pub is_anchor: bool,
}
/// @Goal
/// proto.webcast.data
/// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LiveStreamGoal {
    #[prost(int64, tag = "1")]
    pub id: i64,
    #[prost(int32, tag = "2")]
    pub r#type: i32,
    #[prost(int32, tag = "3")]
    pub status: i32,
    #[prost(message, repeated, tag = "4")]
    pub sub_goals: ::prost::alloc::vec::Vec<live_stream_goal::LiveStreamSubGoal>,
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "AuditStatus", tag = "6")]
    pub audit_status: i32,
    #[prost(int32, tag = "7")]
    pub cycle_type: i32,
    #[prost(int64, tag = "8")]
    pub start_time: i64,
    #[prost(int64, tag = "9")]
    pub expire_time: i64,
    #[prost(int64, tag = "10")]
    pub real_finish_time: i64,
    #[prost(message, repeated, tag = "11")]
    pub contributors: ::prost::alloc::vec::Vec<
        live_stream_goal::LiveStreamGoalContributor,
    >,
    #[prost(int32, tag = "12")]
    pub contributors_length: i32,
    #[prost(string, tag = "13")]
    pub id_str: ::prost::alloc::string::String,
    #[prost(string, tag = "14")]
    pub audit_description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "15")]
    pub stats: ::core::option::Option<live_stream_goal::GoalStats>,
    #[prost(string, tag = "16")]
    pub goal_extra_info: ::prost::alloc::string::String,
    #[prost(int32, tag = "17")]
    pub mode: i32,
    #[prost(message, optional, tag = "18")]
    pub audit_info: ::core::option::Option<live_stream_goal::AuditInfo>,
    #[prost(string, tag = "20")]
    pub challenge_type: ::prost::alloc::string::String,
    #[prost(bool, tag = "21")]
    pub is_uneditable: bool,
}
/// Nested message and enum types in `LiveStreamGoal`.
pub mod live_stream_goal {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AuditInfo {
        #[prost(int64, tag = "1")]
        pub violation_id: i64,
        #[prost(int32, tag = "2")]
        pub task_type: i32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LiveStreamSubGoal {
        #[prost(int32, tag = "1")]
        pub r#type: i32,
        #[prost(int64, tag = "2")]
        pub id: i64,
        #[prost(int64, tag = "3")]
        pub progress: i64,
        #[prost(int64, tag = "4")]
        pub target: i64,
        #[prost(message, optional, tag = "5")]
        pub gift: ::core::option::Option<LiveStreamSubGoalGift>,
        #[prost(string, tag = "6")]
        pub id_str: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "7")]
        pub pin_info: ::core::option::Option<live_stream_sub_goal::SubGoalPinInfo>,
        #[prost(int32, tag = "8")]
        pub source: i32,
        #[prost(string, tag = "9")]
        pub recommended_text: ::prost::alloc::string::String,
        #[prost(string, tag = "10")]
        pub recommended_header: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `LiveStreamSubGoal`.
    pub mod live_stream_sub_goal {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SubGoalPinInfo {
            #[prost(int64, tag = "1")]
            pub pin_start_time: i64,
            #[prost(int64, tag = "2")]
            pub pin_end_time: i64,
            #[prost(int64, tag = "3")]
            pub pin_ready_time: i64,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LiveStreamSubGoalGift {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub icon: ::core::option::Option<super::Image>,
        #[prost(int64, tag = "3")]
        pub diamond_count: i64,
        #[prost(int32, tag = "4")]
        pub r#type: i32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LiveStreamGoalContributor {
        #[prost(int64, tag = "1")]
        pub user_id: i64,
        #[prost(message, optional, tag = "2")]
        pub avatar: ::core::option::Option<super::Image>,
        #[prost(string, tag = "3")]
        pub display_id: ::prost::alloc::string::String,
        #[prost(int64, tag = "4")]
        pub score: i64,
        #[prost(string, tag = "5")]
        pub user_id_str: ::prost::alloc::string::String,
        #[prost(bool, tag = "6")]
        pub in_room: bool,
        #[prost(bool, tag = "7")]
        pub is_friend: bool,
        #[prost(bool, tag = "9")]
        pub follow_by_owner: bool,
        #[prost(bool, tag = "10")]
        pub is_fist_contribute: bool,
        #[prost(message, repeated, tag = "11")]
        pub sub_goal_contributions: ::prost::alloc::vec::Vec<
            live_stream_goal_contributor::SubGoalContribution,
        >,
    }
    /// Nested message and enum types in `LiveStreamGoalContributor`.
    pub mod live_stream_goal_contributor {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SubGoalContribution {
            #[prost(string, tag = "1")]
            pub id: ::prost::alloc::string::String,
            #[prost(int64, tag = "2")]
            pub contribution_count: i64,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GoalStats {
        #[prost(int64, tag = "1")]
        pub total_coins: i64,
        #[prost(int64, tag = "2")]
        pub total_contributor: i64,
        #[prost(message, optional, tag = "3")]
        pub comparison: ::core::option::Option<goal_stats::GoalComparison>,
        #[prost(int64, tag = "4")]
        pub total_new_fans: i64,
    }
    /// Nested message and enum types in `GoalStats`.
    pub mod goal_stats {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct GoalComparison {
            #[prost(int64, tag = "1")]
            pub coins_incr: i64,
            #[prost(int64, tag = "2")]
            pub contributor_incr: i64,
        }
    }
}
/// @Indicator
/// proto.webcast.data
/// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LiveStreamGoalIndicator {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub op: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Ranking {
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub label: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub color: ::core::option::Option<TikTokColor>,
    #[prost(message, repeated, tag = "4")]
    pub details: ::prost::alloc::vec::Vec<ValueLabel>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TikTokColor {
    #[prost(string, tag = "1")]
    pub color: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub id: u64,
    #[prost(uint32, tag = "6")]
    pub data1: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValueLabel {
    #[prost(uint32, tag = "1")]
    pub data: u32,
    #[prost(string, tag = "2")]
    pub label: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub label2: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub label3: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeStampContainer {
    #[prost(uint64, tag = "1")]
    pub timestamp1: u64,
    #[prost(uint64, tag = "2")]
    pub timestamp2: u64,
    #[prost(uint64, tag = "3")]
    pub timestamp3: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollStartContent {
    #[prost(int64, tag = "1")]
    pub start_time: i64,
    #[prost(int64, tag = "2")]
    pub end_time: i64,
    #[prost(message, repeated, tag = "3")]
    pub option_list: ::prost::alloc::vec::Vec<PollOptionInfo>,
    #[prost(string, tag = "4")]
    pub title: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub operator: ::core::option::Option<User>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollEndContent {
    #[prost(enumeration = "PollEndType", tag = "1")]
    pub end_type: i32,
    #[prost(message, repeated, tag = "2")]
    pub option_list: ::prost::alloc::vec::Vec<PollOptionInfo>,
    #[prost(message, optional, tag = "3")]
    pub operator: ::core::option::Option<User>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollOptionInfo {
    #[prost(int32, tag = "1")]
    pub votes: i32,
    #[prost(string, tag = "2")]
    pub display_content: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub option_idx: i32,
    #[prost(message, repeated, tag = "4")]
    pub vote_user_list: ::prost::alloc::vec::Vec<VoteUser>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VoteUser {
    #[prost(int64, tag = "1")]
    pub user_id: i64,
    #[prost(string, tag = "2")]
    pub nick_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub avatar_thumb: ::core::option::Option<Image>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollUpdateVotesContent {
    #[prost(message, repeated, tag = "2")]
    pub option_list: ::prost::alloc::vec::Vec<PollOptionInfo>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserFanTicket {
    #[prost(int64, tag = "1")]
    pub user_id: i64,
    #[prost(int64, tag = "2")]
    pub fan_ticket: i64,
    #[prost(int64, tag = "3")]
    pub match_total_score: i64,
    #[prost(int32, tag = "4")]
    pub match_rank: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FanTicketRoomNoticeContent {
    #[prost(message, repeated, tag = "1")]
    pub user_fan_ticket_list: ::prost::alloc::vec::Vec<UserFanTicket>,
    #[prost(int64, tag = "2")]
    pub total_link_mic_fan_ticket: i64,
    #[prost(int64, tag = "3")]
    pub match_id: i64,
    #[prost(int64, tag = "4")]
    pub event_time: i64,
    #[prost(string, tag = "5")]
    pub fan_ticket_icon_url: ::prost::alloc::string::String,
    #[prost(int64, tag = "6")]
    pub play_id: i64,
    #[prost(enumeration = "PlayScene", tag = "7")]
    pub play_scene: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkerAcceptNoticeContent {
    #[prost(int64, tag = "1")]
    pub from_user_id: i64,
    #[prost(int64, tag = "2")]
    pub from_room_id: i64,
    #[prost(int64, tag = "3")]
    pub to_user_id: i64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkerCancelContent {
    #[prost(int64, tag = "1")]
    pub from_user_id: i64,
    #[prost(int64, tag = "2")]
    pub to_user_id: i64,
    #[prost(int64, tag = "3")]
    pub cancel_type: i64,
    #[prost(int64, tag = "4")]
    pub action_id: i64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUser {
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<User>,
    #[prost(int64, tag = "2")]
    pub linkmic_id: i64,
    #[prost(string, tag = "3")]
    pub linkmic_id_str: ::prost::alloc::string::String,
    #[prost(enumeration = "LinkmicRoleType", tag = "4")]
    pub link_status: i32,
    #[prost(enumeration = "LinkType", tag = "5")]
    pub link_type: i32,
    #[prost(int32, tag = "6")]
    pub user_position: i32,
    #[prost(enumeration = "LinkSilenceStatus", tag = "7")]
    pub silence_status: i32,
    #[prost(int64, tag = "8")]
    pub modify_time: i64,
    #[prost(int64, tag = "9")]
    pub linker_id: i64,
    #[prost(enumeration = "LinkRoleType", tag = "10")]
    pub role_type: i32,
}
/// it is just empty
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkerCloseContent {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkerCreateContent {
    #[prost(int64, tag = "1")]
    pub owner_id: i64,
    #[prost(int64, tag = "2")]
    pub owner_room_id: i64,
    /// Assuming this is LinkType enum
    #[prost(int64, tag = "3")]
    pub link_type: i64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkerEnterContent {
    #[prost(message, repeated, tag = "1")]
    pub linked_users_list: ::prost::alloc::vec::Vec<ListUser>,
    #[prost(enumeration = "LinkmicMultiLiveEnum", tag = "2")]
    pub anchor_multi_live_enum: i32,
    #[prost(message, optional, tag = "3")]
    pub anchor_setting_info: ::core::option::Option<MultiLiveAnchorPanelSettings>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkerInviteContent {
    #[prost(int64, tag = "1")]
    pub from_user_id: i64,
    #[prost(int64, tag = "2")]
    pub from_room_id: i64,
    #[prost(string, tag = "3")]
    pub to_rtc_ext_info: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub rtc_join_channel: bool,
    #[prost(int64, tag = "5")]
    pub vendor: i64,
    #[prost(string, tag = "6")]
    pub sec_from_user_id: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub to_linkmic_id_str: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "8")]
    pub from_user: ::core::option::Option<User>,
    #[prost(int64, tag = "9")]
    pub required_mic_idx: i64,
    #[prost(map = "int64, string", tag = "10")]
    pub rtc_ext_info_map: ::std::collections::HashMap<
        i64,
        ::prost::alloc::string::String,
    >,
    #[prost(enumeration = "LinkmicMultiLiveEnum", tag = "11")]
    pub multi_live_layout_enable: i32,
    #[prost(message, optional, tag = "12")]
    pub multi_live_setting: ::core::option::Option<MultiLiveAnchorPanelSettings>,
    #[prost(string, tag = "13")]
    pub from_linkmic_id_str: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "16")]
    pub from_top_host_info: ::core::option::Option<
        linker_invite_content::InviteTopHostInfo,
    >,
    #[prost(int64, tag = "17")]
    pub action_id: i64,
    #[prost(message, repeated, tag = "18")]
    pub linked_users: ::prost::alloc::vec::Vec<linker_invite_content::LinkmicUserInfo>,
    #[prost(message, optional, tag = "19")]
    pub dialog_info: ::core::option::Option<linker_invite_content::PerceptionDialogInfo>,
    #[prost(message, optional, tag = "20")]
    pub punish_event_info: ::core::option::Option<PunishEventInfo>,
    #[prost(int32, tag = "21")]
    pub from_room_age_restricted: i32,
    #[prost(message, repeated, tag = "23")]
    pub ab_test_setting: ::prost::alloc::vec::Vec<
        linker_invite_content::CohostAbTestSetting,
    >,
    #[prost(message, optional, tag = "101")]
    pub linker_invite_msg_extra: ::core::option::Option<
        linker_invite_content::LinkerInviteMessageExtra,
    >,
}
/// Nested message and enum types in `LinkerInviteContent`.
pub mod linker_invite_content {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InviteTopHostInfo {
        #[prost(string, tag = "1")]
        pub rank_type: ::prost::alloc::string::String,
        #[prost(int64, tag = "2")]
        pub top_index: i64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LinkmicUserInfo {
        #[prost(int64, tag = "1")]
        pub user_id: i64,
        #[prost(string, tag = "2")]
        pub linkmic_id_str: ::prost::alloc::string::String,
        #[prost(int64, tag = "3")]
        pub room_id: i64,
        #[prost(int64, tag = "4")]
        pub linked_time: i64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PerceptionDialogInfo {
        #[prost(enumeration = "super::PerceptionDialogIconType", tag = "1")]
        pub icon_type: i32,
        #[prost(message, optional, tag = "2")]
        pub title: ::core::option::Option<super::Text>,
        #[prost(message, optional, tag = "3")]
        pub sub_title: ::core::option::Option<super::Text>,
        #[prost(message, optional, tag = "4")]
        pub advice_action_text: ::core::option::Option<super::Text>,
        #[prost(message, optional, tag = "5")]
        pub default_action_text: ::core::option::Option<super::Text>,
        #[prost(string, tag = "6")]
        pub violation_detail_url: ::prost::alloc::string::String,
        #[prost(enumeration = "super::Scene", tag = "7")]
        pub scene: i32,
        #[prost(int64, tag = "8")]
        pub target_user_id: i64,
        #[prost(int64, tag = "9")]
        pub target_room_id: i64,
        #[prost(int64, tag = "10")]
        pub count_down_time: i64,
        #[prost(bool, tag = "11")]
        pub show_feedback: bool,
        #[prost(message, repeated, tag = "12")]
        pub feedback_options: ::prost::alloc::vec::Vec<
            perception_dialog_info::PerceptionFeedbackOption,
        >,
        #[prost(int64, tag = "13")]
        pub policy_tip: i64,
        #[prost(int32, tag = "14")]
        pub appeal_popup: i32,
    }
    /// Nested message and enum types in `PerceptionDialogInfo`.
    pub mod perception_dialog_info {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct PerceptionFeedbackOption {
            #[prost(int64, tag = "1")]
            pub id: i64,
            #[prost(string, tag = "2")]
            pub content_key: ::prost::alloc::string::String,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CohostAbTestSetting {
        #[prost(int64, tag = "1")]
        pub key: i64,
        #[prost(message, optional, tag = "2")]
        pub value: ::core::option::Option<cohost_ab_test_setting::CohostAbTestList>,
    }
    /// Nested message and enum types in `CohostABTestSetting`.
    pub mod cohost_ab_test_setting {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CohostAbTestList {
            #[prost(message, repeated, tag = "1")]
            pub ab_test_list: ::prost::alloc::vec::Vec<
                cohost_ab_test_list::CohostAbTest,
            >,
        }
        /// Nested message and enum types in `CohostABTestList`.
        pub mod cohost_ab_test_list {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct CohostAbTest {
                #[prost(
                    enumeration = "super::super::super::CohostAbTestType",
                    tag = "1"
                )]
                pub ab_test_type: i32,
                #[prost(int64, tag = "2")]
                pub group: i64,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LinkerInviteMessageExtra {
        #[prost(int32, tag = "1")]
        pub match_type: i32,
        #[prost(int32, tag = "2")]
        pub invite_type: i32,
        #[prost(int32, tag = "3")]
        pub sub_type: i32,
        #[prost(string, tag = "4")]
        pub theme: ::prost::alloc::string::String,
        #[prost(int32, tag = "5")]
        pub duration: i32,
        #[prost(int32, tag = "6")]
        pub layout: i32,
        #[prost(string, tag = "7")]
        pub tips: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "8")]
        pub inviter_rival_extra: ::core::option::Option<
            linker_invite_message_extra::InviterRivalExtra,
        >,
        #[prost(message, repeated, tag = "9")]
        pub other_rival_extra: ::prost::alloc::vec::Vec<
            linker_invite_message_extra::InviterRivalExtra,
        >,
        #[prost(message, optional, tag = "10")]
        pub topic_info: ::core::option::Option<super::CohostTopic>,
        #[prost(string, tag = "11")]
        pub algo_request_id: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `LinkerInviteMessageExtra`.
    pub mod linker_invite_message_extra {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct InviterRivalExtra {
            #[prost(enumeration = "super::super::TextType", tag = "1")]
            pub text_type: i32,
            #[prost(string, tag = "2")]
            pub text: ::prost::alloc::string::String,
            #[prost(string, tag = "3")]
            pub label: ::prost::alloc::string::String,
            #[prost(int32, tag = "4")]
            pub user_count: i32,
            #[prost(message, optional, tag = "5")]
            pub avatar_thumb: ::core::option::Option<super::super::Image>,
            #[prost(string, tag = "6")]
            pub display_id: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "7")]
            pub authentication_info: ::core::option::Option<
                inviter_rival_extra::AuthenticationInfo,
            >,
            #[prost(string, tag = "8")]
            pub nickname: ::prost::alloc::string::String,
            #[prost(int64, tag = "9")]
            pub follow_status: i64,
            #[prost(message, optional, tag = "10")]
            pub m_hashtag: ::core::option::Option<inviter_rival_extra::Hashtag>,
            #[prost(int64, tag = "12")]
            pub user_id: i64,
            #[prost(bool, tag = "13")]
            pub is_best_teammate: bool,
            #[prost(message, optional, tag = "14")]
            pub opt_pair_info: ::core::option::Option<inviter_rival_extra::OptPairInfo>,
            #[prost(int64, tag = "15")]
            pub follower_count: i64,
        }
        /// Nested message and enum types in `InviterRivalExtra`.
        pub mod inviter_rival_extra {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct AuthenticationInfo {
                #[prost(string, tag = "1")]
                pub custom_verify: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub enterprise_verify_reason: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub authentication_badge: ::core::option::Option<
                    super::super::super::Image,
                >,
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Hashtag {
                #[prost(int64, tag = "1")]
                pub id: i64,
                #[prost(string, tag = "2")]
                pub title: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub image: ::core::option::Option<super::super::super::Image>,
                #[prost(
                    enumeration = "super::super::super::HashtagNamespace",
                    tag = "4"
                )]
                pub namespace: i32,
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct OptPairInfo {
                #[prost(int64, tag = "1")]
                pub mapping_id: i64,
                #[prost(message, repeated, tag = "2")]
                pub display_user_list: ::prost::alloc::vec::Vec<
                    opt_pair_info::OptPairUser,
                >,
                #[prost(enumeration = "super::super::super::OptPairStatus", tag = "3")]
                pub button_notice_type: i32,
                #[prost(int64, tag = "4")]
                pub expected_time_sec: i64,
                #[prost(int64, tag = "5")]
                pub opt_pair_type: i64,
            }
            /// Nested message and enum types in `OptPairInfo`.
            pub mod opt_pair_info {
                #[derive(serde::Serialize, serde::Deserialize)]
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct OptPairUser {
                    #[prost(message, optional, tag = "1")]
                    pub user: ::core::option::Option<super::super::super::super::User>,
                    #[prost(int64, tag = "2")]
                    pub room_id: i64,
                }
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CohostTopic {
    #[prost(int64, tag = "1")]
    pub id: i64,
    #[prost(string, tag = "2")]
    pub title_key: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub title_text: ::prost::alloc::string::String,
    #[prost(bool, tag = "21")]
    pub liked: bool,
    #[prost(int64, tag = "22")]
    pub total_heat: i64,
    #[prost(int64, tag = "23")]
    pub total_rivals: i64,
    #[prost(message, repeated, tag = "24")]
    pub rivals_avatar: ::prost::alloc::vec::Vec<Image>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkerKickOutContent {
    #[prost(int64, tag = "1")]
    pub from_user_id: i64,
    #[prost(enumeration = "KickoutReason", tag = "2")]
    pub kickout_reason: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkerLeaveContent {
    #[prost(int64, tag = "1")]
    pub user_id: i64,
    #[prost(string, tag = "2")]
    pub linkmic_id_str: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub send_leave_uid: i64,
    #[prost(int64, tag = "4")]
    pub leave_reason: i64,
}
/// Empty
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkerLinkedListChangeContent {}
/// Empty
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CohostListChangeContent {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkerListChangeContent {
    #[prost(message, repeated, tag = "1")]
    pub linked_users: ::prost::alloc::vec::Vec<ListUser>,
    #[prost(message, repeated, tag = "2")]
    pub applied_users: ::prost::alloc::vec::Vec<ListUser>,
    #[prost(message, repeated, tag = "3")]
    pub connecting_users: ::prost::alloc::vec::Vec<ListUser>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkerMediaChangeContent {
    #[prost(enumeration = "GuestMicCameraManageOp", tag = "1")]
    pub op: i32,
    #[prost(int64, tag = "2")]
    pub to_user_id: i64,
    #[prost(int64, tag = "3")]
    pub anchor_id: i64,
    #[prost(int64, tag = "4")]
    pub room_id: i64,
    #[prost(enumeration = "GuestMicCameraChangeScene", tag = "5")]
    pub change_scene: i32,
    #[prost(message, optional, tag = "7")]
    pub operator_info: ::core::option::Option<
        linker_media_change_content::LinkerMediaChangeOperator,
    >,
}
/// Nested message and enum types in `LinkerMediaChangeContent`.
pub mod linker_media_change_content {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LinkerMediaChangeOperator {
        #[prost(int64, tag = "1")]
        pub user_id: i64,
        #[prost(enumeration = "super::LinkMicUserAdminType", tag = "2")]
        pub operator_type: i32,
        #[prost(string, tag = "3")]
        pub nick_name: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub display_id: ::prost::alloc::string::String,
    }
}
/// Empty
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkerMicIdxUpdateContent {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkerMuteContent {
    #[prost(int64, tag = "1")]
    pub user_id: i64,
    #[prost(enumeration = "MuteStatus", tag = "2")]
    pub status: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkerRandomMatchContent {
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<User>,
    #[prost(int64, tag = "2")]
    pub room_id: i64,
    #[prost(int64, tag = "3")]
    pub invite_type: i64,
    #[prost(string, tag = "4")]
    pub match_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "5")]
    pub inner_channel_id: i64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkerReplyContent {
    #[prost(int64, tag = "1")]
    pub from_user_id: i64,
    #[prost(int64, tag = "2")]
    pub from_room_id: i64,
    #[prost(message, optional, tag = "3")]
    pub from_user_linkmic_info: ::core::option::Option<
        linker_reply_content::LinkmicInfo,
    >,
    #[prost(int64, tag = "4")]
    pub to_user_id: i64,
    #[prost(message, optional, tag = "5")]
    pub to_user_linkmic_info: ::core::option::Option<linker_reply_content::LinkmicInfo>,
    #[prost(int64, tag = "6")]
    pub link_type: i64,
    #[prost(int64, tag = "7")]
    pub reply_status: i64,
    #[prost(message, optional, tag = "8")]
    pub linker_setting: ::core::option::Option<LinkerSetting>,
    #[prost(message, optional, tag = "9")]
    pub from_user: ::core::option::Option<User>,
    #[prost(message, optional, tag = "10")]
    pub to_user: ::core::option::Option<User>,
}
/// Nested message and enum types in `LinkerReplyContent`.
pub mod linker_reply_content {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LinkmicInfo {
        #[prost(string, tag = "1")]
        pub access_key: ::prost::alloc::string::String,
        #[prost(int64, tag = "2")]
        pub link_mic_id: i64,
        #[prost(bool, tag = "3")]
        pub joinable: bool,
        #[prost(int32, tag = "4")]
        pub confluence_type: i32,
        #[prost(string, tag = "5")]
        pub rtc_ext_info: ::prost::alloc::string::String,
        #[prost(string, tag = "6")]
        pub rtc_app_id: ::prost::alloc::string::String,
        #[prost(string, tag = "7")]
        pub rtc_app_sign: ::prost::alloc::string::String,
        #[prost(string, tag = "8")]
        pub linkmic_id_str: ::prost::alloc::string::String,
        #[prost(int64, tag = "9")]
        pub vendor: i64,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkerSetting {
    #[prost(int64, tag = "1")]
    pub max_member_limit: i64,
    #[prost(int64, tag = "2")]
    pub link_type: i64,
    #[prost(enumeration = "Scene", tag = "3")]
    pub scene: i32,
    #[prost(int64, tag = "4")]
    pub owner_user_id: i64,
    #[prost(int64, tag = "5")]
    pub owner_room_id: i64,
    #[prost(int64, tag = "6")]
    pub vendor: i64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkerSysKickOutContent {
    #[prost(int64, tag = "1")]
    pub user_id: i64,
    #[prost(string, tag = "2")]
    pub linkmic_id_str: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkmicUserToastContent {
    #[prost(int64, tag = "1")]
    pub user_id: i64,
    #[prost(int64, tag = "2")]
    pub room_id: i64,
    #[prost(message, optional, tag = "3")]
    pub display_text: ::core::option::Option<Text>,
    #[prost(int64, tag = "4")]
    pub leaved_user_id: i64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkerUpdateUserContent {
    #[prost(int64, tag = "1")]
    pub from_user_id: i64,
    #[prost(int64, tag = "2")]
    pub to_user_id: i64,
    #[prost(map = "string, string", tag = "3")]
    pub update_info: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkerUpdateUserSettingContent {
    #[prost(message, optional, tag = "1")]
    pub multi_live_anchor_panel_settings: ::core::option::Option<
        MultiLiveAnchorPanelSettings,
    >,
}
/// Empty
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkerWaitingListChangeContent {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultiLiveAnchorPanelSettings {
    #[prost(int64, tag = "1")]
    pub user_id: i64,
    #[prost(int64, tag = "2")]
    pub layout: i64,
    #[prost(int64, tag = "3")]
    pub fix_mic_num: i64,
    #[prost(int64, tag = "4")]
    pub allow_request_from_user: i64,
    #[prost(int64, tag = "5")]
    pub allow_request_from_follower_only: i64,
    #[prost(enumeration = "LinkmicApplierSortSetting", tag = "7")]
    pub applier_sort_setting: i32,
    #[prost(int64, tag = "8")]
    pub applier_sort_gift_score_threshold: i64,
    #[prost(int32, tag = "9")]
    pub allow_request_from_friends: i32,
    #[prost(int32, tag = "10")]
    pub allow_request_from_followers: i32,
    #[prost(int32, tag = "11")]
    pub allow_request_from_others: i32,
    #[prost(int32, tag = "12")]
    pub enable_show_multi_guest_layout: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Player {
    #[prost(int64, tag = "1")]
    pub room_id: i64,
    #[prost(int64, tag = "2")]
    pub user_id: i64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllListUser {
    #[prost(message, repeated, tag = "2")]
    pub linked_list: ::prost::alloc::vec::Vec<LinkLayerListUser>,
    #[prost(message, repeated, tag = "3")]
    pub applied_list: ::prost::alloc::vec::Vec<LinkLayerListUser>,
    #[prost(message, repeated, tag = "4")]
    pub invited_list: ::prost::alloc::vec::Vec<LinkLayerListUser>,
    #[prost(message, repeated, tag = "5")]
    pub ready_list: ::prost::alloc::vec::Vec<LinkLayerListUser>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkLayerListUser {
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<User>,
    #[prost(int64, tag = "2")]
    pub linkmic_id: i64,
    #[prost(message, optional, tag = "3")]
    pub pos: ::core::option::Option<Position>,
    #[prost(int64, tag = "4")]
    pub linked_time_nano: i64,
    #[prost(string, tag = "5")]
    pub app_version: ::prost::alloc::string::String,
    #[prost(int64, tag = "7")]
    pub magic_number1: i64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Position {
    #[prost(int32, tag = "1")]
    pub r#type: i32,
    #[prost(message, optional, tag = "2")]
    pub link: ::core::option::Option<LinkPosition>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkPosition {
    #[prost(int32, tag = "1")]
    pub position: i32,
    #[prost(int32, tag = "2")]
    pub opt: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupPlayer {
    #[prost(int64, tag = "1")]
    pub channel_id: i64,
    #[prost(message, optional, tag = "2")]
    pub user: ::core::option::Option<User>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DslConfig {
    #[prost(int32, tag = "1")]
    pub scene_version: i32,
    #[prost(string, tag = "2")]
    pub layout_id: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupChannelAllUser {
    #[prost(int64, tag = "1")]
    pub group_channel_id: i64,
    #[prost(message, repeated, tag = "2")]
    pub user_list: ::prost::alloc::vec::Vec<GroupChannelUser>,
    #[prost(int64, tag = "3")]
    pub content_version: i64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupChannelUser {
    #[prost(int64, tag = "1")]
    pub channel_id: i64,
    #[prost(enumeration = "GroupStatus", tag = "2")]
    pub status: i32,
    #[prost(enumeration = "TextType", tag = "3")]
    pub r#type: i32,
    #[prost(message, optional, tag = "4")]
    pub all_user: ::core::option::Option<AllListUser>,
    #[prost(int64, tag = "5")]
    pub join_time: i64,
    #[prost(int64, tag = "6")]
    pub linked_time: i64,
    #[prost(message, optional, tag = "7")]
    pub owner_user: ::core::option::Option<GroupPlayer>,
    #[prost(string, tag = "8")]
    pub group_linkmic_id: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RtcExtraInfo {
    #[prost(message, optional, tag = "1")]
    pub live_rtc_engine_config: ::core::option::Option<rtc_extra_info::RtcEngineConfig>,
    #[prost(message, repeated, tag = "2")]
    pub live_rtc_video_param_list: ::prost::alloc::vec::Vec<
        rtc_extra_info::RtcLiveVideoParam,
    >,
    #[prost(message, optional, tag = "3")]
    pub rtc_bitrate_map: ::core::option::Option<rtc_extra_info::RtcBitrateMap>,
    #[prost(int32, tag = "4")]
    pub rtc_fps: i32,
    #[prost(message, optional, tag = "5")]
    pub rtc_mix_base: ::core::option::Option<rtc_extra_info::RtcMixBase>,
    #[prost(message, optional, tag = "6")]
    pub byte_rtc_ext_info: ::core::option::Option<rtc_extra_info::ByteRtcExtInfo>,
    #[prost(message, optional, tag = "7")]
    pub rtc_info_extra: ::core::option::Option<rtc_extra_info::RtcInfoExtra>,
    #[prost(string, tag = "8")]
    pub rtc_business_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "9")]
    pub rtc_other: ::core::option::Option<rtc_extra_info::RtcOther>,
    #[prost(int32, tag = "10")]
    pub interact_client_type: i32,
}
/// Nested message and enum types in `RTCExtraInfo`.
pub mod rtc_extra_info {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RtcMixBase {
        #[prost(int32, tag = "1")]
        pub bitrate: i32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ByteRtcExtInfo {
        #[prost(int32, tag = "1")]
        pub default_signaling: i32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RtcInfoExtra {
        #[prost(string, tag = "1")]
        pub version: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RtcOther {
        #[prost(int32, tag = "1")]
        pub trans_coding_second: i32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RtcEngineConfig {
        #[prost(string, tag = "1")]
        pub rtc_app_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub rtc_user_id: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub rtc_token: ::prost::alloc::string::String,
        #[prost(int64, tag = "4")]
        pub rtc_channel_id: i64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RtcLiveVideoParam {
        #[prost(int32, tag = "1")]
        pub strategy_id: i32,
        #[prost(message, optional, tag = "2")]
        pub params: ::core::option::Option<RtcVideoParam>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RtcVideoParam {
        #[prost(int32, tag = "1")]
        pub width: i32,
        #[prost(int32, tag = "2")]
        pub height: i32,
        #[prost(int32, tag = "3")]
        pub fps: i32,
        #[prost(int32, tag = "4")]
        pub bitrate_kbps: i32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RtcBitrateMap {
        #[prost(int32, tag = "1")]
        pub xx1: i32,
        #[prost(int32, tag = "2")]
        pub xx2: i32,
        #[prost(int32, tag = "3")]
        pub xx3: i32,
        #[prost(int32, tag = "4")]
        pub xx4: i32,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateChannelContent {
    #[prost(message, optional, tag = "1")]
    pub owner: ::core::option::Option<Player>,
    #[prost(string, tag = "2")]
    pub owner_link_mic_id: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListChangeContent {
    #[prost(int32, tag = "1")]
    pub list_change_type: i32,
    #[prost(message, optional, tag = "2")]
    pub user_list: ::core::option::Option<AllListUser>,
    #[prost(string, repeated, tag = "3")]
    pub linked_user_ui_positions: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(message, repeated, tag = "4")]
    pub content_pos: ::prost::alloc::vec::Vec<ContentPosition>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContentPosition {
    #[prost(string, tag = "1")]
    pub content_i_d: ::prost::alloc::string::String,
    #[prost(enumeration = "ContentPositionType", tag = "2")]
    pub content_type: i32,
    #[prost(message, optional, tag = "3")]
    pub pos: ::core::option::Option<MicPositionData>,
    #[prost(string, tag = "4")]
    pub content_linkmic_i_d: ::prost::alloc::string::String,
    #[prost(int64, tag = "5")]
    pub start_time_nano: i64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MicPositionData {
    #[prost(int32, tag = "1")]
    pub r#type: i32,
    #[prost(message, optional, tag = "2")]
    pub link_position: ::core::option::Option<LinkPosition>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultiLiveContent {
    #[prost(message, optional, tag = "1")]
    pub apply_biz_content: ::core::option::Option<multi_live_content::ApplyBizContent>,
    #[prost(message, optional, tag = "2")]
    pub invite_biz_content: ::core::option::Option<multi_live_content::InviteBizContent>,
    #[prost(message, optional, tag = "3")]
    pub reply_biz_content: ::core::option::Option<multi_live_content::ReplyBizContent>,
    #[prost(message, optional, tag = "4")]
    pub permit_biz_content: ::core::option::Option<multi_live_content::PermitBizContent>,
    #[prost(message, optional, tag = "5")]
    pub join_direct_biz_content: ::core::option::Option<
        multi_live_content::JoinDirectBizContent,
    >,
    #[prost(message, optional, tag = "6")]
    pub kick_out_biz_content: ::core::option::Option<
        multi_live_content::KickOutBizContent,
    >,
}
/// Nested message and enum types in `MultiLiveContent`.
pub mod multi_live_content {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ApplyBizContent {
        #[prost(message, optional, tag = "1")]
        pub user: ::core::option::Option<super::User>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct JoinDirectBizContent {
        #[prost(int64, tag = "1")]
        pub reply_im_msg_id: i64,
        #[prost(enumeration = "super::MultiGuestOutsideRoomInviteSource", tag = "2")]
        pub outside_room_invite_source: i32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InviteBizContent {
        #[prost(message, optional, tag = "1")]
        pub anchor_setting_info: ::core::option::Option<
            super::MultiLiveAnchorPanelSettings,
        >,
        #[prost(enumeration = "super::ContentInviteSource", tag = "2")]
        pub invite_source: i32,
        #[prost(message, optional, tag = "3")]
        pub operator_user_info: ::core::option::Option<super::User>,
        #[prost(enumeration = "super::LinkMicUserAdminType", tag = "4")]
        pub operator_link_admin_type: i32,
        #[prost(message, optional, tag = "5")]
        pub invitee_user_info: ::core::option::Option<super::User>,
        #[prost(enumeration = "super::LinkmicShareRevenueSetting", tag = "6")]
        pub share_revenue_setting: i32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ReplyBizContent {
        #[prost(int32, tag = "1")]
        pub link_type: i32,
        #[prost(int32, tag = "2")]
        pub is_turn_off_invitation: i32,
        #[prost(message, optional, tag = "3")]
        pub reply_user_info: ::core::option::Option<super::User>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PermitBizContent {
        #[prost(message, optional, tag = "1")]
        pub anchor_setting_info: ::core::option::Option<
            super::MultiLiveAnchorPanelSettings,
        >,
        #[prost(int64, tag = "2")]
        pub expire_timestamp: i64,
        #[prost(message, optional, tag = "3")]
        pub operator_user_info: ::core::option::Option<super::User>,
        #[prost(enumeration = "super::LinkMicUserAdminType", tag = "4")]
        pub operator_link_admin_type: i32,
        #[prost(enumeration = "super::LinkUserType", tag = "5")]
        pub link_user_type: i32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KickOutBizContent {
        #[prost(message, optional, tag = "1")]
        pub operator_user_info: ::core::option::Option<super::User>,
        #[prost(enumeration = "super::LinkMicUserAdminType", tag = "2")]
        pub operator_link_admin_type: i32,
        #[prost(message, optional, tag = "3")]
        pub kick_player_user_info: ::core::option::Option<super::User>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InviteContent {
    #[prost(message, optional, tag = "1")]
    pub invitor: ::core::option::Option<Player>,
    #[prost(message, optional, tag = "2")]
    pub invitee_rtc_ext_info: ::core::option::Option<RtcExtraInfo>,
    #[prost(string, tag = "3")]
    pub invitor_link_mic_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub invitee_link_mic_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub is_owner: bool,
    #[prost(message, optional, tag = "6")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, optional, tag = "7")]
    pub dsl: ::core::option::Option<DslConfig>,
    #[prost(message, optional, tag = "8")]
    pub invitee: ::core::option::Option<User>,
    #[prost(message, optional, tag = "9")]
    pub operator: ::core::option::Option<User>,
}
/// @ApplyContent
/// proto.webcast.im
/// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyContent {
    #[prost(message, optional, tag = "1")]
    pub applier: ::core::option::Option<Player>,
    #[prost(string, tag = "2")]
    pub applier_link_mic_id: ::prost::alloc::string::String,
}
/// @PermitApplyContent
/// proto.webcast.im
/// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PermitApplyContent {
    #[prost(message, optional, tag = "1")]
    pub permiter: ::core::option::Option<Player>,
    #[prost(string, tag = "2")]
    pub permiter_link_mic_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub applier_pos: ::core::option::Option<Position>,
    /// Enum
    #[prost(enumeration = "ReplyStatus", tag = "4")]
    pub reply_status: i32,
    #[prost(message, optional, tag = "5")]
    pub dsl: ::core::option::Option<DslConfig>,
    #[prost(message, optional, tag = "6")]
    pub applier: ::core::option::Option<User>,
    #[prost(message, optional, tag = "7")]
    pub operator: ::core::option::Option<User>,
    #[prost(string, tag = "8")]
    pub applier_link_mic_id: ::prost::alloc::string::String,
}
/// @ReplyInviteContent
/// proto.webcast.im
/// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReplyInviteContent {
    #[prost(message, optional, tag = "1")]
    pub invitee: ::core::option::Option<Player>,
    #[prost(enumeration = "ReplyStatus", tag = "2")]
    pub reply_status: i32,
    #[prost(string, tag = "3")]
    pub invitee_link_mic_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub invitee_pos: ::core::option::Option<Position>,
    #[prost(message, optional, tag = "5")]
    pub invite_operator_user: ::core::option::Option<Player>,
    #[prost(string, repeated, tag = "6")]
    pub linked_user_ui_positions: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(message, repeated, tag = "7")]
    pub ui_pos: ::prost::alloc::vec::Vec<PosIdentity>,
}
/// @KickOutContent
/// proto.webcast.im
/// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KickOutContent {
    #[prost(message, optional, tag = "1")]
    pub offliner: ::core::option::Option<Player>,
    #[prost(enumeration = "KickoutReason", tag = "2")]
    pub kickout_reason: i32,
    #[prost(string, repeated, tag = "3")]
    pub linked_user_ui_positions: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(message, repeated, tag = "4")]
    pub ui_pos: ::prost::alloc::vec::Vec<PosIdentity>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PosIdentity {
    #[prost(enumeration = "PosIdentityType", tag = "1")]
    pub r#type: i32,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
/// @CancelApplyContent
/// proto.webcast.im
/// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelApplyContent {
    #[prost(message, optional, tag = "1")]
    pub applier: ::core::option::Option<Player>,
    #[prost(string, tag = "2")]
    pub applier_link_mic_id: ::prost::alloc::string::String,
}
/// @CancelInviteContent
/// proto.webcast.im
/// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelInviteContent {
    #[prost(message, optional, tag = "1")]
    pub invitor: ::core::option::Option<Player>,
    #[prost(string, tag = "2")]
    pub invitor_link_mic_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub invitee_link_mic_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub invite_seq_id: i64,
    #[prost(message, optional, tag = "5")]
    pub invitee: ::core::option::Option<Player>,
}
/// @LeaveContent
/// proto.webcast.im
/// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaveContent {
    #[prost(message, optional, tag = "1")]
    pub leaver: ::core::option::Option<Player>,
    #[prost(int64, tag = "2")]
    pub leave_reason: i64,
    #[prost(string, repeated, tag = "3")]
    pub linked_user_ui_positions: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(message, repeated, tag = "4")]
    pub ui_pos: ::prost::alloc::vec::Vec<PosIdentity>,
}
/// @FinishChannelContent
/// proto.webcast.im
/// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FinishChannelContent {
    #[prost(message, optional, tag = "1")]
    pub owner: ::core::option::Option<Player>,
    #[prost(int64, tag = "2")]
    pub finish_reason: i64,
}
/// @JoinDirectContent
/// proto.webcast.im
/// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JoinDirectContent {
    #[prost(message, optional, tag = "1")]
    pub joiner: ::core::option::Option<LinkLayerListUser>,
    #[prost(message, optional, tag = "2")]
    pub all_users: ::core::option::Option<AllListUser>,
}
/// @LeaveJoinGroupContent
/// proto.webcast.im
/// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaveJoinGroupContent {
    #[prost(message, optional, tag = "1")]
    pub operator: ::core::option::Option<GroupPlayer>,
    #[prost(int64, tag = "2")]
    pub group_channel_id: i64,
    #[prost(string, tag = "3")]
    pub leave_source: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub linked_user_ui_positions: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
/// @PermitJoinGroupContent
/// proto.webcast.im
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PermitJoinGroupContent {
    #[prost(message, optional, tag = "1")]
    pub approver: ::core::option::Option<GroupPlayer>,
    #[prost(enumeration = "AgreeStatus", tag = "2")]
    pub agree_status: i32,
    #[prost(enumeration = "JoinType", tag = "3")]
    pub r#type: i32,
    #[prost(message, repeated, tag = "4")]
    pub group_ext_info_list: ::prost::alloc::vec::Vec<RtcExtraInfo>,
    #[prost(message, optional, tag = "5")]
    pub group_user: ::core::option::Option<GroupChannelAllUser>,
    #[prost(message, optional, tag = "6")]
    pub migration_details: ::core::option::Option<MigrationDetails>,
    #[prost(string, repeated, tag = "7")]
    pub linked_user_ui_positions: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrationDetails {
    #[prost(bool, tag = "1")]
    pub is_migrate: bool,
    #[prost(int64, tag = "2")]
    pub source_group_channel_id: i64,
    #[prost(int64, tag = "3")]
    pub target_group_channel_id: i64,
}
/// @CancelJoinGroupContent
/// proto.webcast.im
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelJoinGroupContent {
    #[prost(message, repeated, tag = "1")]
    pub leaver_list: ::prost::alloc::vec::Vec<GroupPlayer>,
    #[prost(message, optional, tag = "2")]
    pub operator: ::core::option::Option<GroupPlayer>,
    #[prost(enumeration = "JoinType", tag = "3")]
    pub r#type: i32,
    #[prost(message, optional, tag = "4")]
    pub group_user: ::core::option::Option<GroupChannelAllUser>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct P2pGroupChangeContent {
    #[prost(message, repeated, tag = "1")]
    pub group_ext_info_list: ::prost::alloc::vec::Vec<RtcExtraInfo>,
    #[prost(message, optional, tag = "2")]
    pub group_user: ::core::option::Option<GroupChannelAllUser>,
    #[prost(message, optional, tag = "3")]
    pub migration_details: ::core::option::Option<MigrationDetails>,
    #[prost(message, repeated, tag = "4")]
    pub content_pos: ::prost::alloc::vec::Vec<ContentPosition>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupChangeContent {
    #[prost(message, optional, tag = "1")]
    pub group_user: ::core::option::Option<GroupChannelAllUser>,
    #[prost(string, repeated, tag = "2")]
    pub linked_user_ui_positions: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BusinessContent {
    #[prost(int64, tag = "1")]
    pub over_length: i64,
    #[prost(message, optional, tag = "100")]
    pub multi_live_content: ::core::option::Option<MultiLiveContent>,
    #[prost(message, optional, tag = "200")]
    pub cohost_content: ::core::option::Option<business_content::CohostContent>,
}
/// Nested message and enum types in `BusinessContent`.
pub mod business_content {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CohostContent {
        #[prost(message, optional, tag = "1")]
        pub join_group_biz_content: ::core::option::Option<JoinGroupBizContent>,
        #[prost(message, optional, tag = "2")]
        pub permit_join_group_biz_content: ::core::option::Option<
            PermitJoinGroupBizContent,
        >,
        #[prost(message, optional, tag = "11")]
        pub list_change_biz_content: ::core::option::Option<ListChangeBizContent>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PermitJoinGroupBizContent {
        #[prost(enumeration = "super::ReplyStatus", tag = "1")]
        pub reply_status: i32,
        #[prost(enumeration = "super::SourceType", tag = "2")]
        pub source_type: i32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListChangeBizContent {
        #[prost(map = "int64, message", tag = "1")]
        pub user_infos: ::std::collections::HashMap<i64, CohostUserInfo>,
        #[prost(message, repeated, tag = "2")]
        pub waiting_users: ::prost::alloc::vec::Vec<
            list_change_biz_content::VirtualWaitingUser,
        >,
    }
    /// Nested message and enum types in `ListChangeBizContent`.
    pub mod list_change_biz_content {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct VirtualWaitingUser {
            #[prost(int64, tag = "1")]
            pub user_id: i64,
            #[prost(int64, tag = "2")]
            pub timestamp: i64,
            #[prost(message, repeated, tag = "3")]
            pub avatars: ::prost::alloc::vec::Vec<super::super::Image>,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CohostUserInfo {
        #[prost(int64, tag = "1")]
        pub permission_type: i64,
        #[prost(enumeration = "super::SourceType", tag = "2")]
        pub source_type: i32,
        #[prost(bool, tag = "3")]
        pub is_low_version: bool,
        #[prost(int64, tag = "4")]
        pub best_teammate_uid: i64,
        #[prost(bool, tag = "5")]
        pub has_topic_perm: bool,
        #[prost(message, optional, tag = "6")]
        pub stream_config: ::core::option::Option<cohost_user_info::CohostStreamConfig>,
        #[prost(bool, tag = "7")]
        pub in_different_invite_type_control_group: bool,
        #[prost(string, tag = "11")]
        pub nickname: ::prost::alloc::string::String,
        #[prost(string, tag = "12")]
        pub display_id: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "13")]
        pub avatar_thumb: ::core::option::Option<super::Image>,
        #[prost(int64, tag = "14")]
        pub follow_status: i64,
        #[prost(string, tag = "15")]
        pub user_id_str: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `CohostUserInfo`.
    pub mod cohost_user_info {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CohostStreamConfig {
            #[prost(string, tag = "1")]
            pub screen_share_stream_id: ::prost::alloc::string::String,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct JoinGroupBizContent {
        #[prost(int32, tag = "1")]
        pub from_room_age_restricted: i32,
        #[prost(message, optional, tag = "2")]
        pub from_tag: ::core::option::Option<Tag>,
        #[prost(message, optional, tag = "3")]
        pub dialog: ::core::option::Option<PerceptionDialogInfo>,
        #[prost(message, optional, tag = "4")]
        pub punish_info: ::core::option::Option<super::PunishEventInfo>,
        #[prost(message, optional, tag = "5")]
        pub topic_info: ::core::option::Option<super::CohostTopic>,
        #[prost(string, tag = "6")]
        pub algo_request_id: ::prost::alloc::string::String,
        #[prost(enumeration = "super::CohostLayoutMode", tag = "7")]
        pub cohost_layout_mode: i32,
        #[prost(message, optional, tag = "8")]
        pub tag: ::core::option::Option<join_group_biz_content::TagV2>,
        #[prost(message, optional, tag = "9")]
        pub game_tag: ::core::option::Option<join_group_biz_content::RivalsGameTag>,
        #[prost(string, tag = "11")]
        pub new_user_education: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "101")]
        pub join_group_msg_extra: ::core::option::Option<JoinGroupMessageExtra>,
    }
    /// Nested message and enum types in `JoinGroupBizContent`.
    pub mod join_group_biz_content {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct RivalsGameTag {
            #[prost(int64, tag = "1")]
            pub tag_id: i64,
            #[prost(string, tag = "2")]
            pub tag_display_text: ::prost::alloc::string::String,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TagV2 {
            #[prost(enumeration = "super::super::TagClassification", tag = "1")]
            pub tag_classification: i32,
            #[prost(int32, tag = "2")]
            pub tag_type: i32,
            #[prost(string, tag = "3")]
            pub tag_value: ::prost::alloc::string::String,
            #[prost(string, tag = "4")]
            pub starling_key: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "10")]
            pub second_degree_relation_content: ::core::option::Option<
                tag_v2::SecondDegreeRelationContent,
            >,
            #[prost(int64, tag = "11")]
            pub cohost_history_day: i64,
            #[prost(message, optional, tag = "12")]
            pub similar_interest_content: ::core::option::Option<
                tag_v2::SimilarInterestContent,
            >,
        }
        /// Nested message and enum types in `TagV2`.
        pub mod tag_v2 {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct UserInfo {
                #[prost(int64, tag = "1")]
                pub user_id: i64,
                #[prost(string, tag = "2")]
                pub nick_name: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub avatar_thumb: ::core::option::Option<super::super::super::Image>,
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct SecondDegreeRelationContent {
                #[prost(message, repeated, tag = "1")]
                pub related_users: ::prost::alloc::vec::Vec<UserInfo>,
                #[prost(int64, tag = "2")]
                pub total_related_user_cnt: i64,
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct SimilarInterestContent {
                #[prost(int64, tag = "1")]
                pub content_id: i64,
                #[prost(string, tag = "2")]
                pub display_text: ::prost::alloc::string::String,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Tag {
        #[prost(int32, tag = "1")]
        pub tag_type: i32,
        #[prost(string, tag = "2")]
        pub tag_value: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub tag_text: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PerceptionDialogInfo {
        /// @warning Enum not found, should be IconType
        #[prost(int64, tag = "1")]
        pub icon_type: i64,
        #[prost(message, optional, tag = "2")]
        pub title: ::core::option::Option<super::Text>,
        #[prost(message, optional, tag = "3")]
        pub sub_title: ::core::option::Option<super::Text>,
        #[prost(message, optional, tag = "4")]
        pub advice_action_text: ::core::option::Option<super::Text>,
        #[prost(message, optional, tag = "5")]
        pub default_action_text: ::core::option::Option<super::Text>,
        #[prost(string, tag = "6")]
        pub violation_detail_url: ::prost::alloc::string::String,
        #[prost(int32, tag = "7")]
        pub scene: i32,
        #[prost(int64, tag = "8")]
        pub target_user_id: i64,
        #[prost(int64, tag = "9")]
        pub target_room_id: i64,
        #[prost(int64, tag = "10")]
        pub count_down_time: i64,
        #[prost(bool, tag = "11")]
        pub show_feedback: bool,
        #[prost(message, repeated, tag = "12")]
        pub feedback_options_list: ::prost::alloc::vec::Vec<PerceptionFeedbackOption>,
        #[prost(int64, tag = "13")]
        pub policy_tip: i64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PerceptionFeedbackOption {
        #[prost(int64, tag = "1")]
        pub id: i64,
        #[prost(string, tag = "2")]
        pub content_key: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct JoinGroupMessageExtra {
        #[prost(int64, tag = "1")]
        pub source_type: i64,
        #[prost(message, optional, tag = "2")]
        pub extra: ::core::option::Option<join_group_message_extra::RivalExtra>,
        #[prost(message, repeated, tag = "3")]
        pub other_users_list: ::prost::alloc::vec::Vec<
            join_group_message_extra::RivalExtra,
        >,
    }
    /// Nested message and enum types in `JoinGroupMessageExtra`.
    pub mod join_group_message_extra {
        /// @RivalExtra
        /// proto.webcast.im.JoinGroupMessageExtra
        /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct RivalExtra {
            #[prost(int64, tag = "4")]
            pub user_count: i64,
            #[prost(message, optional, tag = "5")]
            pub avatar_thumb: ::core::option::Option<super::super::Image>,
            #[prost(string, tag = "6")]
            pub display_id: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "7")]
            pub authentication_info: ::core::option::Option<
                rival_extra::AuthenticationInfo,
            >,
            #[prost(string, tag = "8")]
            pub nickname: ::prost::alloc::string::String,
            #[prost(int64, tag = "9")]
            pub follow_status: i64,
            #[prost(message, optional, tag = "10")]
            pub hashtag: ::core::option::Option<super::Hashtag>,
            #[prost(message, optional, tag = "11")]
            pub top_host_info: ::core::option::Option<super::TopHostInfo>,
            #[prost(int64, tag = "12")]
            pub user_id: i64,
            #[prost(bool, tag = "13")]
            pub is_best_teammate: bool,
        }
        /// Nested message and enum types in `RivalExtra`.
        pub mod rival_extra {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct AuthenticationInfo {
                #[prost(string, tag = "1")]
                pub custom_verify: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub enterprise_verify_reason: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub authentication_badge: ::core::option::Option<
                    super::super::super::Image,
                >,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Hashtag {
        #[prost(int64, tag = "1")]
        pub id: i64,
        #[prost(string, tag = "2")]
        pub title: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub image: ::core::option::Option<super::Image>,
        #[prost(enumeration = "super::HashtagNamespace", tag = "4")]
        pub namespace: i32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TopHostInfo {
        #[prost(string, tag = "1")]
        pub rank_type: ::prost::alloc::string::String,
        #[prost(int64, tag = "2")]
        pub top_index: i64,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JoinGroupContent {
    #[prost(message, optional, tag = "1")]
    pub group_user: ::core::option::Option<GroupChannelAllUser>,
    #[prost(message, optional, tag = "2")]
    pub join_user: ::core::option::Option<GroupPlayer>,
    #[prost(enumeration = "JoinType", tag = "3")]
    pub r#type: i32,
    #[prost(message, repeated, tag = "4")]
    pub group_ext_info: ::prost::alloc::vec::Vec<RtcExtraInfo>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivilegeLogExtra {
    #[prost(string, tag = "1")]
    pub data_version: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub privilege_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub privilege_version: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub privilege_order_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub level: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FontStyle {
    #[prost(int32, tag = "1")]
    pub font_size: i32,
    #[prost(int32, tag = "2")]
    pub font_width: i32,
    #[prost(string, tag = "3")]
    pub font_color: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub border_color: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserHonor {
    #[prost(int64, tag = "1")]
    pub total_diamond: i64,
    #[prost(message, optional, tag = "2")]
    pub diamond_icon: ::core::option::Option<Image>,
    #[prost(string, tag = "3")]
    pub current_honor_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub current_honor_icon: ::core::option::Option<Image>,
    #[prost(string, tag = "5")]
    pub next_honor_name: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub level: i32,
    #[prost(message, optional, tag = "7")]
    pub next_honor_icon: ::core::option::Option<Image>,
    #[prost(int64, tag = "9")]
    pub current_diamond: i64,
    #[prost(int64, tag = "10")]
    pub this_grade_min_diamond: i64,
    #[prost(int64, tag = "11")]
    pub this_grade_max_diamond: i64,
    #[prost(string, tag = "13")]
    pub grade_describe: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "14")]
    pub grade_icon_list: ::prost::alloc::vec::Vec<GradeIcon>,
    #[prost(int64, tag = "15")]
    pub screen_chat_type: i64,
    #[prost(message, optional, tag = "16")]
    pub im_icon: ::core::option::Option<Image>,
    #[prost(message, optional, tag = "17")]
    pub im_icon_with_level: ::core::option::Option<Image>,
    #[prost(message, optional, tag = "18")]
    pub live_icon: ::core::option::Option<Image>,
    #[prost(message, optional, tag = "19")]
    pub new_im_icon_with_level: ::core::option::Option<Image>,
    #[prost(message, optional, tag = "20")]
    pub new_live_icon: ::core::option::Option<Image>,
    #[prost(int64, tag = "21")]
    pub upgrade_need_consume: i64,
    #[prost(string, tag = "22")]
    pub next_privileges: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "23")]
    pub profile_dialog_bg: ::core::option::Option<Image>,
    #[prost(message, optional, tag = "24")]
    pub profile_dialog_back_bg: ::core::option::Option<Image>,
    #[prost(int64, tag = "25")]
    pub score: i64,
    #[prost(string, tag = "1001")]
    pub grade_banner: ::prost::alloc::string::String,
}
/// @GradeIcon
/// proto.webcast.data.User.PayGrade
/// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GradeIcon {
    #[prost(message, optional, tag = "1")]
    pub icon: ::core::option::Option<Image>,
    #[prost(int64, tag = "2")]
    pub icon_diamond: i64,
    #[prost(int64, tag = "3")]
    pub level: i64,
    #[prost(string, tag = "4")]
    pub level_str: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BorderInfo {
    #[prost(message, optional, tag = "1")]
    pub icon: ::core::option::Option<Image>,
    #[prost(int64, tag = "2")]
    pub level: i64,
    #[prost(string, tag = "3")]
    pub source: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub profile_decoration_ribbon: ::core::option::Option<Image>,
    #[prost(message, optional, tag = "5")]
    pub border_log_extra: ::core::option::Option<PrivilegeLogExtra>,
    #[prost(message, optional, tag = "6")]
    pub ribbon_log_extra: ::core::option::Option<PrivilegeLogExtra>,
    #[prost(string, tag = "7")]
    pub avatar_background_color: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub avatar_background_border_color: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FansClubMember {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<FansClubData>,
    #[prost(map = "int32, message", tag = "2")]
    pub prefer_data: ::std::collections::HashMap<i32, FansClubData>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FansClubData {
    #[prost(string, tag = "1")]
    pub club_name: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub level: i32,
    #[prost(int32, tag = "3")]
    pub user_fans_club_status: i32,
    #[prost(message, optional, tag = "4")]
    pub badge: ::core::option::Option<fans_club_data::UserBadge>,
    #[prost(int64, repeated, tag = "5")]
    pub available_gift_ids: ::prost::alloc::vec::Vec<i64>,
    #[prost(int64, tag = "6")]
    pub anchor_id: i64,
}
/// Nested message and enum types in `FansClubData`.
pub mod fans_club_data {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UserBadge {
        #[prost(map = "int32, message", tag = "1")]
        pub icons: ::std::collections::HashMap<i32, super::Image>,
        #[prost(string, tag = "2")]
        pub title: ::prost::alloc::string::String,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Author {
    #[prost(int64, tag = "1")]
    pub video_total_count: i64,
    #[prost(int64, tag = "2")]
    pub video_total_play_count: i64,
    #[prost(int64, tag = "6")]
    pub video_total_favorite_count: i64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicAreaCommon {
    #[prost(message, optional, tag = "1")]
    pub user_label: ::core::option::Option<Image>,
    #[prost(int64, tag = "2")]
    pub user_consume_in_room: i64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicAreaMessageCommon {
    #[prost(int64, tag = "1")]
    pub scroll_gap_count: i64,
    #[prost(int64, tag = "2")]
    pub anchor_scroll_gap_count: i64,
    #[prost(bool, tag = "3")]
    pub release_to_scroll_area: bool,
    #[prost(bool, tag = "4")]
    pub anchor_release_to_scroll_area: bool,
    #[prost(bool, tag = "5")]
    pub is_anchor_marked: bool,
    #[prost(message, optional, tag = "6")]
    pub creator_success_info: ::core::option::Option<
        public_area_message_common::CreatorSuccessInfo,
    >,
    #[prost(message, optional, tag = "7")]
    pub portrait_info: ::core::option::Option<public_area_message_common::PortraitInfo>,
    #[prost(message, optional, tag = "8")]
    pub user_interaction_info: ::core::option::Option<
        public_area_message_common::UserInteractionInfo,
    >,
    #[prost(int64, tag = "9")]
    pub admin_fold_type: i64,
}
/// Nested message and enum types in `PublicAreaMessageCommon`.
pub mod public_area_message_common {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TagItem {
        #[prost(enumeration = "super::TagType", tag = "1")]
        pub tag_type: i32,
        #[prost(message, optional, tag = "2")]
        pub tag_text: ::core::option::Option<super::Text>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Topic {
        #[prost(enumeration = "super::TopicActionType", tag = "1")]
        pub topic_action_type: i32,
        #[prost(message, optional, tag = "2")]
        pub topic_text: ::core::option::Option<super::Text>,
        #[prost(message, optional, tag = "3")]
        pub topic_tips: ::core::option::Option<super::Text>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CreatorSuccessInfo {
        #[prost(message, repeated, tag = "1")]
        pub tags: ::prost::alloc::vec::Vec<TagItem>,
        #[prost(message, optional, tag = "2")]
        pub topic: ::core::option::Option<Topic>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UserMetrics {
        #[prost(enumeration = "super::UserMetricsType", tag = "1")]
        pub r#type: i32,
        #[prost(string, tag = "2")]
        pub metrics_value: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PortraitTag {
        #[prost(string, tag = "1")]
        pub tag_id: ::prost::alloc::string::String,
        #[prost(int64, tag = "2")]
        pub priority: i64,
        #[prost(string, tag = "3")]
        pub show_value: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub show_args: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PortraitInfo {
        #[prost(message, repeated, tag = "1")]
        pub user_metrics: ::prost::alloc::vec::Vec<UserMetrics>,
        #[prost(message, repeated, tag = "2")]
        pub portrait_tag: ::prost::alloc::vec::Vec<PortraitTag>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UserInteractionInfo {
        #[prost(int64, tag = "1")]
        pub like_cnt: i64,
        #[prost(int64, tag = "2")]
        pub comment_cnt: i64,
        #[prost(int64, tag = "3")]
        pub share_cnt: i64,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GiftModeMeta {
    #[prost(int64, tag = "1")]
    pub gift_id: i64,
    #[prost(string, tag = "2")]
    pub gift_name_key: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub gift_icon_image: ::core::option::Option<Image>,
    #[prost(message, optional, tag = "4")]
    pub gift_mode_desc: ::core::option::Option<Text>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BattleTeamUser {
    #[prost(int64, tag = "1")]
    pub user_id: i64,
    #[prost(int64, tag = "2")]
    pub score: i64,
    #[prost(string, tag = "3")]
    pub user_id_str: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BattleSetting {
    #[prost(int64, tag = "1")]
    pub battle_id: i64,
    #[prost(int64, tag = "2")]
    pub start_time_ms: i64,
    #[prost(int32, tag = "3")]
    pub duration: i32,
    #[prost(int64, tag = "4")]
    pub channel_id: i64,
    #[prost(int32, tag = "5")]
    pub status: i32,
    #[prost(enumeration = "BattleInviteType", tag = "6")]
    pub invite_type: i32,
    #[prost(message, optional, tag = "7")]
    pub gift_mode_meta: ::core::option::Option<GiftModeMeta>,
    #[prost(enumeration = "BattleType", tag = "8")]
    pub battle_type: i32,
    #[prost(int64, tag = "9")]
    pub extra_duration_second: i64,
    #[prost(int64, tag = "10")]
    pub end_time_ms: i64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BattleTeamUserArmies {
    #[prost(int64, tag = "1")]
    pub team_id: i64,
    #[prost(message, repeated, tag = "2")]
    pub team_users: ::prost::alloc::vec::Vec<BattleTeamUser>,
    #[prost(int64, tag = "3")]
    pub team_total_score: i64,
    #[prost(message, optional, tag = "4")]
    pub user_armies: ::core::option::Option<BattleUserArmies>,
    #[prost(int64, tag = "5")]
    pub host_rank: i64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BattleUserArmies {
    #[prost(message, repeated, tag = "1")]
    pub user_army: ::prost::alloc::vec::Vec<BattleUserArmy>,
    #[prost(int64, tag = "2")]
    pub host_score: i64,
    #[prost(string, tag = "3")]
    pub anchor_id_str: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BattleUserArmy {
    #[prost(int64, tag = "1")]
    pub user_id: i64,
    #[prost(int64, tag = "2")]
    pub score: i64,
    #[prost(string, tag = "3")]
    pub nickname: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub avatar_thumb: ::core::option::Option<Image>,
    #[prost(int64, tag = "5")]
    pub diamond_score: i64,
    #[prost(string, tag = "6")]
    pub user_id_str: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HighScoreControlCfg {
    #[prost(bool, tag = "1")]
    pub normal_control_applied: bool,
    #[prost(int64, tag = "2")]
    pub threshold: i64,
    #[prost(int64, repeated, tag = "3")]
    pub origin_display_to_user_list: ::prost::alloc::vec::Vec<i64>,
}
/// Heartbeat message
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HeartbeatMessage {
    #[prost(uint64, tag = "1")]
    pub room_id: u64,
}
/// Incoming & outbound messages
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastPushFrame {
    #[prost(int64, tag = "1")]
    pub seq_id: i64,
    #[prost(int64, tag = "2")]
    pub log_id: i64,
    #[prost(int64, tag = "3")]
    pub service: i64,
    #[prost(int64, tag = "4")]
    pub method: i64,
    #[prost(map = "string, string", tag = "5")]
    pub headers: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "6")]
    pub payload_encoding: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub payload_type: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "8")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Message {
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub binary: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebsocketParam {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastRoomUserSeqMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(int32, tag = "3")]
    pub viewer_count: i32,
    #[prost(message, repeated, tag = "2")]
    pub ranks_list: ::prost::alloc::vec::Vec<webcast_room_user_seq_message::Contributor>,
    #[prost(string, tag = "4")]
    pub pop_str: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub seats_list: ::prost::alloc::vec::Vec<webcast_room_user_seq_message::Contributor>,
    #[prost(int64, tag = "6")]
    pub popularity: i64,
    #[prost(int32, tag = "7")]
    pub total_user: i32,
    #[prost(int64, tag = "8")]
    pub anonymous: i64,
}
/// Nested message and enum types in `WebcastRoomUserSeqMessage`.
pub mod webcast_room_user_seq_message {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Contributor {
        #[prost(int32, tag = "1")]
        pub coin_count: i32,
        #[prost(message, optional, tag = "2")]
        pub user: ::core::option::Option<super::User>,
        #[prost(int32, tag = "3")]
        pub rank: i32,
        #[prost(int64, tag = "4")]
        pub delta: i64,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageModel {
    #[prost(string, repeated, tag = "1")]
    pub m_urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub m_uri: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub height: i32,
    #[prost(int32, tag = "4")]
    pub width: i32,
    #[prost(string, tag = "5")]
    pub avg_color: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub image_type: i32,
    #[prost(string, tag = "7")]
    pub schema: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "8")]
    pub content: ::core::option::Option<image_model::Content>,
    #[prost(bool, tag = "9")]
    pub is_animated: bool,
}
/// Nested message and enum types in `ImageModel`.
pub mod image_model {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Content {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub font_color: ::prost::alloc::string::String,
        #[prost(int64, tag = "3")]
        pub level: i64,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastChatMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(message, optional, tag = "2")]
    pub user: ::core::option::Option<User>,
    #[prost(string, tag = "3")]
    pub comment: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub visible_to_sender: bool,
    #[prost(message, optional, tag = "5")]
    pub background: ::core::option::Option<ImageModel>,
    #[prost(string, tag = "6")]
    pub full_screen_text_color: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub background_image_v2: ::core::option::Option<ImageModel>,
    #[prost(message, optional, tag = "9")]
    pub public_area_common: ::core::option::Option<PublicAreaCommon>,
    #[prost(message, optional, tag = "10")]
    pub gift_image: ::core::option::Option<ImageModel>,
    #[prost(int32, tag = "11")]
    pub input_type: i32,
    #[prost(message, optional, tag = "12")]
    pub at_user: ::core::option::Option<User>,
    #[prost(message, repeated, tag = "13")]
    pub emotes: ::prost::alloc::vec::Vec<WebcastSubEmote>,
    #[prost(string, tag = "14")]
    pub content_language: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "15")]
    pub msg_filter: ::core::option::Option<MsgFilter>,
    #[prost(int32, tag = "16")]
    pub quick_chat_scene: i32,
    #[prost(int32, tag = "17")]
    pub communityflagged_status: i32,
    #[prost(message, repeated, tag = "19")]
    pub comment_quality_scores: ::prost::alloc::vec::Vec<
        webcast_chat_message::CommentQualityScore,
    >,
    #[prost(message, optional, tag = "18")]
    pub user_identity: ::core::option::Option<webcast_chat_message::UserIdentity>,
    #[prost(enumeration = "webcast_chat_message::CommentTag", repeated, tag = "20")]
    pub comment_tag: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, optional, tag = "21")]
    pub public_area_message_common: ::core::option::Option<PublicAreaMessageCommon>,
    #[prost(int64, tag = "22")]
    pub screen_time: i64,
    #[prost(string, tag = "23")]
    pub signature: ::prost::alloc::string::String,
    #[prost(string, tag = "24")]
    pub signature_version: ::prost::alloc::string::String,
    #[prost(string, tag = "25")]
    pub ec_streamer_key: ::prost::alloc::string::String,
}
/// Nested message and enum types in `WebcastChatMessage`.
pub mod webcast_chat_message {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UserIdentity {
        #[prost(bool, tag = "1")]
        pub is_gift_giver_of_anchor: bool,
        #[prost(bool, tag = "2")]
        pub is_subscriber_of_anchor: bool,
        #[prost(bool, tag = "3")]
        pub is_mutual_following_with_anchor: bool,
        #[prost(bool, tag = "4")]
        pub is_follower_of_anchor: bool,
        #[prost(bool, tag = "5")]
        pub is_moderator_of_anchor: bool,
        #[prost(bool, tag = "6")]
        pub is_anchor: bool,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CommentQualityScore {
        #[prost(string, tag = "1")]
        pub version: ::prost::alloc::string::String,
        #[prost(int64, tag = "2")]
        pub score: i64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CommentTag {
        Normal = 0,
        Candidate = 1,
        Overage = 2,
    }
    impl CommentTag {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CommentTag::Normal => "COMMENT_TAG_NORMAL",
                CommentTag::Candidate => "COMMENT_TAG_CANDIDATE",
                CommentTag::Overage => "COMMENT_TAG_OVERAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMMENT_TAG_NORMAL" => Some(Self::Normal),
                "COMMENT_TAG_CANDIDATE" => Some(Self::Candidate),
                "COMMENT_TAG_OVERAGE" => Some(Self::Overage),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmoteUploadInfo {
    #[prost(int64, tag = "1")]
    pub user_id: i64,
    #[prost(
        enumeration = "emote_upload_info::UserEmoteUploadSource",
        optional,
        tag = "2"
    )]
    pub emote_upload_source: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "3")]
    pub user_info: ::core::option::Option<User>,
    #[prost(string, tag = "4")]
    pub user_id_str: ::prost::alloc::string::String,
}
/// Nested message and enum types in `EmoteUploadInfo`.
pub mod emote_upload_info {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserEmoteUploadSource {
        EmoteUploadSourceAnchor = 0,
        EmoteUploadSourceSubscriber = 1,
        EmoteUploadSourceModerator = 2,
    }
    impl UserEmoteUploadSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UserEmoteUploadSource::EmoteUploadSourceAnchor => {
                    "USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_ANCHOR"
                }
                UserEmoteUploadSource::EmoteUploadSourceSubscriber => {
                    "USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_SUBSCRIBER"
                }
                UserEmoteUploadSource::EmoteUploadSourceModerator => {
                    "USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_MODERATOR"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_ANCHOR" => {
                    Some(Self::EmoteUploadSourceAnchor)
                }
                "USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_SUBSCRIBER" => {
                    Some(Self::EmoteUploadSourceSubscriber)
                }
                "USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_MODERATOR" => {
                    Some(Self::EmoteUploadSourceModerator)
                }
                _ => None,
            }
        }
    }
}
/// Chat Emotes (Subscriber)
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastEmoteChatMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(message, optional, tag = "2")]
    pub user: ::core::option::Option<User>,
    #[prost(message, repeated, tag = "3")]
    pub emote_list: ::prost::alloc::vec::Vec<Emote>,
    #[prost(message, optional, tag = "4")]
    pub msg_filter: ::core::option::Option<MsgFilter>,
    #[prost(message, optional, tag = "5")]
    pub user_identity: ::core::option::Option<UserIdentity>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastSubEmote {
    /// starting at 0, you insert the emote itself into the comment at that place
    #[prost(int32, tag = "1")]
    pub place_in_comment: i32,
    #[prost(message, optional, tag = "2")]
    pub emote: ::core::option::Option<EmoteDetails>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastMemberMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(message, optional, tag = "2")]
    pub user: ::core::option::Option<User>,
    #[prost(enumeration = "MemberMessageAction", tag = "10")]
    pub action: i32,
    #[prost(int32, tag = "3")]
    pub member_count: i32,
    #[prost(message, optional, tag = "4")]
    pub operator: ::core::option::Option<User>,
    #[prost(bool, tag = "5")]
    pub is_set_to_admin: bool,
    #[prost(bool, tag = "6")]
    pub is_top_user: bool,
    #[prost(int64, tag = "7")]
    pub rank_score: i64,
    #[prost(int64, tag = "8")]
    pub top_user_no: i64,
    #[prost(int64, tag = "9")]
    pub enter_type: i64,
    #[prost(string, tag = "11")]
    pub action_description: ::prost::alloc::string::String,
    #[prost(int64, tag = "12")]
    pub user_id: i64,
    #[prost(message, optional, tag = "13")]
    pub effect_config: ::core::option::Option<webcast_member_message::EffectConfig>,
    #[prost(string, tag = "14")]
    pub pop_str: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "15")]
    pub enter_effect_config: ::core::option::Option<
        webcast_member_message::EffectConfig,
    >,
    #[prost(message, optional, tag = "16")]
    pub background_image: ::core::option::Option<Image>,
    #[prost(message, optional, tag = "17")]
    pub background_image_v2: ::core::option::Option<Image>,
    #[prost(message, optional, tag = "18")]
    pub anchor_display_text: ::core::option::Option<Text>,
    #[prost(string, tag = "19")]
    pub client_enter_source: ::prost::alloc::string::String,
    #[prost(string, tag = "20")]
    pub client_enter_type: ::prost::alloc::string::String,
    #[prost(string, tag = "21")]
    pub client_live_reason: ::prost::alloc::string::String,
    #[prost(int64, tag = "22")]
    pub action_duration: i64,
    #[prost(string, tag = "23")]
    pub user_share_type: ::prost::alloc::string::String,
    #[prost(enumeration = "webcast_member_message::DisplayStyle", tag = "24")]
    pub display_style: i32,
    #[prost(map = "int32, int32", tag = "25")]
    pub admin_permissions: ::std::collections::HashMap<i32, i32>,
    #[prost(int32, tag = "26")]
    pub kick_source: i32,
    #[prost(int64, tag = "27")]
    pub allow_preview_time: i64,
    #[prost(int64, tag = "28")]
    pub last_subscription_action: i64,
    #[prost(message, optional, tag = "29")]
    pub public_area_message_common: ::core::option::Option<PublicAreaMessageCommon>,
    #[prost(int64, tag = "30")]
    pub live_sub_only_tier: i64,
    #[prost(int64, tag = "31")]
    pub live_sub_only_month: i64,
    #[prost(string, tag = "32")]
    pub ec_streamer_key: ::prost::alloc::string::String,
    #[prost(int64, tag = "33")]
    pub show_wave: i64,
    #[prost(message, optional, tag = "34")]
    pub wave_algorithm_data: ::core::option::Option<
        webcast_member_message::WaveAlgorithmData,
    >,
    #[prost(enumeration = "webcast_member_message::HitAbStatus", tag = "35")]
    pub hit_ab_status: i32,
}
/// Nested message and enum types in `WebcastMemberMessage`.
pub mod webcast_member_message {
    /// @EffectConfig
    /// proto.webcast.im.MemberMessage
    /// C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EffectConfig {
        #[prost(int64, tag = "1")]
        pub r#type: i64,
        #[prost(message, optional, tag = "2")]
        pub icon: ::core::option::Option<super::Image>,
        #[prost(int64, tag = "3")]
        pub avatar_pos: i64,
        #[prost(message, optional, tag = "4")]
        pub text: ::core::option::Option<super::Text>,
        #[prost(message, optional, tag = "5")]
        pub text_icon: ::core::option::Option<super::Image>,
        #[prost(int32, tag = "6")]
        pub stay_time: i32,
        #[prost(int64, tag = "7")]
        pub anim_asset_id: i64,
        #[prost(message, optional, tag = "8")]
        pub badge: ::core::option::Option<super::Image>,
        #[prost(int64, repeated, tag = "9")]
        pub flex_setting_array_list: ::prost::alloc::vec::Vec<i64>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WaveAlgorithmData {
        #[prost(string, tag = "1")]
        pub algorithm_version: ::prost::alloc::string::String,
        #[prost(bool, tag = "2")]
        pub is_alg_hit: bool,
        #[prost(string, tag = "3")]
        pub predict_score: ::prost::alloc::string::String,
        #[prost(bool, tag = "4")]
        pub is_rewatch: bool,
        #[prost(bool, tag = "5")]
        pub is_follow: bool,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EffectConfigBean {
        #[prost(int32, tag = "1")]
        pub r#type: i32,
        #[prost(message, optional, tag = "2")]
        pub icon: ::core::option::Option<super::ImageModel>,
        #[prost(message, optional, tag = "4")]
        pub text_key: ::core::option::Option<super::Text>,
        #[prost(message, optional, tag = "8")]
        pub badge: ::core::option::Option<super::ImageModel>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DisplayStyle {
        Normal = 0,
        Stay = 1,
        Chat = 2,
    }
    impl DisplayStyle {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DisplayStyle::Normal => "DISPLAY_STYLE_NORMAL",
                DisplayStyle::Stay => "DISPLAY_STYLE_STAY",
                DisplayStyle::Chat => "DISPLAY_STYLE_CHAT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DISPLAY_STYLE_NORMAL" => Some(Self::Normal),
                "DISPLAY_STYLE_STAY" => Some(Self::Stay),
                "DISPLAY_STYLE_CHAT" => Some(Self::Chat),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HitAbStatus {
        HitABStatusHitAbStatusNoHit = 0,
        HitABStatusHitAbStatusEnterFromExternalLinkNewText = 1,
        HitABStatusHitAbStatusEnterFromRePostNewText = 2,
    }
    impl HitAbStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                HitAbStatus::HitABStatusHitAbStatusNoHit => {
                    "HIT_A_B_STATUS_HIT_AB_STATUS_NO_HIT"
                }
                HitAbStatus::HitABStatusHitAbStatusEnterFromExternalLinkNewText => {
                    "HIT_A_B_STATUS_HIT_AB_STATUS_ENTER_FROM_EXTERNAL_LINK_NEW_TEXT"
                }
                HitAbStatus::HitABStatusHitAbStatusEnterFromRePostNewText => {
                    "HIT_A_B_STATUS_HIT_AB_STATUS_ENTER_FROM_RE_POST_NEW_TEXT"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "HIT_A_B_STATUS_HIT_AB_STATUS_NO_HIT" => {
                    Some(Self::HitABStatusHitAbStatusNoHit)
                }
                "HIT_A_B_STATUS_HIT_AB_STATUS_ENTER_FROM_EXTERNAL_LINK_NEW_TEXT" => {
                    Some(Self::HitABStatusHitAbStatusEnterFromExternalLinkNewText)
                }
                "HIT_A_B_STATUS_HIT_AB_STATUS_ENTER_FROM_RE_POST_NEW_TEXT" => {
                    Some(Self::HitABStatusHitAbStatusEnterFromRePostNewText)
                }
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastGiftMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(int32, tag = "2")]
    pub gift_id: i32,
    #[prost(message, optional, tag = "7")]
    pub user: ::core::option::Option<User>,
    #[prost(int32, tag = "9")]
    pub repeat_end: i32,
    #[prost(uint64, tag = "11")]
    pub group_id: u64,
    #[prost(message, optional, tag = "15")]
    pub gift_details: ::core::option::Option<Gift>,
    #[prost(string, tag = "22")]
    pub monitor_extra: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub fan_ticket_count: i64,
    #[prost(int32, tag = "4")]
    pub group_count: i32,
    #[prost(int32, tag = "5")]
    pub repeat_count: i32,
    #[prost(int32, tag = "6")]
    pub combo_count: i32,
    #[prost(message, optional, tag = "8")]
    pub to_user: ::core::option::Option<User>,
    #[prost(message, optional, tag = "10")]
    pub text_effect: ::core::option::Option<webcast_gift_message::TextEffect>,
    #[prost(int64, tag = "12")]
    pub income_taskgifts: i64,
    #[prost(int64, tag = "13")]
    pub room_fan_ticket_count: i64,
    #[prost(message, optional, tag = "14")]
    pub priority: ::core::option::Option<webcast_gift_message::GiftImPriority>,
    #[prost(string, tag = "16")]
    pub log_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "17")]
    pub send_type: i64,
    #[prost(message, optional, tag = "18")]
    pub public_area_common: ::core::option::Option<PublicAreaCommon>,
    #[prost(message, optional, tag = "19")]
    pub tray_display_text: ::core::option::Option<Text>,
    #[prost(int64, tag = "20")]
    pub banned_display_effects: i64,
    #[prost(message, optional, tag = "21")]
    pub m_tray_info: ::core::option::Option<webcast_gift_message::GiftTrayInfo>,
    #[prost(message, optional, tag = "23")]
    pub gift_extra: ::core::option::Option<webcast_gift_message::GiftMonitorInfo>,
    #[prost(int64, tag = "24")]
    pub color_id: i64,
    #[prost(bool, tag = "25")]
    pub is_first_sent: bool,
    #[prost(message, optional, tag = "26")]
    pub display_text_for_anchor: ::core::option::Option<Text>,
    #[prost(message, optional, tag = "27")]
    pub display_text_for_audience: ::core::option::Option<Text>,
    #[prost(string, tag = "28")]
    pub order_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "29")]
    pub gifts_in_box: ::core::option::Option<webcast_gift_message::GiftsBoxInfo>,
    #[prost(message, optional, tag = "30")]
    pub msg_filter: ::core::option::Option<MsgFilter>,
    #[prost(message, repeated, tag = "31")]
    pub lynx_extra: ::prost::alloc::vec::Vec<webcast_gift_message::LynxGiftExtra>,
    #[prost(message, optional, tag = "32")]
    pub user_identity: ::core::option::Option<UserIdentity>,
    #[prost(message, optional, tag = "33")]
    pub match_info: ::core::option::Option<webcast_gift_message::MatchInfo>,
    #[prost(enumeration = "LinkmicGiftExpressionStrategy", tag = "34")]
    pub linkmic_gift_expression_strategy: i32,
    #[prost(message, optional, tag = "35")]
    pub flying_mic_resources: ::core::option::Option<
        webcast_gift_message::FlyingMicResources,
    >,
    #[prost(bool, tag = "36")]
    pub disable_gift_tracking: bool,
    #[prost(message, optional, tag = "37")]
    pub asset: ::core::option::Option<webcast_gift_message::AssetsModel>,
    #[prost(enumeration = "GiftMessageVersion", tag = "38")]
    pub version: i32,
    #[prost(message, repeated, tag = "39")]
    pub sponsorship_info: ::prost::alloc::vec::Vec<
        webcast_gift_message::SponsorshipInfo,
    >,
    #[prost(message, optional, tag = "40")]
    pub flying_mic_resources_v2: ::core::option::Option<
        webcast_gift_message::FlyingMicResources,
    >,
    #[prost(message, optional, tag = "41")]
    pub public_area_message_common: ::core::option::Option<PublicAreaMessageCommon>,
    #[prost(string, tag = "42")]
    pub signature: ::prost::alloc::string::String,
    #[prost(string, tag = "43")]
    pub signature_version: ::prost::alloc::string::String,
    #[prost(bool, tag = "44")]
    pub multi_generate_message: bool,
    #[prost(string, tag = "45")]
    pub to_member_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "46")]
    pub to_member_id_int: i64,
    #[prost(string, tag = "47")]
    pub to_member_nickname: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "48")]
    pub interactive_gift_info: ::core::option::Option<
        webcast_gift_message::InteractiveGiftInfo,
    >,
}
/// Nested message and enum types in `WebcastGiftMessage`.
pub mod webcast_gift_message {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InteractiveGiftInfo {
        #[prost(int64, tag = "1")]
        pub cross_screen_delay: i64,
        #[prost(int64, tag = "2")]
        pub cross_screen_role: i64,
        #[prost(enumeration = "super::GiftMessageIgnoreConfig", tag = "3")]
        pub ignore_config: i32,
        #[prost(int64, tag = "4")]
        pub uniq_id: i64,
        #[prost(int64, tag = "5")]
        pub to_user_team_id: i64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GiftImPriority {
        #[prost(int64, repeated, tag = "1")]
        pub queue_sizes_list: ::prost::alloc::vec::Vec<i64>,
        #[prost(int64, tag = "2")]
        pub self_queue_priority: i64,
        #[prost(int64, tag = "3")]
        pub priority: i64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TextEffect {
        #[prost(message, optional, tag = "1")]
        pub portrait_detail: ::core::option::Option<text_effect::Detail>,
        #[prost(message, optional, tag = "2")]
        pub landscape_detail: ::core::option::Option<text_effect::Detail>,
    }
    /// Nested message and enum types in `TextEffect`.
    pub mod text_effect {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Detail {
            #[prost(message, optional, tag = "1")]
            pub text: ::core::option::Option<super::super::Text>,
            #[prost(int32, tag = "2")]
            pub text_font_size: i32,
            #[prost(message, optional, tag = "3")]
            pub background: ::core::option::Option<super::super::Image>,
            #[prost(int64, tag = "4")]
            pub start: i64,
            #[prost(int64, tag = "5")]
            pub duration: i64,
            #[prost(int32, tag = "6")]
            pub x: i32,
            #[prost(int32, tag = "7")]
            pub y: i32,
            #[prost(int32, tag = "8")]
            pub width: i32,
            #[prost(int32, tag = "9")]
            pub height: i32,
            #[prost(int32, tag = "10")]
            pub shadow_dx: i32,
            #[prost(int32, tag = "11")]
            pub shadow_dy: i32,
            #[prost(int32, tag = "12")]
            pub shadow_radius: i32,
            #[prost(string, tag = "13")]
            pub shadow_color: ::prost::alloc::string::String,
            #[prost(string, tag = "14")]
            pub stroke_color: ::prost::alloc::string::String,
            #[prost(int32, tag = "15")]
            pub stroke_width: i32,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GiftTrayInfo {
        #[prost(message, optional, tag = "1")]
        pub m_dynamic_img: ::core::option::Option<super::Image>,
        #[prost(bool, tag = "2")]
        pub can_mirror: bool,
        #[prost(message, optional, tag = "3")]
        pub tray_normal_bg_img: ::core::option::Option<super::Image>,
        #[prost(string, repeated, tag = "4")]
        pub tray_normal_bg_color: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
        #[prost(message, optional, tag = "5")]
        pub tray_small_bg_img: ::core::option::Option<super::Image>,
        #[prost(string, repeated, tag = "6")]
        pub tray_small_bg_color: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
        #[prost(message, optional, tag = "7")]
        pub right_tag_text: ::core::option::Option<super::Text>,
        #[prost(message, optional, tag = "8")]
        pub right_tag_bg_img: ::core::option::Option<super::Image>,
        #[prost(string, repeated, tag = "9")]
        pub right_tag_bg_color: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, tag = "10")]
        pub tray_name_text_color: ::prost::alloc::string::String,
        #[prost(string, tag = "11")]
        pub tray_desc_text_color: ::prost::alloc::string::String,
        #[prost(string, tag = "12")]
        pub right_tag_jump_schema: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GiftMonitorInfo {
        #[prost(int64, tag = "1")]
        pub anchor_id: i64,
        #[prost(int64, tag = "2")]
        pub profit_api_message_dur: i64,
        #[prost(int64, tag = "3")]
        pub send_gift_profit_api_start_ms: i64,
        #[prost(int64, tag = "4")]
        pub send_gift_profit_core_start_ms: i64,
        #[prost(int64, tag = "5")]
        pub send_gift_req_start_ms: i64,
        #[prost(int64, tag = "6")]
        pub send_gift_send_message_success_ms: i64,
        #[prost(int64, tag = "7")]
        pub send_profit_api_dur: i64,
        #[prost(int64, tag = "8")]
        pub to_user_id: i64,
        #[prost(int64, tag = "9")]
        pub send_gift_start_client_local_ms: i64,
        #[prost(string, tag = "10")]
        pub from_platform: ::prost::alloc::string::String,
        #[prost(string, tag = "11")]
        pub from_version: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MatchInfo {
        #[prost(int64, tag = "1")]
        pub critical: i64,
        #[prost(bool, tag = "2")]
        pub effect_card_in_use: bool,
        #[prost(enumeration = "super::MultiplierType", tag = "3")]
        pub multiplier_type: i32,
        #[prost(int64, tag = "4")]
        pub multiplier_value: i64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GiftsBoxInfo {
        #[prost(message, repeated, tag = "1")]
        pub gifts: ::prost::alloc::vec::Vec<gifts_box_info::GiftInfoInBox>,
    }
    /// Nested message and enum types in `GiftsBoxInfo`.
    pub mod gifts_box_info {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct GiftInfoInBox {
            #[prost(int64, tag = "1")]
            pub gift_id: i64,
            #[prost(int64, tag = "2")]
            pub effect_id: i64,
            #[prost(int64, tag = "3")]
            pub color_id: i64,
            #[prost(int32, tag = "4")]
            pub remain_times: i32,
            #[prost(message, optional, tag = "5")]
            pub asset: ::core::option::Option<gift_info_in_box::AssetsModel>,
        }
        /// Nested message and enum types in `GiftInfoInBox`.
        pub mod gift_info_in_box {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct AssetsModel {
                #[prost(string, tag = "1")]
                pub name: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub resource_uri: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "4")]
                pub resource_model: ::core::option::Option<assets_model::ResourceModel>,
                #[prost(string, tag = "5")]
                pub describe: ::prost::alloc::string::String,
                #[prost(int64, tag = "6")]
                pub id: i64,
                #[prost(int32, tag = "7")]
                pub resource_type: i32,
                #[prost(string, tag = "8")]
                pub md5: ::prost::alloc::string::String,
                #[prost(int64, tag = "9")]
                pub size: i64,
                #[prost(message, optional, tag = "10")]
                pub loki_extra_content: ::core::option::Option<
                    assets_model::LokiExtraContent,
                >,
                #[prost(int32, tag = "26")]
                pub download_type: i32,
                #[prost(message, optional, tag = "28")]
                pub resource_byte_v_c1_model: ::core::option::Option<
                    assets_model::ResourceModel,
                >,
                #[prost(string, tag = "29")]
                pub bytevc1_md5: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "30")]
                pub video_resource_list: ::prost::alloc::vec::Vec<
                    assets_model::VideoResource,
                >,
                #[prost(message, optional, tag = "31")]
                pub face_recognition_archive_meta: ::core::option::Option<
                    assets_model::FaceRecognitionMeta,
                >,
                #[prost(string, tag = "32")]
                pub lynx_url_settings_key: ::prost::alloc::string::String,
                #[prost(int32, tag = "33")]
                pub downgrade_resource_type: i32,
                #[prost(message, optional, tag = "34")]
                pub asset_extra: ::core::option::Option<assets_model::AssetExtra>,
                #[prost(int32, tag = "35")]
                pub sticker_asset_variant: i32,
                #[prost(bool, tag = "36")]
                pub immediate_download: bool,
                #[prost(int32, tag = "37")]
                pub sticker_asset_variant_reason: i32,
            }
            /// Nested message and enum types in `AssetsModel`.
            pub mod assets_model {
                #[derive(serde::Serialize, serde::Deserialize)]
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct AssetExtra {
                    #[prost(string, tag = "1")]
                    pub effect_starling_key: ::prost::alloc::string::String,
                }
                #[derive(serde::Serialize, serde::Deserialize)]
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct ResourceModel {
                    #[prost(string, repeated, tag = "1")]
                    pub url_list: ::prost::alloc::vec::Vec<
                        ::prost::alloc::string::String,
                    >,
                    #[prost(string, tag = "2")]
                    pub uri: ::prost::alloc::string::String,
                }
                #[derive(serde::Serialize, serde::Deserialize)]
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct LokiExtraContent {
                    #[prost(string, tag = "1")]
                    pub gift_type: ::prost::alloc::string::String,
                    #[prost(int64, tag = "2")]
                    pub gift_duration: i64,
                    #[prost(bool, tag = "3")]
                    pub need_screen_shot: bool,
                    #[prost(bool, tag = "4")]
                    pub ismulti_frame: bool,
                    #[prost(string, tag = "5")]
                    pub view_overlay: ::prost::alloc::string::String,
                    #[prost(message, optional, tag = "6")]
                    pub bef_view_render_size: ::core::option::Option<
                        loki_extra_content::BefViewRenderSize,
                    >,
                    #[prost(int32, tag = "7")]
                    pub bef_view_render_f_p_s: i32,
                    #[prost(int32, tag = "8")]
                    pub bef_view_fit_mode: i32,
                    #[prost(string, tag = "9")]
                    pub model_names: ::prost::alloc::string::String,
                    #[prost(string, repeated, tag = "10")]
                    pub requirements: ::prost::alloc::vec::Vec<
                        ::prost::alloc::string::String,
                    >,
                }
                /// Nested message and enum types in `LokiExtraContent`.
                pub mod loki_extra_content {
                    #[derive(serde::Serialize, serde::Deserialize)]
                    #[allow(clippy::derive_partial_eq_without_eq)]
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct BefViewRenderSize {
                        #[prost(int32, tag = "1")]
                        pub with: i32,
                        #[prost(int32, tag = "2")]
                        pub height: i32,
                    }
                }
                #[derive(serde::Serialize, serde::Deserialize)]
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct VideoResource {
                    #[prost(string, tag = "1")]
                    pub video_type_name: ::prost::alloc::string::String,
                    #[prost(message, optional, tag = "2")]
                    pub video_url: ::core::option::Option<ResourceModel>,
                    #[prost(string, tag = "3")]
                    pub video_md5: ::prost::alloc::string::String,
                }
                #[derive(serde::Serialize, serde::Deserialize)]
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct FaceRecognitionMeta {
                    #[prost(string, tag = "1")]
                    pub version: ::prost::alloc::string::String,
                    #[prost(string, repeated, tag = "2")]
                    pub requirements: ::prost::alloc::vec::Vec<
                        ::prost::alloc::string::String,
                    >,
                    #[prost(string, tag = "3")]
                    pub model_names: ::prost::alloc::string::String,
                    #[prost(string, tag = "4")]
                    pub sdk_extra: ::prost::alloc::string::String,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AssetsModel {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub resource_uri: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "4")]
        pub resource_model: ::core::option::Option<assets_model::ResourceModel>,
        #[prost(string, tag = "5")]
        pub describe: ::prost::alloc::string::String,
        #[prost(int64, tag = "6")]
        pub id: i64,
        #[prost(int32, tag = "7")]
        pub resource_type: i32,
        #[prost(string, tag = "8")]
        pub md5: ::prost::alloc::string::String,
        #[prost(int64, tag = "9")]
        pub size: i64,
        #[prost(message, optional, tag = "10")]
        pub loki_extra_content: ::core::option::Option<assets_model::LokiExtraContent>,
        #[prost(int32, tag = "26")]
        pub download_type: i32,
        #[prost(message, optional, tag = "28")]
        pub resource_byte_v_c1_model: ::core::option::Option<
            assets_model::ResourceModel,
        >,
        #[prost(string, tag = "29")]
        pub bytevc1_md5: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "30")]
        pub video_resource_list: ::prost::alloc::vec::Vec<assets_model::VideoResource>,
        #[prost(message, optional, tag = "31")]
        pub face_recognition_archive_meta: ::core::option::Option<
            assets_model::FaceRecognitionMeta,
        >,
        #[prost(string, tag = "32")]
        pub lynx_url_settings_key: ::prost::alloc::string::String,
        #[prost(int32, tag = "33")]
        pub downgrade_resource_type: i32,
        #[prost(message, optional, tag = "34")]
        pub asset_extra: ::core::option::Option<assets_model::AssetExtra>,
        #[prost(int32, tag = "35")]
        pub sticker_asset_variant: i32,
        #[prost(bool, tag = "36")]
        pub immediate_download: bool,
        #[prost(int32, tag = "37")]
        pub sticker_asset_variant_reason: i32,
    }
    /// Nested message and enum types in `AssetsModel`.
    pub mod assets_model {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct AssetExtra {
            #[prost(string, tag = "1")]
            pub effect_starling_key: ::prost::alloc::string::String,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ResourceModel {
            #[prost(string, repeated, tag = "1")]
            pub url_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            #[prost(string, tag = "2")]
            pub uri: ::prost::alloc::string::String,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct LokiExtraContent {
            #[prost(string, tag = "1")]
            pub gift_type: ::prost::alloc::string::String,
            #[prost(int64, tag = "2")]
            pub gift_duration: i64,
            #[prost(bool, tag = "3")]
            pub need_screen_shot: bool,
            #[prost(bool, tag = "4")]
            pub ismulti_frame: bool,
            #[prost(string, tag = "5")]
            pub view_overlay: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "6")]
            pub bef_view_render_size: ::core::option::Option<
                loki_extra_content::BefViewRenderSize,
            >,
            #[prost(int32, tag = "7")]
            pub bef_view_render_f_p_s: i32,
            #[prost(int32, tag = "8")]
            pub bef_view_fit_mode: i32,
            #[prost(string, tag = "9")]
            pub model_names: ::prost::alloc::string::String,
            #[prost(string, repeated, tag = "10")]
            pub requirements: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        /// Nested message and enum types in `LokiExtraContent`.
        pub mod loki_extra_content {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct BefViewRenderSize {
                #[prost(int32, tag = "1")]
                pub with: i32,
                #[prost(int32, tag = "2")]
                pub height: i32,
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct VideoResource {
            #[prost(string, tag = "1")]
            pub video_type_name: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "2")]
            pub video_url: ::core::option::Option<ResourceModel>,
            #[prost(string, tag = "3")]
            pub video_md5: ::prost::alloc::string::String,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct FaceRecognitionMeta {
            #[prost(string, tag = "1")]
            pub version: ::prost::alloc::string::String,
            #[prost(string, repeated, tag = "2")]
            pub requirements: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            #[prost(string, tag = "3")]
            pub model_names: ::prost::alloc::string::String,
            #[prost(string, tag = "4")]
            pub sdk_extra: ::prost::alloc::string::String,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LynxGiftExtra {
        #[prost(int64, tag = "1")]
        pub id: i64,
        #[prost(int64, tag = "2")]
        pub code: i64,
        #[prost(int64, tag = "3")]
        pub r#type: i64,
        #[prost(string, repeated, tag = "4")]
        pub params: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, tag = "5")]
        pub extra: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FlyingMicResources {
        #[prost(message, optional, tag = "1")]
        pub path_image: ::core::option::Option<super::Image>,
        #[prost(message, optional, tag = "2")]
        pub mic_image: ::core::option::Option<super::Image>,
        #[prost(message, repeated, tag = "3")]
        pub transition_configs: ::prost::alloc::vec::Vec<
            flying_mic_resources::TransitionConfig,
        >,
    }
    /// Nested message and enum types in `FlyingMicResources`.
    pub mod flying_mic_resources {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TransitionConfig {
            #[prost(int64, tag = "1")]
            pub config_id: i64,
            #[prost(message, optional, tag = "2")]
            pub resource_image: ::core::option::Option<super::super::Image>,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SponsorshipInfo {
        #[prost(int64, tag = "1")]
        pub gift_id: i64,
        #[prost(int64, tag = "2")]
        pub sponsor_id: i64,
        #[prost(bool, tag = "3")]
        pub light_gift_up: bool,
        #[prost(string, tag = "4")]
        pub unlighted_gift_icon: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub gift_gallery_detail_page_scheme_url: ::prost::alloc::string::String,
        #[prost(bool, tag = "6")]
        pub gift_gallery_click_sponsor: bool,
        #[prost(bool, tag = "21")]
        pub become_all_sponsored: bool,
    }
}
/// Battle start
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastLinkMicBattle {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(int64, tag = "2")]
    pub battle_id: i64,
    #[prost(message, optional, tag = "3")]
    pub battle_setting: ::core::option::Option<BattleSetting>,
    #[prost(enumeration = "BattleAction", tag = "4")]
    pub action: i32,
    #[prost(map = "int64, message", tag = "5")]
    pub battle_result: ::std::collections::HashMap<
        i64,
        webcast_link_mic_battle::BattleResult,
    >,
    #[prost(message, optional, tag = "6")]
    pub m_battle_display_config: ::core::option::Option<
        webcast_link_mic_battle::BattleDisplayConfig,
    >,
    #[prost(enumeration = "GiftPermissionType", tag = "8")]
    pub invitee_gift_permission_type: i32,
    #[prost(map = "int64, message", tag = "9")]
    pub armies: ::std::collections::HashMap<i64, BattleUserArmies>,
    #[prost(map = "int64, message", tag = "10")]
    pub anchor_info: ::std::collections::HashMap<
        i64,
        webcast_link_mic_battle::BattleUserInfo,
    >,
    #[prost(string, tag = "11")]
    pub bubble_text: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "12")]
    pub supported_actions: ::prost::alloc::vec::Vec<
        webcast_link_mic_battle::SupportedActionsWrapper,
    >,
    #[prost(map = "int64, message", tag = "13")]
    pub battle_combos: ::std::collections::HashMap<
        i64,
        webcast_link_mic_battle::BattleComboInfo,
    >,
    #[prost(message, repeated, tag = "14")]
    pub team_users: ::prost::alloc::vec::Vec<webcast_link_mic_battle::TeamUsersInfo>,
    #[prost(message, repeated, tag = "15")]
    pub invitee_gift_permission_types: ::prost::alloc::vec::Vec<
        webcast_link_mic_battle::BattleInviteeGiftPermission,
    >,
    #[prost(int64, tag = "16")]
    pub action_by_user_id: i64,
    #[prost(message, repeated, tag = "17")]
    pub team_battle_result: ::prost::alloc::vec::Vec<
        webcast_link_mic_battle::BattleTeamResult,
    >,
    #[prost(message, repeated, tag = "18")]
    pub team_armies: ::prost::alloc::vec::Vec<BattleTeamUserArmies>,
    #[prost(message, repeated, tag = "19")]
    pub abtest_settings: ::prost::alloc::vec::Vec<
        webcast_link_mic_battle::BattleAbTestSetting,
    >,
    #[prost(message, optional, tag = "20")]
    pub team_match_campaign: ::core::option::Option<
        webcast_link_mic_battle::TeamMatchCampaign,
    >,
    #[prost(message, optional, tag = "21")]
    pub fuzzy_display_config_v2: ::core::option::Option<HighScoreControlCfg>,
}
/// Nested message and enum types in `WebcastLinkMicBattle`.
pub mod webcast_link_mic_battle {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TeamMatchCampaign {
        #[prost(message, repeated, tag = "1")]
        pub best_teammate_relation: ::prost::alloc::vec::Vec<
            team_match_campaign::BestTeammateRelation,
        >,
        #[prost(int64, repeated, tag = "2")]
        pub start_sfx_team_id: ::prost::alloc::vec::Vec<i64>,
        #[prost(bool, tag = "3")]
        pub has_team_match_mvp_sfx: bool,
    }
    /// Nested message and enum types in `TeamMatchCampaign`.
    pub mod team_match_campaign {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct BestTeammateRelation {
            #[prost(int64, tag = "1")]
            pub user_id: i64,
            #[prost(int64, tag = "2")]
            pub best_teammate_id: i64,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BattleTeamResult {
        #[prost(int64, tag = "1")]
        pub team_id: i64,
        #[prost(message, repeated, tag = "2")]
        pub team_users: ::prost::alloc::vec::Vec<super::BattleTeamUser>,
        #[prost(int32, tag = "3")]
        pub result: i32,
        #[prost(int64, tag = "4")]
        pub total_score: i64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BattleInviteeGiftPermission {
        #[prost(int64, tag = "1")]
        pub user_id: i64,
        #[prost(int32, tag = "2")]
        pub gift_permission_type: i32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SupportedActionsWrapper {
        #[prost(int64, tag = "1")]
        pub action_type: i64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TeamUsersInfo {
        #[prost(int64, tag = "1")]
        pub team_id: i64,
        #[prost(int64, repeated, tag = "2")]
        pub user_ids: ::prost::alloc::vec::Vec<i64>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BattleComboInfo {
        #[prost(int64, tag = "1")]
        pub user_id: i64,
        #[prost(int64, tag = "2")]
        pub combo_status: i64,
        #[prost(int64, tag = "3")]
        pub combo_count: i64,
        #[prost(string, tag = "4")]
        pub combo_icon_url: ::prost::alloc::string::String,
        #[prost(int32, tag = "5")]
        pub combo_type: i32,
        #[prost(string, tag = "6")]
        pub combo_rule_guide_schema: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BattleResult {
        #[prost(int64, tag = "1")]
        pub user_id: i64,
        #[prost(enumeration = "super::Result", tag = "2")]
        pub result: i32,
        #[prost(int64, tag = "3")]
        pub score: i64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BattleDisplayConfig {
        #[prost(int32, tag = "1")]
        pub threshold: i32,
        #[prost(string, tag = "2")]
        pub text: ::prost::alloc::string::String,
        #[prost(int32, tag = "3")]
        pub diff_threshold: i32,
        #[prost(string, tag = "4")]
        pub diff_text: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "5")]
        pub exempt_strategy: ::core::option::Option<
            battle_display_config::ExemptStrategy,
        >,
    }
    /// Nested message and enum types in `BattleDisplayConfig`.
    pub mod battle_display_config {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ExemptStrategy {
            #[prost(bool, tag = "1")]
            pub exempt_both_host: bool,
            #[prost(int32, tag = "2")]
            pub exempt_audience_top: i32,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BattleUserInfo {
        #[prost(message, optional, tag = "1")]
        pub user: ::core::option::Option<battle_user_info::BattleBaseUserInfo>,
        #[prost(message, repeated, tag = "2")]
        pub tags: ::prost::alloc::vec::Vec<battle_user_info::BattleRivalTag>,
    }
    /// Nested message and enum types in `BattleUserInfo`.
    pub mod battle_user_info {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct BattleBaseUserInfo {
            #[prost(int64, tag = "1")]
            pub user_id: i64,
            #[prost(string, tag = "2")]
            pub nick_name: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "3")]
            pub avatar_thumb: ::core::option::Option<super::super::Image>,
            #[prost(string, tag = "4")]
            pub display_id: ::prost::alloc::string::String,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct BattleRivalTag {
            #[prost(message, optional, tag = "1")]
            pub bg_image: ::core::option::Option<super::super::Image>,
            #[prost(message, optional, tag = "2")]
            pub icon_image: ::core::option::Option<super::super::Image>,
            #[prost(string, tag = "3")]
            pub content: ::prost::alloc::string::String,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BattleAbTestSetting {
        #[prost(int64, tag = "1")]
        pub uid: i64,
        #[prost(message, optional, tag = "2")]
        pub ab_test_list: ::core::option::Option<
            battle_ab_test_setting::BattleAbTestList,
        >,
    }
    /// Nested message and enum types in `BattleABTestSetting`.
    pub mod battle_ab_test_setting {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct BattleAbTestList {
            #[prost(message, repeated, tag = "1")]
            pub ab_test_list: ::prost::alloc::vec::Vec<
                battle_ab_test_list::BattleAbTest,
            >,
        }
        /// Nested message and enum types in `BattleABTestList`.
        pub mod battle_ab_test_list {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct BattleAbTest {
                #[prost(
                    enumeration = "super::super::super::BattleAbTestType",
                    tag = "1"
                )]
                pub ab_test_type: i32,
                #[prost(int32, tag = "2")]
                pub group: i32,
            }
        }
    }
}
/// Battle status
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastLinkMicArmies {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(int64, tag = "2")]
    pub battle_id: i64,
    #[prost(map = "int64, message", tag = "3")]
    pub battle_items: ::std::collections::HashMap<i64, BattleUserArmies>,
    #[prost(int64, tag = "4")]
    pub channel_id: i64,
    #[prost(int64, tag = "5")]
    pub gift_sent_time: i64,
    #[prost(int64, tag = "6")]
    pub score_update_time: i64,
    #[prost(enumeration = "TriggerReason", tag = "7")]
    pub battle_status: i32,
    #[prost(int64, tag = "8")]
    pub from_user_id: i64,
    #[prost(int64, tag = "9")]
    pub gift_id: i64,
    #[prost(int32, tag = "10")]
    pub gift_count: i32,
    #[prost(message, optional, tag = "11")]
    pub gif_icon_image: ::core::option::Option<Image>,
    #[prost(int32, tag = "12")]
    pub total_diamond_count: i32,
    #[prost(int32, tag = "13")]
    pub repeat_count: i32,
    #[prost(message, repeated, tag = "14")]
    pub team_armies: ::prost::alloc::vec::Vec<BattleTeamUserArmies>,
    #[prost(bool, tag = "15")]
    pub trigger_critical_strike: bool,
    #[prost(bool, tag = "16")]
    pub has_team_match_mvp_sfx: bool,
    #[prost(string, tag = "17")]
    pub log_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "18")]
    pub battle_settings: ::core::option::Option<BattleSetting>,
    #[prost(message, optional, tag = "19")]
    pub fuzzy_display_config_v2: ::core::option::Option<HighScoreControlCfg>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastLinkMicArmiesItems {
    #[prost(uint64, tag = "1")]
    pub host_user_id: u64,
    #[prost(message, repeated, tag = "2")]
    pub battle_groups: ::prost::alloc::vec::Vec<WebcastLinkMicArmiesGroup>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastLinkMicArmiesGroup {
    #[prost(message, repeated, tag = "1")]
    pub users: ::prost::alloc::vec::Vec<User>,
    #[prost(int32, tag = "2")]
    pub points: i32,
}
/// Follow & share event
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastSocialMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(message, optional, tag = "2")]
    pub user: ::core::option::Option<User>,
    #[prost(int64, tag = "3")]
    pub share_type: i64,
    #[prost(int64, tag = "4")]
    pub action: i64,
    #[prost(string, tag = "5")]
    pub share_target: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub follow_count: i32,
    #[prost(int64, tag = "7")]
    pub share_display_style: i64,
    #[prost(int32, tag = "8")]
    pub share_count: i32,
    #[prost(message, optional, tag = "9")]
    pub public_area_message_common: ::core::option::Option<PublicAreaMessageCommon>,
    #[prost(string, tag = "10")]
    pub signature: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub signature_version: ::prost::alloc::string::String,
    #[prost(int64, tag = "12")]
    pub show_duration_ms: i64,
}
/// Like event (is only sent from time to time, not with every like)
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastLikeMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(int32, tag = "2")]
    pub like_count: i32,
    #[prost(int32, tag = "3")]
    pub total_like_count: i32,
    #[prost(int32, tag = "4")]
    pub color: i32,
    #[prost(message, optional, tag = "5")]
    pub user: ::core::option::Option<User>,
    #[prost(string, tag = "6")]
    pub icon: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "7")]
    pub icons: ::prost::alloc::vec::Vec<Image>,
    #[prost(message, repeated, tag = "8")]
    pub specified_display_text: ::prost::alloc::vec::Vec<SpecifiedDisplayText>,
    #[prost(int64, tag = "9")]
    pub effect_cnt: i64,
    #[prost(message, repeated, tag = "10")]
    pub like_effect: ::prost::alloc::vec::Vec<LikeEffect>,
    #[prost(message, optional, tag = "11")]
    pub public_area_message_common: ::core::option::Option<PublicAreaMessageCommon>,
    #[prost(int64, tag = "12")]
    pub room_message_heat_level: i64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpecifiedDisplayText {
    #[prost(int64, tag = "1")]
    pub uid: i64,
    #[prost(message, optional, tag = "2")]
    pub display_text: ::core::option::Option<Text>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LikeEffect {
    #[prost(int64, tag = "1")]
    pub version: i64,
    #[prost(int64, tag = "2")]
    pub effect_cnt: i64,
    #[prost(int64, tag = "3")]
    pub effect_interval_ms: i64,
    #[prost(int64, tag = "4")]
    pub level: i64,
}
/// New question event
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastQuestionNewMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(message, optional, tag = "2")]
    pub details: ::core::option::Option<webcast_question_new_message::Question>,
}
/// Nested message and enum types in `WebcastQuestionNewMessage`.
pub mod webcast_question_new_message {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Question {
        #[prost(int64, tag = "1")]
        pub question_id: i64,
        #[prost(string, tag = "2")]
        pub question_text: ::prost::alloc::string::String,
        #[prost(int32, tag = "3")]
        pub answer_status: i32,
        #[prost(int64, tag = "4")]
        pub create_time: i64,
        #[prost(message, optional, tag = "5")]
        pub user: ::core::option::Option<super::User>,
        #[prost(int32, tag = "20")]
        pub create_from: i32,
        #[prost(int32, tag = "21")]
        pub answer_from: i32,
    }
}
/// Contains UI information
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastMessageEventDetails {
    #[prost(string, tag = "1")]
    pub display_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub label: ::prost::alloc::string::String,
}
/// Source: Co-opted <https://github.com/zerodytrash/TikTok-Livestream-Chat-Connector/issues/19#issuecomment-1074150342>
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastLiveIntroMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(int64, tag = "2")]
    pub room_id: i64,
    #[prost(enumeration = "AuditStatus", tag = "3")]
    pub audit_status: i32,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub host: ::core::option::Option<User>,
    #[prost(int32, tag = "6")]
    pub intro_mode: i32,
    #[prost(message, repeated, tag = "7")]
    pub badges: ::prost::alloc::vec::Vec<BadgeStruct>,
    #[prost(string, tag = "8")]
    pub language: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemMessage {
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RankItem {
    #[prost(string, tag = "1")]
    pub colour: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub id: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastHourlyRankMessage {
    #[prost(message, optional, tag = "2")]
    pub data: ::core::option::Option<webcast_hourly_rank_message::RankContainer>,
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(uint32, tag = "3")]
    pub data2: u32,
}
/// Nested message and enum types in `WebcastHourlyRankMessage`.
pub mod webcast_hourly_rank_message {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RankContainer {
        #[prost(uint32, tag = "1")]
        pub data1: u32,
        #[prost(message, optional, tag = "2")]
        pub ranking_data: ::core::option::Option<rank_container::RankingData>,
        #[prost(uint32, tag = "3")]
        pub data2: u32,
        #[prost(message, optional, tag = "4")]
        pub rankings: ::core::option::Option<super::Ranking>,
        #[prost(message, optional, tag = "5")]
        pub ranking_data2: ::core::option::Option<rank_container::RankingData2>,
        #[prost(uint32, tag = "6")]
        pub data3: u32,
        #[prost(uint32, tag = "7")]
        pub data4: u32,
    }
    /// Nested message and enum types in `RankContainer`.
    pub mod rank_container {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct RankingData {
            #[prost(uint32, tag = "1")]
            pub data1: u32,
            #[prost(message, optional, tag = "2")]
            pub rankdata: ::core::option::Option<super::super::Ranking>,
            #[prost(string, tag = "3")]
            pub data2: ::prost::alloc::string::String,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct RankingData2 {
            #[prost(uint32, tag = "1")]
            pub data1: u32,
            #[prost(uint32, tag = "2")]
            pub data2: u32,
            #[prost(message, optional, tag = "3")]
            pub rankdata: ::core::option::Option<super::super::Ranking>,
            #[prost(string, tag = "4")]
            pub data3: ::prost::alloc::string::String,
            #[prost(uint32, tag = "5")]
            pub data4: u32,
            #[prost(uint32, tag = "6")]
            pub data5: u32,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmoteDetails {
    #[prost(string, tag = "1")]
    pub emote_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub image: ::core::option::Option<EmoteImage>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmoteImage {
    #[prost(string, tag = "1")]
    pub image_url: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastEnvelopeMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(message, optional, tag = "2")]
    pub envelope_info: ::core::option::Option<webcast_envelope_message::EnvelopeInfo>,
    #[prost(enumeration = "EnvelopeDisplay", tag = "3")]
    pub display: i32,
}
/// Nested message and enum types in `WebcastEnvelopeMessage`.
pub mod webcast_envelope_message {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EnvelopeInfo {
        #[prost(string, tag = "1")]
        pub envelope_id: ::prost::alloc::string::String,
        #[prost(enumeration = "super::EnvelopeBusinessType", tag = "2")]
        pub business_type: i32,
        #[prost(string, tag = "3")]
        pub envelope_idc: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub send_user_name: ::prost::alloc::string::String,
        #[prost(int32, tag = "5")]
        pub diamond_count: i32,
        #[prost(int32, tag = "6")]
        pub people_count: i32,
        #[prost(int32, tag = "7")]
        pub unpack_at: i32,
        #[prost(string, tag = "8")]
        pub send_user_id: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "9")]
        pub send_user_avatar: ::core::option::Option<super::Image>,
        #[prost(string, tag = "10")]
        pub create_at: ::prost::alloc::string::String,
        #[prost(string, tag = "11")]
        pub room_id: ::prost::alloc::string::String,
        #[prost(enumeration = "super::EnvelopeFollowShowStatus", tag = "12")]
        pub follow_show_status: i32,
        #[prost(int32, tag = "13")]
        pub skin_id: i32,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TreasureBoxData {
    #[prost(uint32, tag = "5")]
    pub coins: u32,
    #[prost(uint32, tag = "6")]
    pub can_open: u32,
    #[prost(uint64, tag = "7")]
    pub timestamp: u64,
}
/// New Subscriber message
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastSubNotifyMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(message, optional, tag = "2")]
    pub user: ::core::option::Option<User>,
    #[prost(enumeration = "ExhibitionType", tag = "3")]
    pub exhibition_type: i32,
    #[prost(int64, tag = "4")]
    pub sub_month: i64,
    #[prost(enumeration = "SubscribeType", tag = "5")]
    pub subscribe_type: i32,
    #[prost(enumeration = "OldSubscribeStatus", tag = "6")]
    pub old_subscribe_status: i32,
    #[prost(enumeration = "MessageType", optional, tag = "7")]
    pub subscribe_message_type: ::core::option::Option<i32>,
    #[prost(enumeration = "SubscribingStatus", tag = "8")]
    pub subscribing_status: i32,
    #[prost(bool, tag = "9")]
    pub is_send: bool,
    #[prost(bool, tag = "10")]
    pub is_custom: bool,
    #[prost(enumeration = "GiftSource", tag = "11")]
    pub gift_source: i32,
    #[prost(enumeration = "MessageDisplayStyle", tag = "12")]
    pub message_display_style: i32,
    #[prost(message, optional, tag = "13")]
    pub public_area_message_common: ::core::option::Option<PublicAreaMessageCommon>,
    #[prost(string, tag = "14")]
    pub package_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "15")]
    pub event_tracking: ::core::option::Option<
        webcast_sub_notify_message::EventTracking,
    >,
}
/// Nested message and enum types in `WebcastSubNotifyMessage`.
pub mod webcast_sub_notify_message {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EventTracking {
        #[prost(int64, tag = "1")]
        pub gift_sub_sender_id: i64,
        #[prost(int64, tag = "2")]
        pub gift_sub_receiver_id: i64,
        #[prost(int64, tag = "3")]
        pub anchor_id: i64,
        #[prost(int64, tag = "4")]
        pub gift_sub_order_create_time: i64,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FollowInfo {
    #[prost(int32, tag = "1")]
    pub following_count: i32,
    #[prost(int32, tag = "2")]
    pub follower_count: i32,
    #[prost(int32, tag = "3")]
    pub follow_status: i32,
    #[prost(int32, tag = "4")]
    pub push_status: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProfilePicture {
    #[prost(string, repeated, tag = "1")]
    pub urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserBadgesAttributes {
    #[prost(int32, tag = "3")]
    pub badge_scene_type: i32,
    #[prost(message, repeated, tag = "20")]
    pub image_badges: ::prost::alloc::vec::Vec<UserImageBadge>,
    #[prost(message, repeated, tag = "21")]
    pub badges: ::prost::alloc::vec::Vec<UserBadge>,
    #[prost(message, optional, tag = "12")]
    pub privilege_log_extra: ::core::option::Option<PrivilegeLogExtra>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserBadge {
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserImageBadge {
    #[prost(int32, tag = "1")]
    pub display_type: i32,
    #[prost(message, optional, tag = "2")]
    pub image: ::core::option::Option<UserImageBadgeImage>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserImageBadgeImage {
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastBarrageMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(message, optional, tag = "2")]
    pub event: ::core::option::Option<webcast_barrage_message::BarrageEvent>,
    #[prost(enumeration = "webcast_barrage_message::BarrageType", optional, tag = "3")]
    pub msg_type: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "4")]
    pub icon: ::core::option::Option<ImageModel>,
    #[prost(int64, tag = "6")]
    pub duration: i64,
    #[prost(message, optional, tag = "7")]
    pub back_ground: ::core::option::Option<ImageModel>,
    #[prost(message, optional, tag = "8")]
    pub right_icon: ::core::option::Option<ImageModel>,
    #[prost(int32, tag = "9")]
    pub display_config: i32,
    #[prost(int64, tag = "10")]
    pub gallery_gift_id: i64,
    #[prost(bool, tag = "14")]
    pub use_marquee: bool,
    #[prost(enumeration = "webcast_barrage_message::ShowType", optional, tag = "15")]
    pub show_type: ::core::option::Option<i32>,
    #[prost(enumeration = "webcast_barrage_message::RenderType", optional, tag = "17")]
    pub render_type: ::core::option::Option<i32>,
    #[prost(
        enumeration = "webcast_barrage_message::IconDisplayType",
        optional,
        tag = "18"
    )]
    pub left_icon_display_type: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "19")]
    pub ribbon_animation: ::core::option::Option<ImageModel>,
    #[prost(string, tag = "21")]
    pub hybrid_url: ::prost::alloc::string::String,
    #[prost(string, tag = "22")]
    pub schema: ::prost::alloc::string::String,
    #[prost(string, tag = "23")]
    pub sub_type: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "103")]
    pub privilege_log_extra: ::core::option::Option<PrivilegeLogExtra>,
    #[prost(message, optional, tag = "5")]
    pub content: ::core::option::Option<Text>,
    #[prost(enumeration = "Scene", tag = "11")]
    pub scene: i32,
    #[prost(message, optional, tag = "12")]
    pub control: ::core::option::Option<webcast_barrage_message::DisplayControl>,
    #[prost(message, optional, tag = "13")]
    pub right_label: ::core::option::Option<webcast_barrage_message::RightLabel>,
    #[prost(message, optional, tag = "16")]
    pub badge: ::core::option::Option<BadgeStruct>,
    #[prost(message, optional, tag = "20")]
    pub animation_data: ::core::option::Option<webcast_barrage_message::AnimationData>,
    #[prost(message, optional, tag = "24")]
    pub common_barrage_content: ::core::option::Option<Text>,
    #[prost(message, optional, tag = "100")]
    pub user_grade_param: ::core::option::Option<
        webcast_barrage_message::BarrageTypeUserGradeParam,
    >,
    #[prost(message, optional, tag = "101")]
    pub fans_level_param: ::core::option::Option<
        webcast_barrage_message::BarrageTypeFansLevelParam,
    >,
    #[prost(message, optional, tag = "102")]
    pub subscribe_gift_param: ::core::option::Option<
        webcast_barrage_message::BarrageTypeSubscribeGiftParam,
    >,
    #[prost(message, optional, tag = "104")]
    pub gift_gallery_params: ::core::option::Option<
        webcast_barrage_message::BarrageTypeGiftGalleryParam,
    >,
}
/// Nested message and enum types in `WebcastBarrageMessage`.
pub mod webcast_barrage_message {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BarrageEvent {
        #[prost(string, tag = "1")]
        pub event_name: ::prost::alloc::string::String,
        #[prost(map = "string, string", tag = "2")]
        pub params: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BarrageTypeUserGradeParam {
        #[prost(int32, tag = "1")]
        pub current_grade: i32,
        #[prost(int32, tag = "2")]
        pub display_config: i32,
        #[prost(string, tag = "3")]
        pub user_id: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "4")]
        pub user: ::core::option::Option<super::User>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BarrageTypeFansLevelParam {
        #[prost(int32, tag = "1")]
        pub current_grade: i32,
        #[prost(int32, tag = "2")]
        pub display_config: i32,
        #[prost(message, optional, tag = "4")]
        pub user: ::core::option::Option<super::User>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BarrageTypeSubscribeGiftParam {
        #[prost(int64, tag = "1")]
        pub gift_sub_count: i64,
        #[prost(bool, tag = "2")]
        pub show_gift_sub_count: bool,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AnimationData {
        #[prost(string, tag = "1")]
        pub gecko_channel_name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub file_name: ::prost::alloc::string::String,
        #[prost(int64, tag = "3")]
        pub height: i64,
        #[prost(int64, tag = "4")]
        pub width: i64,
        #[prost(int64, tag = "5")]
        pub right_offset: i64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BarrageTypeGiftGalleryParam {
        #[prost(int64, tag = "1")]
        pub from_user_id: i64,
        #[prost(int64, tag = "2")]
        pub to_user_id: i64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DisplayControl {
        #[prost(int32, tag = "1")]
        pub priority: i32,
        #[prost(int64, tag = "2")]
        pub duration: i64,
        #[prost(map = "int32, message", tag = "3")]
        pub target_group_show_rst: ::std::collections::HashMap<
            i32,
            display_control::ShowResult,
        >,
        #[prost(enumeration = "super::HorizontalOnclickTriggerType", tag = "4")]
        pub horizontal_trigger_type: i32,
    }
    /// Nested message and enum types in `DisplayControl`.
    pub mod display_control {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ShowResult {
            #[prost(bool, tag = "1")]
            pub banned: bool,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RightLabel {
        #[prost(string, tag = "1")]
        pub background_color: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub content: ::core::option::Option<super::Text>,
        #[prost(int64, tag = "3")]
        pub height: i64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BarrageType {
        Unknown = 0,
        EComOrdering = 1,
        EComBuying = 2,
        Normal = 3,
        Subscribe = 4,
        EventView = 5,
        EventRegistered = 6,
        SubscribeGift = 7,
        UserUpgrade = 8,
        GradeUserEntranceNotification = 9,
        FansLevelUpgrade = 10,
        FansLevelEntrance = 11,
        GamePartnership = 12,
        GiftGallery = 13,
        EComBought = 14,
        CommonBarrage = 100,
    }
    impl BarrageType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BarrageType::Unknown => "BARRAGE_TYPE_UNKNOWN",
                BarrageType::EComOrdering => "BARRAGE_TYPE_E_COM_ORDERING",
                BarrageType::EComBuying => "BARRAGE_TYPE_E_COM_BUYING",
                BarrageType::Normal => "BARRAGE_TYPE_NORMAL",
                BarrageType::Subscribe => "BARRAGE_TYPE_SUBSCRIBE",
                BarrageType::EventView => "BARRAGE_TYPE_EVENT_VIEW",
                BarrageType::EventRegistered => "BARRAGE_TYPE_EVENT_REGISTERED",
                BarrageType::SubscribeGift => "BARRAGE_TYPE_SUBSCRIBE_GIFT",
                BarrageType::UserUpgrade => "BARRAGE_TYPE_USER_UPGRADE",
                BarrageType::GradeUserEntranceNotification => {
                    "BARRAGE_TYPE_GRADE_USER_ENTRANCE_NOTIFICATION"
                }
                BarrageType::FansLevelUpgrade => "BARRAGE_TYPE_FANS_LEVEL_UPGRADE",
                BarrageType::FansLevelEntrance => "BARRAGE_TYPE_FANS_LEVEL_ENTRANCE",
                BarrageType::GamePartnership => "BARRAGE_TYPE_GAME_PARTNERSHIP",
                BarrageType::GiftGallery => "BARRAGE_TYPE_GIFT_GALLERY",
                BarrageType::EComBought => "BARRAGE_TYPE_E_COM_BOUGHT",
                BarrageType::CommonBarrage => "BARRAGE_TYPE_COMMON_BARRAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BARRAGE_TYPE_UNKNOWN" => Some(Self::Unknown),
                "BARRAGE_TYPE_E_COM_ORDERING" => Some(Self::EComOrdering),
                "BARRAGE_TYPE_E_COM_BUYING" => Some(Self::EComBuying),
                "BARRAGE_TYPE_NORMAL" => Some(Self::Normal),
                "BARRAGE_TYPE_SUBSCRIBE" => Some(Self::Subscribe),
                "BARRAGE_TYPE_EVENT_VIEW" => Some(Self::EventView),
                "BARRAGE_TYPE_EVENT_REGISTERED" => Some(Self::EventRegistered),
                "BARRAGE_TYPE_SUBSCRIBE_GIFT" => Some(Self::SubscribeGift),
                "BARRAGE_TYPE_USER_UPGRADE" => Some(Self::UserUpgrade),
                "BARRAGE_TYPE_GRADE_USER_ENTRANCE_NOTIFICATION" => {
                    Some(Self::GradeUserEntranceNotification)
                }
                "BARRAGE_TYPE_FANS_LEVEL_UPGRADE" => Some(Self::FansLevelUpgrade),
                "BARRAGE_TYPE_FANS_LEVEL_ENTRANCE" => Some(Self::FansLevelEntrance),
                "BARRAGE_TYPE_GAME_PARTNERSHIP" => Some(Self::GamePartnership),
                "BARRAGE_TYPE_GIFT_GALLERY" => Some(Self::GiftGallery),
                "BARRAGE_TYPE_E_COM_BOUGHT" => Some(Self::EComBought),
                "BARRAGE_TYPE_COMMON_BARRAGE" => Some(Self::CommonBarrage),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ShowType {
        Normal = 0,
        FadeInOut = 1,
    }
    impl ShowType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ShowType::Normal => "SHOW_TYPE_NORMAL",
                ShowType::FadeInOut => "SHOW_TYPE_FADE_IN_OUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SHOW_TYPE_NORMAL" => Some(Self::Normal),
                "SHOW_TYPE_FADE_IN_OUT" => Some(Self::FadeInOut),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RenderType {
        Native = 0,
        Hybrid = 1,
        Alpha = 2,
    }
    impl RenderType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RenderType::Native => "RENDER_TYPE_NATIVE",
                RenderType::Hybrid => "RENDER_TYPE_HYBRID",
                RenderType::Alpha => "RENDER_TYPE_ALPHA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RENDER_TYPE_NATIVE" => Some(Self::Native),
                "RENDER_TYPE_HYBRID" => Some(Self::Hybrid),
                "RENDER_TYPE_ALPHA" => Some(Self::Alpha),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IconDisplayType {
        Image = 0,
        Badge = 1,
    }
    impl IconDisplayType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                IconDisplayType::Image => "ICON_DISPLAY_TYPE_IMAGE",
                IconDisplayType::Badge => "ICON_DISPLAY_TYPE_BADGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ICON_DISPLAY_TYPE_IMAGE" => Some(Self::Image),
                "ICON_DISPLAY_TYPE_BADGE" => Some(Self::Badge),
                _ => None,
            }
        }
    }
}
/// Response from TikTokServer. Container for Messages
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoMessageFetchResult {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<BaseProtoMessage>,
    #[prost(string, tag = "2")]
    pub cursor: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub fetch_interval: i64,
    #[prost(int64, tag = "4")]
    pub now: i64,
    #[prost(string, tag = "5")]
    pub internal_ext: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub fetch_type: i32,
    #[prost(map = "string, string", tag = "7")]
    pub ws_params: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(int32, tag = "8")]
    pub heart_beat_duration: i32,
    #[prost(bool, tag = "9")]
    pub needs_ack: bool,
    #[prost(string, tag = "10")]
    pub ws_url: ::prost::alloc::string::String,
    #[prost(bool, tag = "11")]
    pub is_first: bool,
    #[prost(string, tag = "12")]
    pub history_comment_cursor: ::prost::alloc::string::String,
    #[prost(bool, tag = "13")]
    pub history_no_more: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BaseProtoMessage {
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "3")]
    pub msg_id: i64,
    #[prost(int32, tag = "4")]
    pub msg_type: i32,
    #[prost(int64, tag = "5")]
    pub offset: i64,
    #[prost(bool, tag = "6")]
    pub is_history: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastRoomMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub support_landscape: bool,
    #[prost(int64, tag = "4")]
    pub source: i64,
    #[prost(message, optional, tag = "5")]
    pub icon: ::core::option::Option<Image>,
    #[prost(enumeration = "Scene", tag = "6")]
    pub scene: i32,
    #[prost(bool, tag = "7")]
    pub is_welcome: bool,
    #[prost(message, optional, tag = "8")]
    pub public_area_common: ::core::option::Option<PublicAreaMessageCommon>,
    #[prost(int64, tag = "9")]
    pub show_duration_ms: i64,
    #[prost(string, tag = "10")]
    pub sub_scene: ::prost::alloc::string::String,
}
/// Closed Captioning for Video
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastCaptionMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(int64, tag = "2")]
    pub timestamp_ms: i64,
    #[prost(int64, tag = "3")]
    pub duration_ms: i64,
    #[prost(message, repeated, tag = "4")]
    pub content: ::prost::alloc::vec::Vec<webcast_caption_message::CaptionContent>,
    #[prost(int64, tag = "5")]
    pub sentence_id: i64,
    #[prost(int64, tag = "6")]
    pub sequence_id: i64,
    #[prost(bool, tag = "7")]
    pub definite: bool,
}
/// Nested message and enum types in `WebcastCaptionMessage`.
pub mod webcast_caption_message {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CaptionContent {
        #[prost(string, tag = "1")]
        pub lang: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub content: ::prost::alloc::string::String,
    }
}
/// System-Control Message from Room (e.g. Host ended Stream)
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastControlMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(enumeration = "ControlAction", tag = "2")]
    pub action: i32,
    #[prost(string, tag = "3")]
    pub tips: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub extra: ::core::option::Option<webcast_control_message::Extra>,
    #[prost(message, optional, tag = "5")]
    pub perception_dialog: ::core::option::Option<
        webcast_control_message::PerceptionDialogInfo,
    >,
    #[prost(message, optional, tag = "6")]
    pub perception_audience_text: ::core::option::Option<Text>,
    #[prost(message, optional, tag = "7")]
    pub punish_info: ::core::option::Option<PunishEventInfo>,
    #[prost(message, optional, tag = "8")]
    pub float_text: ::core::option::Option<Text>,
    #[prost(int32, tag = "9")]
    pub float_style: i32,
}
/// Nested message and enum types in `WebcastControlMessage`.
pub mod webcast_control_message {
    /// @Extra
    /// proto.webcast.im.ControlMessage
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Extra {
        #[prost(string, tag = "1")]
        pub ban_info_url: ::prost::alloc::string::String,
        #[prost(int64, tag = "2")]
        pub reason_no: i64,
        #[prost(message, optional, tag = "3")]
        pub title: ::core::option::Option<super::Text>,
        #[prost(message, optional, tag = "4")]
        pub violation_reason: ::core::option::Option<super::Text>,
        #[prost(message, optional, tag = "5")]
        pub content: ::core::option::Option<super::Text>,
        #[prost(message, optional, tag = "6")]
        pub got_it_button: ::core::option::Option<super::Text>,
        #[prost(message, optional, tag = "7")]
        pub ban_detail_button: ::core::option::Option<super::Text>,
        #[prost(string, tag = "8")]
        pub source: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PerceptionDialogInfo {
        #[prost(enumeration = "super::PerceptionDialogIconType", tag = "1")]
        pub icon_type: i32,
        #[prost(message, optional, tag = "2")]
        pub title: ::core::option::Option<super::Text>,
        #[prost(message, optional, tag = "3")]
        pub sub_title: ::core::option::Option<super::Text>,
        #[prost(message, optional, tag = "4")]
        pub advice_action_text: ::core::option::Option<super::Text>,
        #[prost(message, optional, tag = "5")]
        pub default_action_text: ::core::option::Option<super::Text>,
        #[prost(string, tag = "6")]
        pub violation_detail_url: ::prost::alloc::string::String,
        #[prost(enumeration = "super::Scene", tag = "7")]
        pub scene: i32,
        #[prost(int64, tag = "8")]
        pub target_user_id: i64,
        #[prost(int64, tag = "9")]
        pub target_room_id: i64,
        #[prost(int64, tag = "10")]
        pub count_down_time: i64,
        #[prost(bool, tag = "11")]
        pub show_feedback: bool,
        #[prost(message, repeated, tag = "12")]
        pub feedback_options: ::prost::alloc::vec::Vec<
            perception_dialog_info::PerceptionFeedbackOption,
        >,
        #[prost(int64, tag = "13")]
        pub policy_tip: i64,
        #[prost(int32, tag = "14")]
        pub appeal_popup: i32,
    }
    /// Nested message and enum types in `PerceptionDialogInfo`.
    pub mod perception_dialog_info {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct PerceptionFeedbackOption {
            #[prost(int64, tag = "1")]
            pub id: i64,
            #[prost(string, tag = "2")]
            pub content_key: ::prost::alloc::string::String,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastGoalUpdateMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(message, optional, tag = "2")]
    pub indicator: ::core::option::Option<LiveStreamGoalIndicator>,
    #[prost(message, optional, tag = "3")]
    pub goal: ::core::option::Option<LiveStreamGoal>,
    #[prost(int64, tag = "4")]
    pub contributor_id: i64,
    #[prost(message, optional, tag = "5")]
    pub contributor_avatar: ::core::option::Option<Image>,
    #[prost(string, tag = "6")]
    pub contributor_display_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub contribute_subgoal: ::core::option::Option<
        webcast_goal_update_message::LiveStreamSubGoal,
    >,
    #[prost(int64, tag = "9")]
    pub contribute_count: i64,
    #[prost(int64, tag = "10")]
    pub contribute_score: i64,
    #[prost(int64, tag = "11")]
    pub gift_repeat_count: i64,
    #[prost(string, tag = "12")]
    pub contributor_id_str: ::prost::alloc::string::String,
    #[prost(bool, tag = "13")]
    pub pin: bool,
    #[prost(bool, tag = "14")]
    pub unpin: bool,
    #[prost(message, optional, tag = "15")]
    pub pin_info: ::core::option::Option<webcast_goal_update_message::GoalPinInfo>,
    #[prost(enumeration = "GoalMessageSource", tag = "16")]
    pub update_source: i32,
    #[prost(string, tag = "17")]
    pub goal_extra: ::prost::alloc::string::String,
}
/// Nested message and enum types in `WebcastGoalUpdateMessage`.
pub mod webcast_goal_update_message {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LiveStreamSubGoal {
        #[prost(int32, tag = "1")]
        pub r#type: i32,
        #[prost(int64, tag = "2")]
        pub id: i64,
        #[prost(int64, tag = "3")]
        pub progress: i64,
        #[prost(int64, tag = "4")]
        pub target: i64,
        #[prost(message, optional, tag = "5")]
        pub gift: ::core::option::Option<live_stream_sub_goal::LiveStreamSubGoalGift>,
        #[prost(string, tag = "6")]
        pub id_str: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "7")]
        pub pin_info: ::core::option::Option<live_stream_sub_goal::SubGoalPinInfo>,
        #[prost(int32, tag = "8")]
        pub source: i32,
        #[prost(string, tag = "9")]
        pub recommended_text: ::prost::alloc::string::String,
        #[prost(string, tag = "10")]
        pub recommended_common: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `LiveStreamSubGoal`.
    pub mod live_stream_sub_goal {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct LiveStreamSubGoalGift {
            #[prost(string, tag = "1")]
            pub name: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "2")]
            pub icon: ::core::option::Option<super::super::Image>,
            #[prost(int64, tag = "3")]
            pub diamond_count: i64,
            #[prost(int32, tag = "4")]
            pub r#type: i32,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SubGoalPinInfo {
            #[prost(int64, tag = "1")]
            pub pin_start_time: i64,
            #[prost(int64, tag = "2")]
            pub pin_end_time: i64,
            #[prost(int64, tag = "3")]
            pub pin_ready_time: i64,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GoalPinInfo {
        #[prost(bool, tag = "1")]
        pub pin: bool,
        #[prost(bool, tag = "2")]
        pub unpin: bool,
        #[prost(int64, tag = "3")]
        pub pin_end_time: i64,
        #[prost(int64, tag = "4")]
        pub sub_goal_id: i64,
        #[prost(string, tag = "5")]
        pub sub_goal_id_str: ::prost::alloc::string::String,
    }
}
/// Message related to Chat-moderation?
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastImDeleteMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(int64, repeated, tag = "2")]
    pub delete_msg_ids_list: ::prost::alloc::vec::Vec<i64>,
    #[prost(int64, repeated, tag = "3")]
    pub delete_user_ids_list: ::prost::alloc::vec::Vec<i64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastInRoomBannerMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(map = "string, string", tag = "2")]
    pub data: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(int32, tag = "3")]
    pub position: i32,
    #[prost(int32, tag = "4")]
    pub action_type: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastRankUpdateMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(message, repeated, tag = "2")]
    pub updates_list: ::prost::alloc::vec::Vec<webcast_rank_update_message::RankUpdate>,
    /// @warning Enum not found, should be GroupType
    #[prost(int64, tag = "3")]
    pub group_type: i64,
    #[prost(int64, tag = "5")]
    pub priority: i64,
    #[prost(message, repeated, tag = "6")]
    pub tabs_list: ::prost::alloc::vec::Vec<webcast_rank_update_message::RankTabInfo>,
    #[prost(bool, tag = "7")]
    pub is_animation_loop_play: bool,
    #[prost(bool, tag = "8")]
    pub animation_loop_for_off: bool,
    #[prost(message, repeated, tag = "9")]
    pub union_animation: ::prost::alloc::vec::Vec<
        webcast_rank_update_message::UnionAnimationInfo,
    >,
    #[prost(message, repeated, tag = "10")]
    pub tab_info: ::prost::alloc::vec::Vec<webcast_rank_update_message::RankListTabInfo>,
}
/// Nested message and enum types in `WebcastRankUpdateMessage`.
pub mod webcast_rank_update_message {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UnionAnimationInfo {
        #[prost(enumeration = "super::UnionAnimationInfoType", tag = "1")]
        pub union_type: i32,
        #[prost(enumeration = "super::ProfitRankType", tag = "2")]
        pub rank_type_array: i32,
        #[prost(int64, tag = "3")]
        pub supported_version: i64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RankListTabInfo {
        #[prost(message, repeated, tag = "1")]
        pub tabs: ::prost::alloc::vec::Vec<RankTabInfo>,
        #[prost(int64, tag = "2")]
        pub supported_version: i64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RankTabInfo {
        #[prost(enumeration = "super::ProfitRankType", tag = "1")]
        pub rank_type: i32,
        #[prost(string, tag = "2")]
        pub title: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub title_text: ::core::option::Option<super::Text>,
        #[prost(int64, tag = "4")]
        pub list_lynx_type: i64,
    }
    /// @RankUpdate
    /// proto.webcast.im.RankUpdateMessage
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RankUpdate {
        /// @warning Enum not found, should be RankType
        #[prost(int64, tag = "1")]
        pub rank_type: i64,
        #[prost(int64, tag = "2")]
        pub owner_rank: i64,
        #[prost(message, optional, tag = "3")]
        pub default_content: ::core::option::Option<super::Text>,
        #[prost(bool, tag = "5")]
        pub show_entrance_animation: bool,
        #[prost(int64, tag = "6")]
        pub countdown: i64,
        /// @warning Enum not found, should be RelatedTabRankType
        #[prost(int64, tag = "8")]
        pub related_tab_rank_type: i64,
        /// @warning Enum not found, should be RequestFirstShowType
        #[prost(int64, tag = "9")]
        pub request_first_show_type: i64,
        #[prost(int64, tag = "10")]
        pub supported_version: i64,
        #[prost(bool, tag = "11")]
        pub owneronrank: bool,
    }
}
/// --- HandMade --
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastPollMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(enumeration = "MessageType", tag = "2")]
    pub message_type: i32,
    #[prost(int64, tag = "3")]
    pub poll_id: i64,
    #[prost(message, optional, tag = "4")]
    pub start_content: ::core::option::Option<PollStartContent>,
    #[prost(message, optional, tag = "5")]
    pub end_content: ::core::option::Option<PollEndContent>,
    #[prost(message, optional, tag = "6")]
    pub update_content: ::core::option::Option<PollUpdateVotesContent>,
    #[prost(enumeration = "PollKind", tag = "7")]
    pub poll_kind: i32,
    #[prost(message, optional, tag = "8")]
    pub poll_basic_info: ::core::option::Option<webcast_poll_message::PollBasicInfo>,
    #[prost(message, optional, tag = "9")]
    pub template_content: ::core::option::Option<webcast_poll_message::TemplateContent>,
}
/// Nested message and enum types in `WebcastPollMessage`.
pub mod webcast_poll_message {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TemplateContent {
        #[prost(int64, tag = "1")]
        pub template_id: i64,
        #[prost(string, tag = "2")]
        pub template_id_str: ::prost::alloc::string::String,
        #[prost(enumeration = "super::PollTemplateStatus", tag = "3")]
        pub status: i32,
        #[prost(enumeration = "super::PollKind", tag = "4")]
        pub poll_kind: i32,
        #[prost(enumeration = "super::PollAppealStatus", tag = "5")]
        pub appeal_status: i32,
        #[prost(string, tag = "6")]
        pub violation_id_str: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PollBasicInfo {
        #[prost(string, tag = "1")]
        pub poll_sponsor: ::prost::alloc::string::String,
        #[prost(int64, tag = "2")]
        pub gift_id: i64,
        #[prost(string, tag = "3")]
        pub title: ::prost::alloc::string::String,
        #[prost(bool, tag = "4")]
        pub is_suggested_question: bool,
        #[prost(int64, tag = "5")]
        pub user_cnt: i64,
        #[prost(message, optional, tag = "6")]
        pub gift: ::core::option::Option<super::Gift>,
        #[prost(string, tag = "7")]
        pub poll_id_str: ::prost::alloc::string::String,
        #[prost(string, tag = "8")]
        pub suggested_question_key: ::prost::alloc::string::String,
        #[prost(int64, tag = "9")]
        pub poll_duration: i64,
        #[prost(int64, tag = "10")]
        pub time_remain: i64,
        #[prost(int64, tag = "11")]
        pub poll_index: i64,
        #[prost(int64, tag = "12")]
        pub template_id: i64,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastRankTextMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(enumeration = "RankTestMessageScene", tag = "2")]
    pub scene: i32,
    #[prost(int64, tag = "3")]
    pub owner_idx_before_update: i64,
    #[prost(int64, tag = "4")]
    pub owner_idx_after_update: i64,
    #[prost(message, optional, tag = "5")]
    pub self_get_badge_msg: ::core::option::Option<Text>,
    #[prost(message, optional, tag = "6")]
    pub other_get_badge_msg: ::core::option::Option<Text>,
    #[prost(int64, tag = "7")]
    pub cur_user_id: i64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastLinkMicBattlePunishFinish {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(int64, tag = "2")]
    pub channel_id: i64,
    #[prost(int64, tag = "3")]
    pub op_uid: i64,
    #[prost(enumeration = "Reason", tag = "4")]
    pub reason: i32,
    #[prost(int64, tag = "5")]
    pub battle_id: i64,
    #[prost(message, optional, tag = "6")]
    pub battle_settings: ::core::option::Option<BattleSetting>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastLinkmicBattleTaskMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(enumeration = "BattleTaskMessageType", tag = "2")]
    pub battle_task_message_type: i32,
    #[prost(message, optional, tag = "3")]
    pub task_start: ::core::option::Option<
        webcast_linkmic_battle_task_message::BattleTaskStart,
    >,
    #[prost(message, optional, tag = "4")]
    pub task_update: ::core::option::Option<
        webcast_linkmic_battle_task_message::BattleTaskUpdate,
    >,
    #[prost(message, optional, tag = "5")]
    pub task_settle: ::core::option::Option<
        webcast_linkmic_battle_task_message::BattleTaskSettle,
    >,
    #[prost(message, optional, tag = "6")]
    pub reward_settle: ::core::option::Option<
        webcast_linkmic_battle_task_message::BattleRewardSettle,
    >,
    #[prost(int64, tag = "20")]
    pub battle_id: i64,
}
/// Nested message and enum types in `WebcastLinkmicBattleTaskMessage`.
pub mod webcast_linkmic_battle_task_message {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BattlePrompt {
        #[prost(string, tag = "1")]
        pub prompt_key: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "2")]
        pub prompt_elements: ::prost::alloc::vec::Vec<battle_prompt::BattlePromptElem>,
    }
    /// Nested message and enum types in `BattlePrompt`.
    pub mod battle_prompt {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct BattlePromptElem {
            #[prost(string, tag = "1")]
            pub prompt_field_key: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub prompt_field_value: ::prost::alloc::string::String,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BattleTaskStart {
        #[prost(message, optional, tag = "1")]
        pub battle_bonus_config: ::core::option::Option<
            battle_task_start::BattleBonusConfig,
        >,
    }
    /// Nested message and enum types in `BattleTaskStart`.
    pub mod battle_task_start {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct BattleBonusConfig {
            #[prost(int64, tag = "1")]
            pub preview_start_time: i64,
            #[prost(message, repeated, tag = "2")]
            pub preview_period_config: ::prost::alloc::vec::Vec<
                battle_bonus_config::PreviewPeriod,
            >,
            #[prost(message, optional, tag = "3")]
            pub task_period_config: ::core::option::Option<
                battle_bonus_config::TaskPeriodConfig,
            >,
            #[prost(message, optional, tag = "4")]
            pub reward_period_config: ::core::option::Option<
                battle_bonus_config::RewardPeriodConfig,
            >,
            #[prost(map = "int64, message", tag = "5")]
            pub task_gift_guide: ::std::collections::HashMap<
                i64,
                battle_bonus_config::BattleTaskGiftAmountGuide,
            >,
            #[prost(int64, tag = "6")]
            pub preview_start_timestamp: i64,
            #[prost(string, tag = "7")]
            pub preview_click_action_schema_url: ::prost::alloc::string::String,
        }
        /// Nested message and enum types in `BattleBonusConfig`.
        pub mod battle_bonus_config {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct PreviewPeriod {
                #[prost(int64, tag = "1")]
                pub duration: i64,
                #[prost(message, optional, tag = "2")]
                pub promot: ::core::option::Option<super::super::BattlePrompt>,
                #[prost(message, optional, tag = "25")]
                pub icon: ::core::option::Option<super::super::super::Image>,
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct TaskPeriodConfig {
                #[prost(int64, tag = "1")]
                pub task_start_time: i64,
                #[prost(int64, tag = "2")]
                pub duration: i64,
                #[prost(int64, tag = "3")]
                pub target_start_timestamp: i64,
                #[prost(int32, tag = "11")]
                pub click_action: i32,
                #[prost(message, optional, tag = "12")]
                pub click_toast_prompt: ::core::option::Option<
                    super::super::BattlePrompt,
                >,
                #[prost(int32, tag = "21")]
                pub prompt_type: i32,
                #[prost(message, optional, tag = "22")]
                pub task_static_prompt: ::core::option::Option<
                    super::super::BattlePrompt,
                >,
                #[prost(int64, tag = "23")]
                pub progress_target: i64,
                #[prost(int32, tag = "24")]
                pub target_type: i32,
                #[prost(message, optional, tag = "25")]
                pub icon: ::core::option::Option<super::super::super::Image>,
                #[prost(string, tag = "26")]
                pub click_action_schema_url: ::prost::alloc::string::String,
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct RewardPeriodConfig {
                #[prost(int64, tag = "1")]
                pub reward_start_time: i64,
                #[prost(int64, tag = "2")]
                pub duration: i64,
                #[prost(int32, tag = "3")]
                pub reward_multiple: i32,
                #[prost(int64, tag = "4")]
                pub reward_start_timestamp: i64,
                #[prost(message, optional, tag = "11")]
                pub reward_prapare_prompt: ::core::option::Option<
                    super::super::BattlePrompt,
                >,
                #[prost(message, optional, tag = "12")]
                pub rewarding_prompt: ::core::option::Option<super::super::BattlePrompt>,
                #[prost(message, optional, tag = "13")]
                pub click_prompt: ::core::option::Option<super::super::BattlePrompt>,
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct BattleTaskGiftAmountGuide {
                #[prost(message, optional, tag = "1")]
                pub guide_prompt: ::core::option::Option<super::super::BattlePrompt>,
                #[prost(int32, tag = "2")]
                pub prompt_type: i32,
                #[prost(int32, tag = "3")]
                pub disappear_duration: i32,
                #[prost(message, optional, tag = "11")]
                pub icon_image: ::core::option::Option<super::super::super::Image>,
                #[prost(message, optional, tag = "12")]
                pub gift_image: ::core::option::Option<super::super::super::Image>,
                #[prost(int64, tag = "21")]
                pub recommend_gift_id: i64,
                #[prost(int32, tag = "22")]
                pub recommend_gift_count: i32,
                #[prost(message, optional, tag = "23")]
                pub guide_content: ::core::option::Option<super::super::super::Text>,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BattleTaskUpdate {
        #[prost(int64, tag = "1")]
        pub task_progress: i64,
        #[prost(int64, tag = "2")]
        pub from_user_uid: i64,
        #[prost(string, tag = "3")]
        pub prompt_key: ::prost::alloc::string::String,
        #[prost(string, tag = "21")]
        pub log_id: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BattleTaskSettle {
        #[prost(enumeration = "battle_task_settle::Result", tag = "1")]
        pub task_result: i32,
        #[prost(int64, tag = "2")]
        pub reward_start_time: i64,
        #[prost(int64, tag = "3")]
        pub reward_start_timestamp: i64,
    }
    /// Nested message and enum types in `BattleTaskSettle`.
    pub mod battle_task_settle {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Result {
            Succeed = 0,
            Failed = 1,
            BothSucceed = 2,
        }
        impl Result {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Result::Succeed => "RESULT_SUCCEED",
                    Result::Failed => "RESULT_FAILED",
                    Result::BothSucceed => "RESULT_BOTH_SUCCEED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "RESULT_SUCCEED" => Some(Self::Succeed),
                    "RESULT_FAILED" => Some(Self::Failed),
                    "RESULT_BOTH_SUCCEED" => Some(Self::BothSucceed),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BattleRewardSettle {
        #[prost(message, optional, tag = "1")]
        pub reward_settle_prompt: ::core::option::Option<BattlePrompt>,
        #[prost(enumeration = "super::RewardStatus", tag = "2")]
        pub status: i32,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastLinkMicFanTicketMethod {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(message, optional, tag = "2")]
    pub fan_ticket_room_notice: ::core::option::Option<FanTicketRoomNoticeContent>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastLinkMicMethod {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(enumeration = "MessageType", tag = "2")]
    pub message_type: i32,
    #[prost(string, tag = "3")]
    pub access_key: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub anchor_linkmic_id: i64,
    #[prost(int64, tag = "5")]
    pub user_id: i64,
    #[prost(int64, tag = "6")]
    pub fan_ticket: i64,
    #[prost(int64, tag = "7")]
    pub total_link_mic_fan_ticket: i64,
    #[prost(int64, tag = "8")]
    pub channel_id: i64,
    #[prost(int64, tag = "9")]
    pub layout: i64,
    #[prost(int64, tag = "10")]
    pub vendor: i64,
    #[prost(int64, tag = "11")]
    pub dimension: i64,
    #[prost(string, tag = "12")]
    pub theme: ::prost::alloc::string::String,
    #[prost(int64, tag = "13")]
    pub invite_uid: i64,
    #[prost(int32, tag = "14")]
    pub reply: i32,
    #[prost(int32, tag = "16")]
    pub duration: i32,
    #[prost(int32, tag = "18")]
    pub match_type: i32,
    #[prost(bool, tag = "19")]
    pub win: bool,
    #[prost(string, tag = "20")]
    pub prompts: ::prost::alloc::string::String,
    #[prost(int64, tag = "21")]
    pub to_user_id: i64,
    #[prost(string, tag = "25")]
    pub tips: ::prost::alloc::string::String,
    #[prost(int64, tag = "26")]
    pub start_time_ms: i64,
    #[prost(int32, tag = "27")]
    pub confluence_type: i32,
    #[prost(int64, tag = "28")]
    pub from_room_id: i64,
    #[prost(int32, tag = "29")]
    pub invite_type: i32,
    #[prost(int64, tag = "30")]
    pub sub_type: i64,
    #[prost(string, tag = "32")]
    pub rtc_ext_info: ::prost::alloc::string::String,
    #[prost(string, tag = "34")]
    pub app_id: ::prost::alloc::string::String,
    #[prost(string, tag = "35")]
    pub app_sign: ::prost::alloc::string::String,
    #[prost(string, tag = "37")]
    pub anchor_link_mic_id_str: ::prost::alloc::string::String,
    #[prost(int64, tag = "38")]
    pub rival_anchor_id: i64,
    #[prost(int32, tag = "39")]
    pub rival_linkmic_id: i32,
    #[prost(string, tag = "40")]
    pub rival_linkmic_id_str: ::prost::alloc::string::String,
    #[prost(bool, tag = "41")]
    pub should_show_popup: bool,
    #[prost(bool, tag = "51")]
    pub rtc_join_channel: bool,
    #[prost(int32, tag = "52")]
    pub fan_ticket_type: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastUnauthorizedMemberMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(int32, tag = "2")]
    pub action: i32,
    #[prost(message, optional, tag = "3")]
    pub nick_name_prefix: ::core::option::Option<Text>,
    #[prost(string, tag = "4")]
    pub nick_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub enter_text: ::core::option::Option<Text>,
    #[prost(message, optional, tag = "6")]
    pub public_area_common: ::core::option::Option<PublicAreaMessageCommon>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastMsgDetectMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(int32, tag = "2")]
    pub detect_type: i32,
    #[prost(message, optional, tag = "3")]
    pub trigger_condition: ::core::option::Option<
        webcast_msg_detect_message::TriggerCondition,
    >,
    #[prost(message, optional, tag = "4")]
    pub time_info: ::core::option::Option<webcast_msg_detect_message::TimeInfo>,
    #[prost(int32, tag = "5")]
    pub trigger_by: i32,
    #[prost(string, tag = "6")]
    pub from_region: ::prost::alloc::string::String,
}
/// Nested message and enum types in `WebcastMsgDetectMessage`.
pub mod webcast_msg_detect_message {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TimeInfo {
        #[prost(int64, tag = "1")]
        pub client_start_ms: i64,
        #[prost(int64, tag = "2")]
        pub api_recv_time_ms: i64,
        #[prost(int64, tag = "3")]
        pub api_send_to_goim_ms: i64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TriggerCondition {
        #[prost(bool, tag = "1")]
        pub uplink_detect_http: bool,
        #[prost(bool, tag = "2")]
        pub uplink_detect_web_socket: bool,
        #[prost(bool, tag = "3")]
        pub detect_p2p_msg: bool,
        #[prost(bool, tag = "4")]
        pub detect_room_msg: bool,
        #[prost(bool, tag = "5")]
        pub http_optimize: bool,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastOecLiveShoppingMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(uint32, tag = "2")]
    pub data1: u32,
    #[prost(message, optional, tag = "4")]
    pub shop_data: ::core::option::Option<
        webcast_oec_live_shopping_message::LiveShoppingData,
    >,
    /// Uses index 1, 2 & 3
    #[prost(message, optional, tag = "5")]
    pub shop_timings: ::core::option::Option<TimeStampContainer>,
    #[prost(message, optional, tag = "9")]
    pub details: ::core::option::Option<
        webcast_oec_live_shopping_message::LiveShoppingDetails,
    >,
}
/// Nested message and enum types in `WebcastOecLiveShoppingMessage`.
pub mod webcast_oec_live_shopping_message {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LiveShoppingData {
        #[prost(string, tag = "1")]
        pub title: ::prost::alloc::string::String,
        /// $55.99
        #[prost(string, tag = "2")]
        pub price_string: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub image_url: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub shop_url: ::prost::alloc::string::String,
        #[prost(uint64, tag = "6")]
        pub data1: u64,
        /// "Shopify"
        #[prost(string, tag = "7")]
        pub shop_name: ::prost::alloc::string::String,
        #[prost(uint64, tag = "8")]
        pub data2: u64,
        #[prost(string, tag = "9")]
        pub shop_url2: ::prost::alloc::string::String,
        #[prost(uint64, tag = "10")]
        pub data3: u64,
        #[prost(uint64, tag = "11")]
        pub data4: u64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LiveShoppingDetails {
        #[prost(string, tag = "1")]
        pub id1: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub data1: ::prost::alloc::string::String,
        #[prost(uint32, tag = "4")]
        pub data2: u32,
        #[prost(uint64, tag = "5")]
        pub timestamp: u64,
        #[prost(message, optional, tag = "6")]
        pub data: ::core::option::Option<super::ValueLabel>,
    }
}
/// Host Pins comment to stream
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastRoomPinMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(string, tag = "30")]
    pub method: ::prost::alloc::string::String,
    #[prost(int64, tag = "31")]
    pub pin_time: i64,
    #[prost(message, optional, tag = "32")]
    pub operator: ::core::option::Option<User>,
    #[prost(int32, tag = "33")]
    pub action: i32,
    #[prost(int64, tag = "34")]
    pub display_duration: i64,
    #[prost(int64, tag = "35")]
    pub pin_id: i64,
    #[prost(string, tag = "36")]
    pub ec_streamer_key: ::prost::alloc::string::String,
    #[prost(oneof = "webcast_room_pin_message::WebcastMsg", tags = "2, 3, 4, 5, 6")]
    pub webcast_msg: ::core::option::Option<webcast_room_pin_message::WebcastMsg>,
}
/// Nested message and enum types in `WebcastRoomPinMessage`.
pub mod webcast_room_pin_message {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum WebcastMsg {
        #[prost(message, tag = "2")]
        ChatMessage(super::WebcastChatMessage),
        #[prost(message, tag = "3")]
        SocialMessage(super::WebcastSocialMessage),
        #[prost(message, tag = "4")]
        GiftMessage(super::WebcastGiftMessage),
        #[prost(message, tag = "5")]
        MemberMessage(super::WebcastMemberMessage),
        #[prost(message, tag = "6")]
        LikeMessage(super::WebcastLikeMessage),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastLinkMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(enumeration = "LinkMessageType", tag = "2")]
    pub message_type: i32,
    #[prost(int64, tag = "3")]
    pub linker_id: i64,
    #[prost(enumeration = "Scene", tag = "4")]
    pub scene: i32,
    #[prost(message, optional, tag = "5")]
    pub invite_content: ::core::option::Option<LinkerInviteContent>,
    #[prost(message, optional, tag = "6")]
    pub reply_content: ::core::option::Option<LinkerReplyContent>,
    #[prost(message, optional, tag = "7")]
    pub create_content: ::core::option::Option<LinkerCreateContent>,
    #[prost(message, optional, tag = "8")]
    pub close_content: ::core::option::Option<LinkerCloseContent>,
    #[prost(message, optional, tag = "9")]
    pub enter_content: ::core::option::Option<LinkerEnterContent>,
    #[prost(message, optional, tag = "10")]
    pub leave_content: ::core::option::Option<LinkerLeaveContent>,
    #[prost(message, optional, tag = "11")]
    pub cancel_content: ::core::option::Option<LinkerCancelContent>,
    #[prost(message, optional, tag = "12")]
    pub kick_out_content: ::core::option::Option<LinkerKickOutContent>,
    #[prost(message, optional, tag = "13")]
    pub linked_list_change_content: ::core::option::Option<
        LinkerLinkedListChangeContent,
    >,
    #[prost(message, optional, tag = "14")]
    pub update_user_content: ::core::option::Option<LinkerUpdateUserContent>,
    #[prost(message, optional, tag = "15")]
    pub waiting_list_change_content: ::core::option::Option<
        LinkerWaitingListChangeContent,
    >,
    #[prost(message, optional, tag = "16")]
    pub mute_content: ::core::option::Option<LinkerMuteContent>,
    #[prost(message, optional, tag = "17")]
    pub random_match_content: ::core::option::Option<LinkerRandomMatchContent>,
    #[prost(message, optional, tag = "18")]
    pub update_user_setting_content: ::core::option::Option<
        LinkerUpdateUserSettingContent,
    >,
    #[prost(message, optional, tag = "19")]
    pub mic_idx_update_content: ::core::option::Option<LinkerMicIdxUpdateContent>,
    #[prost(message, optional, tag = "20")]
    pub list_change_content: ::core::option::Option<LinkerListChangeContent>,
    #[prost(message, optional, tag = "21")]
    pub cohost_list_change_content: ::core::option::Option<CohostListChangeContent>,
    #[prost(message, optional, tag = "22")]
    pub media_change_content: ::core::option::Option<LinkerMediaChangeContent>,
    #[prost(message, optional, tag = "23")]
    pub accept_notice_content: ::core::option::Option<LinkerAcceptNoticeContent>,
    #[prost(message, optional, tag = "101")]
    pub sys_kick_out_content: ::core::option::Option<LinkerSysKickOutContent>,
    #[prost(message, optional, tag = "102")]
    pub user_toast_content: ::core::option::Option<LinkmicUserToastContent>,
    #[prost(string, tag = "200")]
    pub extra: ::prost::alloc::string::String,
    #[prost(int64, tag = "201")]
    pub expire_timestamp: i64,
    #[prost(string, tag = "202")]
    pub transfer_extra: ::prost::alloc::string::String,
}
/// @WebcastLinkLayerMessage
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastLinkLayerMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(enumeration = "MessageType", tag = "2")]
    pub message_type: i32,
    #[prost(int64, tag = "3")]
    pub channel_id: i64,
    #[prost(enumeration = "Scene", tag = "4")]
    pub scene: i32,
    #[prost(string, tag = "5")]
    pub source: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub centerized_idc: ::prost::alloc::string::String,
    #[prost(int64, tag = "7")]
    pub rtc_room_id: i64,
    #[prost(message, optional, tag = "100")]
    pub create_channel_content: ::core::option::Option<CreateChannelContent>,
    #[prost(message, optional, tag = "102")]
    pub list_change_content: ::core::option::Option<ListChangeContent>,
    #[prost(message, optional, tag = "103")]
    pub invite_content: ::core::option::Option<InviteContent>,
    #[prost(message, optional, tag = "104")]
    pub apply_content: ::core::option::Option<ApplyContent>,
    #[prost(message, optional, tag = "105")]
    pub permit_apply_content: ::core::option::Option<PermitApplyContent>,
    #[prost(message, optional, tag = "106")]
    pub reply_invite_content: ::core::option::Option<ReplyInviteContent>,
    #[prost(message, optional, tag = "107")]
    pub kick_out_content: ::core::option::Option<KickOutContent>,
    #[prost(message, optional, tag = "108")]
    pub cancel_apply_content: ::core::option::Option<CancelApplyContent>,
    #[prost(message, optional, tag = "109")]
    pub cancel_invite_content: ::core::option::Option<CancelInviteContent>,
    #[prost(message, optional, tag = "110")]
    pub leave_content: ::core::option::Option<LeaveContent>,
    #[prost(message, optional, tag = "111")]
    pub finish_content: ::core::option::Option<FinishChannelContent>,
    #[prost(message, optional, tag = "112")]
    pub join_direct_content: ::core::option::Option<JoinDirectContent>,
    #[prost(message, optional, tag = "113")]
    pub join_group_content: ::core::option::Option<JoinGroupContent>,
    #[prost(message, optional, tag = "114")]
    pub permit_group_content: ::core::option::Option<PermitJoinGroupContent>,
    #[prost(message, optional, tag = "115")]
    pub cancel_group_content: ::core::option::Option<CancelJoinGroupContent>,
    #[prost(message, optional, tag = "116")]
    pub leave_group_content: ::core::option::Option<LeaveJoinGroupContent>,
    #[prost(message, optional, tag = "117")]
    pub p2p_group_change_content: ::core::option::Option<P2pGroupChangeContent>,
    #[prost(message, optional, tag = "118")]
    pub group_change_content: ::core::option::Option<GroupChangeContent>,
    #[prost(message, optional, tag = "200")]
    pub business_content: ::core::option::Option<BusinessContent>,
}
/// @RoomVerifyMessage
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoomVerifyMessage {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<CommonMessageData>,
    #[prost(int32, tag = "2")]
    pub action: i32,
    #[prost(string, tag = "3")]
    pub content: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub notice_type: i64,
    #[prost(bool, tag = "5")]
    pub close_room: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastBarrageMessageOld {
    #[prost(message, optional, tag = "1")]
    pub event: ::core::option::Option<CommonMessageData>,
    #[prost(int32, tag = "3")]
    pub msg_type: i32,
    #[prost(message, optional, tag = "5")]
    pub content: ::core::option::Option<webcast_barrage_message_old::Text>,
}
/// Nested message and enum types in `WebcastBarrageMessage_Old`.
pub mod webcast_barrage_message_old {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Text {
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub default_pattern: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "4")]
        pub pieces: ::prost::alloc::vec::Vec<TextPiece>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TextPiece {
        #[prost(int32, tag = "1")]
        pub r#type: i32,
        #[prost(string, tag = "11")]
        pub string_value: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "21")]
        pub user_value: ::core::option::Option<TextPieceUser>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TextPieceUser {
        #[prost(message, optional, tag = "1")]
        pub user: ::core::option::Option<super::User>,
        #[prost(bool, tag = "2")]
        pub with_colon: bool,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebcastImEnterRoomMessage {
    /// sent
    #[prost(int64, tag = "1")]
    pub room_id: i64,
    /// Not sent, even when there is a hashtag on the room
    #[prost(string, tag = "2")]
    pub room_tag: ::prost::alloc::string::String,
    /// not sent
    #[prost(string, tag = "3")]
    pub live_region: ::prost::alloc::string::String,
    /// "12" <- It's a STATIC value for all streams, I checked the decompiled proto
    #[prost(int64, tag = "4")]
    pub live_id: i64,
    /// "audience"
    #[prost(string, tag = "5")]
    pub identity: ::prost::alloc::string::String,
    /// ""
    #[prost(string, tag = "6")]
    pub cursor: ::prost::alloc::string::String,
    /// 0
    #[prost(int64, tag = "7")]
    pub account_type: i64,
    /// NOT sent
    #[prost(int64, tag = "8")]
    pub enter_unique_id: i64,
    /// "0"
    #[prost(string, tag = "9")]
    pub filter_welcome_msg: ::prost::alloc::string::String,
    /// 0
    #[prost(bool, tag = "10")]
    pub is_anchor_continue_keep_msg: bool,
}
